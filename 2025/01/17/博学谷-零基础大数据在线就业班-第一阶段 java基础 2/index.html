<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>博学谷-零基础大数据在线就业班-第一阶段 java基础2 | Tech智汇站</title><meta name="keywords" content="大数据"><meta name="author" content="智汇君"><meta name="copyright" content="智汇君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="博学谷-零基础大数据在线就业班-第一阶段 java基础2"><meta name="application-name" content="博学谷-零基础大数据在线就业班-第一阶段 java基础2"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="博学谷-零基础大数据在线就业班-第一阶段 java基础2"><meta property="og:url" content="http://example.com/2025/01/17/博学谷-零基础大数据在线就业班-第一阶段 java基础 2/index.html"><meta property="og:site_name" content="Tech智汇站"><meta property="og:description" content="博学谷-零基础大数据在线就业班-第一阶段 java基础 2泛型(廖雪峰)1泛型是一种“代码模板”，可以用一套代码套用各种类型。  什么是泛型123456789101112131415在讲解什么是泛型之前，我们先观察Java标准库提供的ArrayList，它可以看作“可变长度”的数组，因为用起来比数组"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta property="article:author" content="智汇君"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta name="description" content="博学谷-零基础大数据在线就业班-第一阶段 java基础 2泛型(廖雪峰)1泛型是一种“代码模板”，可以用一套代码套用各种类型。  什么是泛型123456789101112131415在讲解什么是泛型之前，我们先观察Java标准库提供的ArrayList，它可以看作“可变长度”的数组，因为用起来比数组"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80%202/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 智汇君","link":"链接: ","source":"来源: Tech智汇站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Tech智汇站',
  title: '博学谷-零基础大数据在线就业班-第一阶段 java基础2',
  postAI: '',
  pageFillDescription: '博学谷-零基础大数据在线就业班-第一阶段 java基础 2, 泛型(廖雪峰), 什么是泛型, 向上转型, 总结, 使用泛型, 省略T, 泛型接口, 总结, 编写泛型, 静态方法, 多个泛型类型, 小结, 擦拭法cashifa, Java泛型的局限, 不恰当的覆写方法, 泛型继承, 总结, extends通配符, extends通配符的作用, 使用extends限定T类型, 小结, super通配符, 对比extends和super通配符, PECS原则, 无限定通配符, 小结, 泛型和反射, 小结, 集合(廖雪峰), java集合简介, 使用List, 编写equals方法, 使用Map, 编写equals和hashCode, 使用EnumMap, 使用TreeMap, 使用Properties, 使用Set, 使用Queue, 使用PriorityQueue, 使用Deque, 使用Stack, 使用Iterator, 使用Collections, 多线程(廖雪峰), 多线程基础, 创建新线程, 线程的状态, 中断线程, 守护线程, 线程同步, 同步方法, 死锁, 使用wait和notify, 案例, 使用ReentrantLock, 使用Condition, 案例, ReadWriteLock, 案例, StampedLock, 案例, Semaphore, 案例, Concurrent, 案例, Atomic, 案例, 线程池, Future, CompletableFuture, ForkJoin, ThreadLocal, 虚拟线程, 网络编程, 网络编程基础, TCP编程, UDP编程, 发送Email, 接收Email, HTTP编程, RMI远程调用博学谷零基础大数据在线就业班第一阶段基础泛型廖雪峰泛型是一种代码模板可以用一套代码套用各种类型什么是泛型在讲解什么是泛型之前我们先观察标准库提供的它可以看作可变长度的数组因为用起来比数组更方便实际上内部就是一个数组配合存储一个当前分配的长度就可以充当可变数组如果用上述存储类型会有这么几个缺点需要强制转型不方便易出错例如代码必须这么写获取到必须强制转型为很容易出现因为容易误转型要解决上述问题我们可以为单独编写一种这样一来存入的必须是取出的也一定是不需要强制转型因为编译器会强制检查放入的类型编译错误不允许放入非类型问题暂时解决然而新的问题是如果要存储还需要为单独编写一种实际上还需要为其他所有单独编写一种这是不可能的的就有上千个而且它还不知道其他人编写的为了解决新的问题我们必须把变成一种模板代码如下可以是任何这样一来我们就实现了编写一次模版可以创建任意类型的创建可以存储的创建可以存储的创建可以存储的因此泛型就是定义一种模板例如然后在代码中为用到的类创建对应的类型由编译器针对类型作检查这样一来既实现了编写一次万能匹配又通过编译器保证了类型安全这就是泛型向上转型在标准库中的实现了接口它可以向上转型为即类型可以向上转型为要特别注意不能把向上转型为或这是为什么呢假设可以向上转型为观察一下代码创建类型添加一个向上转型为添加一个因为也是从获取索引为的元素即添加的我们把一个转型为类型后这个就可以接受类型因为是的子类但是实际上和是同一个对象也就是类型它不可能接受类型所以在获取的时候将产生实际上编译器为了避免这种错误根本就不允许把转型为和两者完全没有继承关系总结泛型就是编写模板代码来适应任意类型泛型的好处是使用时不必对类型进行强制转换它通过编译器对类型进行检查注意泛型的继承关系可以把向上转型为不能变但不能把向上转型为不能变成父类使用泛型使用时如果不定义泛型类型时泛型类型实际上就是编译器警告此时只能把当作使用没有发挥泛型的优势当我们定义泛型类型后的泛型接口变为强类型无编译器警告无强制转型当我们定义泛型类型后的泛型接口变为强类型省略编译器如果能自动推断出泛型类型就可以省略后面的泛型类型例如对于下面的代码编译器看到泛型类型就可以自动推断出后面的的泛型类型必须是因此可以把代码简写为可以省略后面的编译器可以自动推断泛型类型泛型接口除了使用了泛型还可以在接口中使用泛型例如可以对任意数组进行排序但待排序的元素必须实现这个泛型接口返回负数当前实例比参数小返回当前实例与参数相等返回正数当前实例比参数大可以直接对数组进行排序这是因为本身已经实现了接口如果换成我们自定义的类型试试运行程序我们会得到即无法将转型为我们修改代码让实现接口运行上述代码可以正确实现按进行排序也可以修改比较逻辑例如按从高到低排序请自行修改测试总结使用泛型时把泛型参数替换为需要的类型例如等可以省略编译器能自动推断出的类型例如不指定泛型参数类型时编译器会给出警告且只能将视为类型可以在接口中定义泛型类型实现此接口的类必须实现正确的泛型类型编写泛型编写泛型类比普通类要复杂通常来说泛型类一般用在集合类中例如我们很少需要编写泛型类如果我们确实需要编写一个泛型类那么应该如何编写它可以按照以下步骤来编写一个泛型类首先按照某种类型例如来编写类然后标记所有的特定类型这里是最后把特定类型替换为并申明熟练后即可直接从开始编写静态方法编写泛型类时要特别注意泛型类型不能用于静态方法例如对静态方法使用上述代码会导致编译错误我们无法在静态方法的方法参数和返回类型上使用泛型类型有些同学在网上搜索发现可以在修饰符后面加一个编译就能通过可以编译通过但实际上这个和类型的已经没有任何关系了对于静态方法我们可以单独改写为泛型方法只需要使用另一个类型即可对于上面的静态方法我们应该把它改为另一种泛型类型例如静态泛型方法应该使用其他类型区分这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开多个泛型类型泛型还可以定义多种类型例如我们希望不总是存储两个类型一样的对象就可以使用类型使用的时候需要指出两种类型标准库的就是使用两种泛型类型的例子它对使用一种类型对使用另一种类型小结编写泛型时需要定义泛型类型静态方法不能引用泛型类型必须定义其他类型例如来实现静态泛型方法泛型可以同时定义多种类型例如擦拭法泛型是一种类似模板代码的技术不同语言的泛型实现方式不一定相同语言的泛型实现方式是擦拭法所谓擦拭法是指虚拟机对泛型其实一无所知所有的工作都是编译器做的例如我们编写了一个泛型类这是编译器看到的代码而虚拟机根本不知道泛型这是虚拟机执行的代码因此使用擦拭法实现泛型导致了编译器把类型视为编译器根据实现安全的强制转型使用泛型的时候我们编写的代码也是编译器看到的代码而虚拟机执行的代码并没有泛型泛型的局限所以的泛型是由编译器在编译时实行的编译器内部永远把所有类型视为处理但是在需要转型的时候编译器会根据的类型自动为我们实行安全地强制转型了解了泛型的实现方式擦拭法我们就知道了泛型的局限局限一不能是基本类型例如因为实际类型是类型无法持有基本类型局限二无法取得带泛型的观察以下代码因为是我们对和类型获取时获取到的是同一个也就是类的换句话说所有泛型实例无论的类型是什么返回同一个实例因为编译后它们全部都是局限三无法判断带泛型的类型原因和前面一样并不存在而是只有唯一的局限四不能实例化类型上述代码无法通过编译因为构造方法的两行语句擦拭后实际上变成了这样一来创建和创建就全部成了显然编译器要阻止这种类型不对的代码要实例化类型我们必须借助额外的参数上述代码借助参数并通过反射来实例化类型使用的时候也必须传入例如因为传入了的实例所以我们借助就可以实例化类型不恰当的覆写方法有些时候一个看似正确定义的方法会无法通过编译例如这是因为定义的方法实际上会被擦拭成而这个方法是继承自的编译器会阻止一个实际上会变成覆写的泛型方法定义换个方法名避开与的冲突就可以成功编译泛型继承一个类可以继承自一个泛型类例如父类的类型是子类的类型是可以这么继承使用的时候因为子类并没有泛型类型所以正常使用即可前面讲了我们无法获取的类型即给定一个变量无法从中获取到类型前面讲了我们无法获取的类型即给定一个变量无法从中获取到类型但是在父类是泛型类型的情况下编译器就必须把类型对来说也就是类型保存到子类的文件中不然编译器就不知道只能存取这种类型在继承了泛型类型的情况下子类可以获取父类的泛型类型例如可以获取到父类的泛型类型获取父类的泛型类型代码比较复杂可能有多个泛型类型取第一个泛型类型因为引入了泛型所以只用来标识类型已经不够了实际上的类型系统结构如下总结的泛型是采用擦拭法实现的擦拭法决定了泛型不能是基本类型例如不能获取带泛型类型的例如不能判断带泛型类型的类型例如不能实例化类型例如泛型方法要防止重复定义方法例如子类可以获取父类的泛型类型通配符我们前面已经讲到了泛型的继承关系不是的子类假设我们定义了然后我们又针对类型写了一个静态方法它接收的参数类型是上述代码是可以正常编译的使用的时候我们传入注意传入的类型是实际参数类型是既然实际参数是类型试试传入直接运行会得到一个编译错误原因很明显因为不是的子类因此不接受参数类型但是从方法的代码可知传入是完全符合内部代码的类型规范因为语句实际类型是引用类型是没有问题问题在于方法参数类型定死了只能传入有没有办法使得方法参数接受办法是有的这就是使用使得方法接收所有泛型类型为或子类的类型我们把代码改写如下这样一来给方法传入类型时它符合参数类型这种使用的泛型定义称之为上界通配符即把泛型类型的上界限定在了除了可以传入类型我们还可以传入类型类型等等因为和都是的子类如果我们考察对类型调用方法实际的方法签名变成了即返回值是或的子类因此可以安全赋值给类型的变量然后我们不可预测实际类型就是例如下面的代码是无法通过编译的这是因为实际的返回类型可能是也可能是或者其他类型编译器只能确定类型一定是的子类包括类型本身但具体类型无法确定我们再来考察一下的方法不出意外我们会得到一个编译错误编译错误发生在传入的参数是类型有些童鞋会问了既然的定义是那么为什么不能传入原因还在于擦拭法如果我们传入的是显然它满足参数定义然而的显然无法接受类型这就是通配符的一个重要限制方法参数签名无法传递任何的子类型给这里唯一的例外是可以给方法参数传入但是后面会抛出通配符的作用如果我们考察标准库的接口它实现的是一个类似可变数组的列表主要功能包括获取个数根据索引获取指定元素添加一个新元素删除一个已有元素现在让我们定义一个方法来处理列表的每个元素为什么我们定义的方法参数类型是而不是从方法内部代码看传入或者是完全一样的但是注意到的限制允许调用方法获取的引用不允许调用方法并传入任何的引用除外因此方法参数类型表明了该方法内部只会读取的元素不会修改的元素因为无法调用这些方法换句话说这是一个对参数进行只读的方法恶意调用除外使用限定类型在定义泛型类型的时候也可以使用通配符来限定的类型现在我们只能定义因为和都符合非类型将无法通过编译因为都不符合因为它们不是类型或的子类小结使用类似通配符作为方法参数时表示方法内部可以调用获取引用的方法例如方法内部无法调用传入引用的方法除外例如即一句话总结使用通配符表示可以读不能写使用类似定义泛型类时表示泛型类型限定为以及的子类通配符我们前面已经讲到了泛型的继承关系不是的子类考察下面的方法传入是允许的但是传入是不允许的和通配符相反这次我们希望接受类型以及因为和是的父类和实际上允许接受类型我们使用通配符来改写这个方法注意到表示方法参数接受所有泛型类型为或父类的类型下面的代码可以被正常编译考察的方法它的方法签名实际上是因此可以安全地传入类型再考察的方法它的方法签名实际上是这里注意到我们无法使用类型来接收的返回值即下面的语句将无法通过编译因为如果传入的实际类型是编译器无法将类型转型为注意虽然是一个抽象类我们无法直接实例化它但是即便不是抽象类这里仍然无法通过编译此外传入类型时编译器也无法将类型转型为唯一可以接收方法返回值的是类型因此使用通配符表示允许调用方法传入的引用不允许调用方法获得的引用唯一例外是可以获取的引用换句话说使用通配符作为方法参数表示方法内部代码对于参数只能写不能读对比和通配符我们再回顾一下通配符作为方法参数类型和类型的区别在于允许调用读方法获取的引用但不允许调用写方法传入的引用传入除外允许调用写方法传入的引用但不允许调用读方法获取的引用获取除外一个是允许读不允许写另一个是允许写不允许读先记住上面的结论我们来看标准库的类定义的方法把的每个元素复制到中它的作用是把一个的每个元素依次添加到另一个中它的第一个参数是表示目标第二个参数表示要复制的我们可以简单地用循环实现复制在循环中我们可以看到对于类型的变量我们可以安全地获取类型的引用而对于类型的变量我们可以安全地传入的引用这个方法的定义就完美地展示了和的意图方法内部不会读取因为不能调用来获取的引用方法内部也不会修改因为不能调用这是由编译器检查来实现的如果在方法代码中意外修改了或者意外读取了就会导致一个编译错误把的每个元素复制到中这个方法的另一个好处是可以安全地把一个添加到但是无法反过来添加而这些都是通过和通配符并由编译器强制检查来实现的原则何时使用何时使用为了便于记忆我们可以用原则即如果需要返回它是生产者要使用通配符如果需要写入它是消费者要使用通配符还是以的方法为例是是需要返回的是生产者因此声明为需要写入的是消费者因此声明为无限定通配符我们已经讨论了和作为方法参数的作用实际上的泛型还允许使用无限定通配符即只定义一个因为通配符既没有也没有因此不允许调用方法并传入引用除外不允许调用方法并获取引用只能获取引用换句话说既不能读也不能写那只能做一些判断大多数情况下可以引入泛型参数消除通配符通配符有一个独特的特点就是是所有的超类安全地向上转型上述代码是可以正常编译运行的因为是的子类可以安全地向上转型小结使用类似通配符作为方法参数时表示方法内部可以调用传入引用的方法例如方法内部无法调用获取引用的方法除外例如即使用通配符表示只能写不能读使用和通配符要遵循原则无限定通配符很少使用可以用替换同时它是所有类型的超类泛型和反射的部分反射也是泛型例如就是泛型调用的方法返回的类型是构造方法也是泛型我们可以声明带泛型的数组但不能用操作符创建带泛型的数组必须通过强制转型实现带泛型的数组使用泛型数组要特别小心因为数组实际上在运行期没有泛型编译器可以强制检查变量因为它的类型是泛型数组但是编译器不会检查变量因为它不是泛型数组因为这两个变量实际上指向同一个数组所以操作可能导致从获取元素时报错例如以下代码演示了不安全地使用带泛型的数组要安全地使用泛型数组必须扔掉的引用上面的代码中由于拿不到原始数组的引用就只能对泛型数组进行操作这种操作就是安全的带泛型的数组实际上是编译器的类型擦除所以我们不能直接创建泛型数组因为擦拭后代码变为必须借助来创建泛型数组我们还可以利用可变参数创建泛型数组谨慎使用泛型可变参数在上面的例子中我们看到通过似乎可以安全地创建一个泛型数组但实际上这种方法非常危险以下代码来自的示例直接调用似乎没有问题但是在另一个方法中我们返回一个泛型数组就会产生原因还是因为擦拭法在方法内部编译器无法检测的正确类型因此返回了如果仔细观察可以发现编译器对所有可变泛型参数都会发出警告除非确认完全没有问题才可以用消除警告如果在方法内部创建了泛型数组最好不要将它返回给外部使用更详细的解释请参考小结部分反射是泛型例如可以声明带泛型的数组但不能直接创建带泛型的数组必须强制转型可以通过创建数组需要强制转型同时使用泛型和可变参数时需要特别小心集合廖雪峰集合简介使用编写方法使用编写和使用使用使用使用使用使用使用使用使用使用多线程廖雪峰多线程基础进程线程关系进程线程优缺点多任务实现方式创建新线程两种创建方法第二种有便捷方式不能直接要用优先级线程的状态中断线程当目标线程调用后调用方会捕获到异常标志位中断方法守护线程线程同步原子操作不需要的操作有些时候通过一些巧妙的转换可以把非原子操作变为原子操作不可变对象无需同步同步方法线程安全对于方法是没有实例的因为方法是针对类而不是实例但是我们注意到任何一个类都有一个由自动创建的实例因此对方法添加锁住的是该类的实例死锁死锁可重入锁使用和释放当前锁中使用让释放锁的线程从处获得锁只会唤醒其中一个具体哪个依赖操作系统有一定的随机性将唤醒所有当前正在锁等待的线程但只能有一个能获得锁案例释放锁重新获取锁唤醒在锁等待的线程执行放入使用可以替代进行同步也是可重入锁和不同的是可以尝试获取锁上述代码在尝试获取锁的时候最多等待秒如果秒后仍未获取到锁返回程序就可以做一些额外处理而不是无限等待下去使用可以实现的此外和类似可以在等待指定时间后如果还没有被其他线程通过或唤醒可以自己醒来被其他线程唤醒指定时间内没有被其他线程唤醒案例可以实现多个线程同时读不允许同时写只允许一个线程写不允许读允许多个线程同时读但只要有一个线程在写其他线程就必须等待案例注意一对读锁和写锁必须从同一个获取加写锁释放写锁加读锁释放读锁读的过程也可以写适合读的过程小概率发生写把读锁细分为乐观读和悲观读能进一步提升并发效率显然乐观锁的并发效率更高但一旦有小概率的写入导致读取的数据不一致需要能检测出来再读一遍就行不是可重入锁案例获取写锁释放写锁获得一个乐观读锁注意下面两行代码不是原子操作假设此处已读取到但可能被写线程修改为此处已读取到如果没有写入读取是正确的如果有写入读取是错误的检查乐观读锁后是否有其他写锁发生获取一个悲观读锁释放悲观读锁这种限制数量的锁本质上就是一个信号计数器用于限制同一时间的最大访问数量案例任意时刻仅允许最多个线程获取许可如果超过了许可数量其他线程将在此等待指定等待时间秒内获取到许可这个库提供了一些线程安全的集合尽量使用标准库提供的并发集合避免自己编写同步代码案例这个类封装了一些原子操作的类参考案例我们利用可以编写一个多线程安全的全局唯一生成器线程池固定大小动态调整固定区间范围计划线程池虚拟线程网络编程网络编程基础编程编程发送接收编程远程调用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-10 16:29:19',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Tech智汇站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 1.05rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 1.05rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 1.05rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 1.05rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>26</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 1.05rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 1.05rem;">廖雪峰<sup>9</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>12</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">74</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD/" itemprop="url">零基础大数据在线就业班</a></span></div></div><h1 class="post-title" itemprop="name headline">博学谷-零基础大数据在线就业班-第一阶段 java基础2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80%202/"><header><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD/" itemprop="url">零基础大数据在线就业班</a><h1 id="CrawlerTitle" itemprop="name headline">博学谷-零基础大数据在线就业班-第一阶段 java基础2</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">智汇君</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="undefined 2025-01-17 17:35:02">2025-01-17</time></header><h1 id="博学谷-零基础大数据在线就业班-第一阶段-java基础-2"><a href="#博学谷-零基础大数据在线就业班-第一阶段-java基础-2" class="headerlink" title="博学谷-零基础大数据在线就业班-第一阶段 java基础 2"></a>博学谷-零基础大数据在线就业班-第一阶段 java基础 2</h1><h2 id="泛型-廖雪峰"><a href="#泛型-廖雪峰" class="headerlink" title="泛型(廖雪峰)"></a>泛型(廖雪峰)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型是一种“代码模板”，可以用一套代码套用各种类型。</span><br></pre></td></tr></table></figure>

<h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在讲解什么是泛型之前，我们先观察Java标准库提供的ArrayList，它可以看作“可变长度”的数组，因为用起来比数组更方便。</span><br><span class="line"></span><br><span class="line">实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</span><br><span class="line"></span><br><span class="line">public class ArrayList &#123;</span><br><span class="line">    private Object[] array;</span><br><span class="line">    private int size;</span><br><span class="line">    public void add(Object e) &#123;...&#125;</span><br><span class="line">    public void remove(int index) &#123;...&#125;</span><br><span class="line">    public Object get(int index) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果用上述ArrayList存储String类型，会有这么几个缺点：</span><br><span class="line">需要强制转型；</span><br><span class="line">不方便，易出错。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例如，代码必须这么写：</span><br><span class="line"></span><br><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">// 获取到Object，必须强制转型为String:</span><br><span class="line">String first = (String) list.get(0);</span><br><span class="line">很容易出现ClassCastException，因为容易“误转型”：</span><br><span class="line"></span><br><span class="line">list.add(new Integer(123));</span><br><span class="line">// ERROR: ClassCastException:</span><br><span class="line">String second = (String) list.get(1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">要解决上述问题，我们可以为String单独编写一种ArrayList：</span><br><span class="line"></span><br><span class="line">public class StringArrayList &#123;</span><br><span class="line">    private String[] array;</span><br><span class="line">    private int size;</span><br><span class="line">    public void add(String e) &#123;...&#125;</span><br><span class="line">    public void remove(int index) &#123;...&#125;</span><br><span class="line">    public String get(int index) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型：</span><br><span class="line"></span><br><span class="line">StringArrayList list = new StringArrayList();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">String first = list.get(0);</span><br><span class="line"></span><br><span class="line">// 编译错误: 不允许放入非String类型:</span><br><span class="line">list.add(new Integer(123));</span><br><span class="line">问题暂时解决。</span><br><span class="line"></span><br><span class="line">然而，新的问题是，如果要存储Integer，还需要为Integer单独编写一种ArrayList：</span><br><span class="line"></span><br><span class="line">public class IntegerArrayList &#123;</span><br><span class="line">    private Integer[] array;</span><br><span class="line">    private int size;</span><br><span class="line">    public void add(Integer e) &#123;...&#125;</span><br><span class="line">    public void remove(int index) &#123;...&#125;</span><br><span class="line">    public Integer get(int index) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际上，还需要为其他所有class单独编写一种ArrayList：</span><br><span class="line"></span><br><span class="line">LongArrayList</span><br><span class="line">DoubleArrayList</span><br><span class="line">PersonArrayList</span><br><span class="line">...</span><br><span class="line">这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">为了解决新的问题，我们必须把ArrayList变成一种模板：ArrayList&lt;T&gt;，代码如下：</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;T&gt; &#123;</span><br><span class="line">    private T[] array;</span><br><span class="line">    private int size;</span><br><span class="line">    public void add(T e) &#123;...&#125;</span><br><span class="line">    public void remove(int index) &#123;...&#125;</span><br><span class="line">    public T get(int index) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList：</span><br><span class="line"></span><br><span class="line">// 创建可以存储String的ArrayList:</span><br><span class="line">ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">// 创建可以存储Float的ArrayList:</span><br><span class="line">ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;();</span><br><span class="line">// 创建可以存储Person的ArrayList:</span><br><span class="line">ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class="line">因此，泛型就是定义一种模板，例如ArrayList&lt;T&gt;，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;：</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由编译器针对类型作检查：</span><br><span class="line"></span><br><span class="line">strList.add(&quot;hello&quot;); // OK</span><br><span class="line">String s = strList.get(0); // OK</span><br><span class="line">strList.add(new Integer(123)); // compile error!</span><br><span class="line">Integer n = strList.get(0); // compile error!</span><br><span class="line">这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</span><br></pre></td></tr></table></figure>

<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Java标准库中的ArrayList&lt;T&gt;实现了List&lt;T&gt;接口，它可以向上转型为List&lt;T&gt;：</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;T&gt; implements List&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">即类型ArrayList&lt;T&gt;可以向上转型为List&lt;T&gt;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">要特别注意：不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。</span><br><span class="line"></span><br><span class="line">这是为什么呢？假设ArrayList&lt;Integer&gt;可以向上转型为ArrayList&lt;Number&gt;，观察一下代码：</span><br><span class="line"></span><br><span class="line">// 创建ArrayList&lt;Integer&gt;类型：</span><br><span class="line">ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">// 添加一个Integer：</span><br><span class="line">integerList.add(new Integer(123));</span><br><span class="line">// “向上转型”为ArrayList&lt;Number&gt;：</span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line">// 添加一个Float，因为Float也是Number：</span><br><span class="line">numberList.add(new Float(12.34));</span><br><span class="line">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span><br><span class="line">Integer n = integerList.get(1); // ClassCastException!</span><br><span class="line"></span><br><span class="line">我们把一个ArrayList&lt;Integer&gt;转型为ArrayList&lt;Number&gt;类型后，这个ArrayList&lt;Number&gt;就可以接受Float类型，因为Float是Number的子类。但是，ArrayList&lt;Number&gt;实际上和ArrayList&lt;Integer&gt;是同一个对象，也就是ArrayList&lt;Integer&gt;类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实际上，编译器为了避免这种错误，根本就不允许把ArrayList&lt;Integer&gt;转型为ArrayList&lt;Number&gt;。</span><br><span class="line"></span><br><span class="line"> ArrayList&lt;Integer&gt;和ArrayList&lt;Number&gt;两者完全没有继承关系。</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">泛型就是编写模板代码来适应任意类型；</span><br><span class="line"></span><br><span class="line">泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</span><br><span class="line"></span><br><span class="line">注意泛型的继承关系：可以把ArrayList&lt;Integer&gt;向上转型为List&lt;Integer&gt;（T不能变！），但不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;（T不能变成父类）。</span><br></pre></td></tr></table></figure>

<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object：</span><br><span class="line"></span><br><span class="line">// 编译器警告:</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">list.add(&quot;World&quot;);</span><br><span class="line">String first = (String) list.get(0);</span><br><span class="line">String second = (String) list.get(1);</span><br><span class="line">此时，只能把&lt;T&gt;当作Object使用，没有发挥泛型的优势。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当我们定义泛型类型&lt;String&gt;后，List&lt;T&gt;的泛型接口变为强类型List&lt;String&gt;：</span><br><span class="line"></span><br><span class="line">// 无编译器警告:</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">list.add(&quot;World&quot;);</span><br><span class="line">// 无强制转型:</span><br><span class="line">String first = list.get(0);</span><br><span class="line">String second = list.get(1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当我们定义泛型类型&lt;Number&gt;后，List&lt;T&gt;的泛型接口变为强类型List&lt;Number&gt;：</span><br><span class="line"></span><br><span class="line">List&lt;Number&gt; list = new ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(new Integer(123));</span><br><span class="line">list.add(new Double(12.34));</span><br><span class="line">Number first = list.get(0);</span><br><span class="line">Number second = list.get(1);</span><br></pre></td></tr></table></figure>

<h4 id="省略T"><a href="#省略T" class="headerlink" title="省略T"></a>省略T</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</span><br><span class="line"></span><br><span class="line">List&lt;Number&gt; list = new ArrayList&lt;Number&gt;();</span><br><span class="line">编译器看到泛型类型List&lt;Number&gt;就可以自动推断出后面的ArrayList&lt;T&gt;的泛型类型必须是ArrayList&lt;Number&gt;，因此，可以把代码简写为：</span><br><span class="line"></span><br><span class="line">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span><br><span class="line">List&lt;Number&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">除了ArrayList&lt;T&gt;使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable&lt;T&gt;这个泛型接口：</span><br><span class="line"></span><br><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 返回负数: 当前实例比参数o小</span><br><span class="line">     * 返回0: 当前实例与参数o相等</span><br><span class="line">     * 返回正数: 当前实例比参数o大</span><br><span class="line">     */</span><br><span class="line">    int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可以直接对String数组进行排序：</span><br><span class="line"></span><br><span class="line">// sort</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    String[] ss = new String[] &#123; &quot;Orange&quot;, &quot;Apple&quot;, &quot;Pear&quot; &#125;;</span><br><span class="line">        Arrays.sort(ss);</span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">这是因为String本身已经实现了Comparable&lt;String&gt;接口。如果换成我们自定义的Person类型试试：</span><br><span class="line">// sort</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Person[] ps = new Person[] &#123;</span><br><span class="line">            new Person(&quot;Bob&quot;, 61),</span><br><span class="line">            new Person(&quot;Alice&quot;, 88),</span><br><span class="line">            new Person(&quot;Lily&quot;, 75),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int score;</span><br><span class="line">    Person(String name, int score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.name + &quot;,&quot; + this.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">运行程序，我们会得到ClassCastException，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable&lt;T&gt;接口：</span><br><span class="line"></span><br><span class="line">// sort</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person[] ps = new Person[] &#123;</span><br><span class="line">            new Person(&quot;Bob&quot;, 61),</span><br><span class="line">            new Person(&quot;Alice&quot;, 88),</span><br><span class="line">            new Person(&quot;Lily&quot;, 75),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person implements Comparable&lt;Person&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int score;</span><br><span class="line">    Person(String name, int score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    public int compareTo(Person other) &#123;</span><br><span class="line">        return this.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.name + &quot;,&quot; + this.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行上述代码，可以正确实现按name进行排序。</span><br><span class="line"></span><br><span class="line">也可以修改比较逻辑，例如，按score从高到低排序。请自行修改测试。</span><br></pre></td></tr></table></figure>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用泛型时，把泛型参数&lt;T&gt;替换为需要的class类型，例如：ArrayList&lt;String&gt;，ArrayList&lt;Number&gt;等；</span><br><span class="line"></span><br><span class="line">可以省略编译器能自动推断出的类型，例如：List&lt;String&gt; list = new ArrayList&lt;&gt;();；</span><br><span class="line"></span><br><span class="line">不指定泛型参数类型时，编译器会给出警告，且只能将&lt;T&gt;视为Object类型；</span><br><span class="line"></span><br><span class="line">可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</span><br></pre></td></tr></table></figure>

<h3 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList&lt;T&gt;，我们很少需要编写泛型类。</span><br><span class="line"></span><br><span class="line">如果我们确实需要编写一个泛型类，那么，应该如何编写它？</span><br><span class="line"></span><br><span class="line">可以按照以下步骤来编写一个泛型类。</span><br><span class="line"></span><br><span class="line">首先，按照某种类型，例如：String，来编写类：</span><br><span class="line"></span><br><span class="line">public class Pair &#123;</span><br><span class="line">    private String first;</span><br><span class="line">    private String last;</span><br><span class="line">    public Pair(String first, String last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">然后，标记所有的特定类型，这里是String：</span><br><span class="line"></span><br><span class="line">public class Pair &#123;</span><br><span class="line">    private String first;</span><br><span class="line">    private String last;</span><br><span class="line">    public Pair(String first, String last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">最后，把特定类型String替换为T，并申明&lt;T&gt;：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">熟练后即可直接从T开始编写。</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">编写泛型类时，要特别注意，泛型类型&lt;T&gt;不能用于静态方法。例如：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123; ... &#125;</span><br><span class="line">    public T getLast() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // 对静态方法使用&lt;T&gt;:</span><br><span class="line">    public static Pair&lt;T&gt; create(T first, T last) &#123;</span><br><span class="line">        return new Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。</span><br><span class="line"></span><br><span class="line">有些同学在网上搜索发现，可以在static修饰符后面加一个&lt;T&gt;，编译就能通过：</span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123; ... &#125;</span><br><span class="line">    public T getLast() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // 可以编译通过:</span><br><span class="line">    public static &lt;T&gt; Pair&lt;T&gt; create(T first, T last) &#123;</span><br><span class="line">        return new Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">但实际上，这个&lt;T&gt;和Pair&lt;T&gt;类型的&lt;T&gt;已经没有任何关系了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，&lt;K&gt;：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123; ... &#125;</span><br><span class="line">    public T getLast() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    // 静态泛型方法应该使用其他类型区分:</span><br><span class="line">    public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) &#123;</span><br><span class="line">        return new Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</span><br></pre></td></tr></table></figure>

<h4 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T, K&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private K last;</span><br><span class="line">    public Pair(T first, K last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123; ... &#125;</span><br><span class="line">    public K getLast() &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用的时候，需要指出两种类型：</span><br><span class="line"></span><br><span class="line">Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(&quot;test&quot;, 123);</span><br><span class="line">Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写泛型时，需要定义泛型类型&lt;T&gt;；</span><br><span class="line"></span><br><span class="line">静态方法不能引用泛型类型&lt;T&gt;，必须定义其他类型（例如&lt;K&gt;）来实现静态泛型方法；</span><br><span class="line"></span><br><span class="line">泛型可以同时定义多种类型，例如Map&lt;K, V&gt;。</span><br></pre></td></tr></table></figure>

<h3 id="擦拭法cashifa"><a href="#擦拭法cashifa" class="headerlink" title="擦拭法cashifa"></a>擦拭法cashifa</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</span><br><span class="line">Java语言的泛型实现方式是擦拭法（Type Erasure）。</span><br><span class="line">所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</span><br><span class="line">例如，我们编写了一个泛型类Pair&lt;T&gt;，这是编译器看到的代码：</span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而虚拟机根本不知道泛型。这是虚拟机执行的代码：</span><br><span class="line">public class Pair &#123;</span><br><span class="line">    private Object first;</span><br><span class="line">    private Object last;</span><br><span class="line">    public Pair(Object first, Object last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">因此，Java使用擦拭法实现泛型，导致了：</span><br><span class="line"></span><br><span class="line">编译器把类型&lt;T&gt;视为Object；</span><br><span class="line">编译器根据&lt;T&gt;实现安全的强制转型。</span><br><span class="line">使用泛型的时候，我们编写的代码也是编译器看到的代码：</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br><span class="line">而虚拟机执行的代码并没有泛型：</span><br><span class="line"></span><br><span class="line">Pair p = new Pair(&quot;Hello&quot;, &quot;world&quot;);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure>

<h4 id="Java泛型的局限"><a href="#Java泛型的局限" class="headerlink" title="Java泛型的局限"></a>Java泛型的局限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</span><br><span class="line"></span><br><span class="line">了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局限一：&lt;T&gt;不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型：</span><br><span class="line"></span><br><span class="line">Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">局限二：无法取得带泛型的Class。观察以下代码：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    Pair&lt;String&gt; p1 = new Pair&lt;&gt;(&quot;Hello&quot;, &quot;world&quot;);</span><br><span class="line">    Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);</span><br><span class="line">    Class c1 = p1.getClass();</span><br><span class="line">    Class c2 = p2.getClass();</span><br><span class="line">    System.out.println(c1==c2); // true</span><br><span class="line">    System.out.println(c1==Pair.class); // true</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为T是Object，我们对Pair&lt;String&gt;和Pair&lt;Integer&gt;类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</span><br><span class="line"></span><br><span class="line">换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair&lt;Object&gt;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">局限三：无法判断带泛型的类型：</span><br><span class="line"></span><br><span class="line">Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</span><br><span class="line">// Compile error:</span><br><span class="line">if (p instanceof Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br><span class="line">原因和前面一样，并不存在Pair&lt;String&gt;.class，而是只有唯一的Pair.class。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">局限四：不能实例化T类型：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair() &#123;</span><br><span class="line">        // Compile error:</span><br><span class="line">        first = new T();</span><br><span class="line">        last = new T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述代码无法通过编译，因为构造方法的两行语句：</span><br><span class="line"></span><br><span class="line">first = new T();</span><br><span class="line">last = new T();</span><br><span class="line">擦拭后实际上变成了：</span><br><span class="line"></span><br><span class="line">first = new Object();</span><br><span class="line">last = new Object();</span><br><span class="line">这样一来，创建new Pair&lt;String&gt;()和创建new Pair&lt;Integer&gt;()就全部成了Object，显然编译器要阻止这种类型不对的代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class&lt;T&gt;。例如：</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; pair = new Pair&lt;&gt;(String.class);</span><br><span class="line">因为传入了Class&lt;String&gt;的实例，所以我们借助String.class就可以实例化String类型。</span><br></pre></td></tr></table></figure>

<h4 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有些时候，一个看似正确定义的方法会无法通过编译。例如：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    public boolean equals(T t) &#123;</span><br><span class="line">        return this == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这是因为，定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</span><br><span class="line"></span><br><span class="line">换个方法名，避开与Object.equals(Object)的冲突就可以成功编译：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    public boolean same(T t) &#123;</span><br><span class="line">        return this == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个类可以继承自一个泛型类。例如：父类的类型是Pair&lt;Integer&gt;，子类的类型是IntPair，可以这么继承：</span><br><span class="line"></span><br><span class="line">public class IntPair extends Pair&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可：</span><br><span class="line"></span><br><span class="line">IntPair ip = new IntPair(1, 2);</span><br><span class="line">前面讲了，我们无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;Integer&gt; p，无法从p中获取到Integer类型</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">前面讲了，我们无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;Integer&gt; p，无法从p中获取到Integer类型。</span><br><span class="line"></span><br><span class="line">但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。</span><br><span class="line"></span><br><span class="line">在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂：</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.ParameterizedType;</span><br><span class="line">import java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        if (t instanceof ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型</span><br><span class="line">            Type firstType = types[0]; // 取第一个泛型类型</span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); // Integer</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IntPair extends Pair&lt;Integer&gt; &#123;</span><br><span class="line">    public IntPair(Integer first, Integer last) &#123;</span><br><span class="line">        super(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为Java引入了泛型，所以，只用Class来标识类型已经不够了。实际上，Java的类型系统结构如下：</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/ttyong/hexoBlog/raw/master/%E6%9E%97%E5%AD%90%E9%9B%A8%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/202311222350427.png" alt="image-20231122235046393"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java的泛型是采用擦拭法实现的；</span><br><span class="line"></span><br><span class="line">擦拭法决定了泛型&lt;T&gt;：</span><br><span class="line"></span><br><span class="line">不能是基本类型，例如：int；</span><br><span class="line">不能获取带泛型类型的Class，例如：Pair&lt;String&gt;.class；</span><br><span class="line">不能判断带泛型类型的类型，例如：x instanceof Pair&lt;String&gt;；</span><br><span class="line">不能实例化T类型，例如：new T()。</span><br><span class="line">泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；</span><br><span class="line"></span><br><span class="line">子类可以获取父类的泛型类型&lt;T&gt;。</span><br></pre></td></tr></table></figure>

<h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我们前面已经讲到了泛型的继承关系：Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类。</span><br><span class="line"></span><br><span class="line">假设我们定义了Pair&lt;T&gt;：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T&gt; &#123; ... &#125;</span><br><span class="line">然后，我们又针对Pair&lt;Number&gt;类型写了一个静态方法，它接收的参数类型是Pair&lt;Number&gt;：</span><br><span class="line"></span><br><span class="line">public class PairHelper &#123;</span><br><span class="line">    static int add(Pair&lt;Number&gt; p) &#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        return first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述代码是可以正常编译的。使用的时候，我们传入：</span><br><span class="line"></span><br><span class="line">int sum = PairHelper.add(new Pair&lt;Number&gt;(1, 2));</span><br><span class="line">注意：传入的类型是Pair&lt;Number&gt;，实际参数类型是(Integer, Integer)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">既然实际参数是Integer类型，试试传入Pair&lt;Integer&gt;：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</span><br><span class="line">        int n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int add(Pair&lt;Number&gt; p) &#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        return first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">直接运行，会得到一个编译错误：</span><br><span class="line"></span><br><span class="line">incompatible types: Pair&lt;Integer&gt; cannot be converted to Pair&lt;Number&gt;</span><br><span class="line">原因很明显，因为Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类，因此，add(Pair&lt;Number&gt;)不接受参数类型Pair&lt;Integer&gt;。</span><br><span class="line"></span><br><span class="line">但是从add()方法的代码可知，传入Pair&lt;Integer&gt;是完全符合内部代码的类型规范，因为语句：</span><br><span class="line"></span><br><span class="line">Number first = p.getFirst();</span><br><span class="line">Number last = p.getLast();</span><br><span class="line">实际类型是Integer，引用类型是Number，没有问题。问题在于方法参数类型定死了只能传入Pair&lt;Number&gt;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">有没有办法使得方法参数接受Pair&lt;Integer&gt;？办法是有的，这就是使用Pair&lt;? extends Number&gt;使得方法接收所有泛型类型为Number或Number子类的Pair类型。我们把代码改写如下：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</span><br><span class="line">        int n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int add(Pair&lt;? extends Number&gt; p) &#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        return first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样一来，给方法传入Pair&lt;Integer&gt;类型时，它符合参数Pair&lt;? extends Number&gt;类型。这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。</span><br><span class="line"></span><br><span class="line">除了可以传入Pair&lt;Integer&gt;类型，我们还可以传入Pair&lt;Double&gt;类型，Pair&lt;BigDecimal&gt;类型等等，因为Double和BigDecimal都是Number的子类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果我们考察对Pair&lt;? extends Number&gt;类型调用getFirst()方法，实际的方法签名变成了：</span><br><span class="line"></span><br><span class="line">&lt;? extends Number&gt; getFirst();</span><br><span class="line">即返回值是Number或Number的子类，因此，可以安全赋值给Number类型的变量：</span><br><span class="line"></span><br><span class="line">Number x = p.getFirst();</span><br><span class="line">然后，我们不可预测实际类型就是Integer，例如，下面的代码是无法通过编译的：</span><br><span class="line"></span><br><span class="line">Integer x = p.getFirst();</span><br><span class="line">这是因为实际的返回类型可能是Integer，也可能是Double或者其他类型，编译器只能确定类型一定是Number的子类（包括Number类型本身），但具体类型无法确定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">我们再来考察一下Pair&lt;T&gt;的set方法：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</span><br><span class="line">        int n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int add(Pair&lt;? extends Number&gt; p) &#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        p.setFirst(new Integer(first.intValue() + 100));</span><br><span class="line">        p.setLast(new Integer(last.intValue() + 100));</span><br><span class="line">        return p.getFirst().intValue() + p.getFirst().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line"></span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFirst(T first) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLast(T last) &#123;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不出意外，我们会得到一个编译错误：</span><br><span class="line"></span><br><span class="line">incompatible types: Integer cannot be converted to CAP#1</span><br><span class="line">where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Number from capture of ? extends Number</span><br><span class="line">编译错误发生在p.setFirst()传入的参数是Integer类型。有些童鞋会问了，既然p的定义是Pair&lt;? extends Number&gt;，那么setFirst(? extends Number)为什么不能传入Integer？</span><br><span class="line"></span><br><span class="line">原因还在于擦拭法。如果我们传入的p是Pair&lt;Double&gt;，显然它满足参数定义Pair&lt;? extends Number&gt;，然而，Pair&lt;Double&gt;的setFirst()显然无法接受Integer类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这就是&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number的子类型给setFirst(? extends Number)。</span><br><span class="line"></span><br><span class="line">这里唯一的例外是可以给方法参数传入null：</span><br><span class="line"></span><br><span class="line">p.setFirst(null); // ok, 但是后面会抛出NullPointerException</span><br><span class="line">p.getFirst().intValue(); // NullPointerException</span><br></pre></td></tr></table></figure>

<h4 id="extends通配符的作用"><a href="#extends通配符的作用" class="headerlink" title="extends通配符的作用"></a>extends通配符的作用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">如果我们考察Java标准库的java.util.List&lt;T&gt;接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</span><br><span class="line"></span><br><span class="line">public interface List&lt;T&gt; &#123;</span><br><span class="line">    int size(); // 获取个数</span><br><span class="line">    T get(int index); // 根据索引获取指定元素</span><br><span class="line">    void add(T t); // 添加一个新元素</span><br><span class="line">    void remove(T t); // 删除一个已有元素</span><br><span class="line">&#125;</span><br><span class="line">现在，让我们定义一个方法来处理列表的每个元素：</span><br><span class="line"></span><br><span class="line">int sumOfList(List&lt;? extends Integer&gt; list) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">        Integer n = list.get(i);</span><br><span class="line">        sum = sum + n;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">为什么我们定义的方法参数类型是List&lt;? extends Integer&gt;而不是List&lt;Integer&gt;？从方法内部代码看，传入List&lt;? extends Integer&gt;或者List&lt;Integer&gt;是完全一样的，但是，注意到List&lt;? extends Integer&gt;的限制：</span><br><span class="line"></span><br><span class="line">允许调用get()方法获取Integer的引用；</span><br><span class="line">不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。</span><br><span class="line">因此，方法参数类型List&lt;? extends Integer&gt;表明了该方法内部只会读取List的元素，不会修改List的元素（因为无法调用add(? extends Integer)、remove(? extends Integer)这些方法。换句话说，这是一个对参数List&lt;? extends Integer&gt;进行只读的方法（恶意调用set(null)除外）。</span><br></pre></td></tr></table></figure>

<h4 id="使用extends限定T类型"><a href="#使用extends限定T类型" class="headerlink" title="使用extends限定T类型"></a>使用extends限定T类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在定义泛型类型Pair&lt;T&gt;的时候，也可以使用extends通配符来限定T的类型：</span><br><span class="line"></span><br><span class="line">public class Pair&lt;T extends Number&gt; &#123; ... &#125;</span><br><span class="line">现在，我们只能定义：</span><br><span class="line"></span><br><span class="line">Pair&lt;Number&gt; p1 = null;</span><br><span class="line">Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(1, 2);</span><br><span class="line">Pair&lt;Double&gt; p3 = null;</span><br><span class="line">因为Number、Integer和Double都符合&lt;T extends Number&gt;。</span><br><span class="line"></span><br><span class="line">非Number类型将无法通过编译：</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p1 = null; // compile error!</span><br><span class="line">Pair&lt;Object&gt; p2 = null; // compile error!</span><br><span class="line">因为String、Object都不符合&lt;T extends Number&gt;，因为它们不是Number类型或Number的子类。</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用类似&lt;? extends Number&gt;通配符作为方法参数时表示：</span><br><span class="line"></span><br><span class="line">方法内部可以调用获取Number引用的方法，例如：Number n = obj.getFirst();；</span><br><span class="line"></span><br><span class="line">方法内部无法调用传入Number引用的方法（null除外），例如：obj.setFirst(Number n);。</span><br><span class="line"></span><br><span class="line">即一句话总结：使用extends通配符表示可以读，不能写。</span><br><span class="line"></span><br><span class="line">使用类似&lt;T extends Number&gt;定义泛型类时表示：</span><br><span class="line"></span><br><span class="line">泛型类型限定为Number以及Number的子类。</span><br></pre></td></tr></table></figure>

<h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们前面已经讲到了泛型的继承关系：Pair&lt;Integer&gt;不是Pair&lt;Number&gt;的子类。</span><br><span class="line"></span><br><span class="line">考察下面的set方法：</span><br><span class="line"></span><br><span class="line">void set(Pair&lt;Integer&gt; p, Integer first, Integer last) &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br><span class="line">传入Pair&lt;Integer&gt;是允许的，但是传入Pair&lt;Number&gt;是不允许的。</span><br><span class="line"></span><br><span class="line">和extends通配符相反，这次，我们希望接受Pair&lt;Integer&gt;类型，以及Pair&lt;Number&gt;、Pair&lt;Object&gt;，因为Number和Object是Integer的父类，setFirst(Number)和setFirst(Object)实际上允许接受Integer类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们使用super通配符来改写这个方法：</span><br><span class="line"></span><br><span class="line">void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last) &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br><span class="line">注意到Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">下面的代码可以被正常编译：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Pair&lt;Number&gt; p1 = new Pair&lt;&gt;(12.3, 4.56);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);</span><br><span class="line">        setSame(p1, 100);</span><br><span class="line">        setSame(p2, 200);</span><br><span class="line">        System.out.println(p1.getFirst() + &quot;, &quot; + p1.getLast());</span><br><span class="line">        System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void setSame(Pair&lt;? super Integer&gt; p, Integer n) &#123;</span><br><span class="line">        p.setFirst(n);</span><br><span class="line">        p.setLast(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line"></span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFirst(T first) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLast(T last) &#123;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">考察Pair&lt;? super Integer&gt;的setFirst()方法，它的方法签名实际上是：</span><br><span class="line"></span><br><span class="line">void setFirst(? super Integer);</span><br><span class="line">因此，可以安全地传入Integer类型。</span><br><span class="line"></span><br><span class="line">再考察Pair&lt;? super Integer&gt;的getFirst()方法，它的方法签名实际上是：</span><br><span class="line"></span><br><span class="line">? super Integer getFirst();</span><br><span class="line">这里注意到我们无法使用Integer类型来接收getFirst()的返回值，即下面的语句将无法通过编译：</span><br><span class="line"></span><br><span class="line">Integer x = p.getFirst();</span><br><span class="line">因为如果传入的实际类型是Pair&lt;Number&gt;，编译器无法将Number类型转型为Integer。</span><br><span class="line"></span><br><span class="line">注意：虽然Number是一个抽象类，我们无法直接实例化它。但是，即便Number不是抽象类，这里仍然无法通过编译。此外，传入Pair&lt;Object&gt;类型时，编译器也无法将Object类型转型为Integer。</span><br><span class="line"></span><br><span class="line">唯一可以接收getFirst()方法返回值的是Object类型：</span><br><span class="line"></span><br><span class="line">Object obj = p.getFirst();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因此，使用&lt;? super Integer&gt;通配符表示：</span><br><span class="line"></span><br><span class="line">允许调用set(? super Integer)方法传入Integer的引用；</span><br><span class="line"></span><br><span class="line">不允许调用get()方法获得Integer的引用。</span><br><span class="line"></span><br><span class="line">唯一例外是可以获取Object的引用：Object o = p.getFirst()。</span><br><span class="line"></span><br><span class="line">换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</span><br></pre></td></tr></table></figure>

<h4 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们再回顾一下extends通配符。作为方法参数，&lt;? extends T&gt;类型和&lt;? super T&gt;类型的区别在于：</span><br><span class="line"></span><br><span class="line">&lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）；</span><br><span class="line"></span><br><span class="line">&lt;? super T&gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。</span><br><span class="line"></span><br><span class="line">一个是允许读不允许写，另一个是允许写不允许读。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">先记住上面的结论，我们来看Java标准库的Collections类定义的copy()方法：</span><br><span class="line"></span><br><span class="line">public class Collections &#123;</span><br><span class="line">    // 把src的每个元素复制到dest中:</span><br><span class="line">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class="line">        for (int i=0; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">它的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是List&lt;? super T&gt;，表示目标List，第二个参数List&lt;? extends T&gt;，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型&lt;? extends T&gt;的变量src，我们可以安全地获取类型T的引用，而对于类型&lt;? super T&gt;的变量dest，我们可以安全地传入T的引用。</span><br><span class="line"></span><br><span class="line">这个copy()方法的定义就完美地展示了extends和super的意图：</span><br><span class="line"></span><br><span class="line">copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用；</span><br><span class="line"></span><br><span class="line">copy()方法内部也不会修改src，因为不能调用src.add(T)。</span><br><span class="line"></span><br><span class="line">这是由编译器检查来实现的。如果在方法代码中意外修改了src，或者意外读取了dest，就会导致一个编译错误：</span><br><span class="line"></span><br><span class="line">public class Collections &#123;</span><br><span class="line">    // 把src的每个元素复制到dest中:</span><br><span class="line">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class="line">        ...</span><br><span class="line">        T t = dest.get(0); // compile error!</span><br><span class="line">        src.add(t); // compile error!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个copy()方法的另一个好处是可以安全地把一个List&lt;Integer&gt;添加到List&lt;Number&gt;，但是无法反过来添加：</span><br><span class="line"></span><br><span class="line">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span><br><span class="line">List&lt;Number&gt; numList = ...;</span><br><span class="line">List&lt;Integer&gt; intList = ...;</span><br><span class="line">Collections.copy(numList, intList);</span><br><span class="line"></span><br><span class="line">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span><br><span class="line">Collections.copy(intList, numList);</span><br><span class="line">而这些都是通过super和extends通配符，并由编译器强制检查来实现的。</span><br></pre></td></tr></table></figure>

<h4 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">何时使用extends，何时使用super？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</span><br><span class="line"></span><br><span class="line">即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。</span><br><span class="line"></span><br><span class="line">还是以Collections的copy()方法为例：</span><br><span class="line"></span><br><span class="line">public class Collections &#123;</span><br><span class="line">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class="line">        for (int i=0; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i); // src是producer</span><br><span class="line">            dest.add(t); // dest是consumer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">需要返回T的src是生产者，因此声明为List&lt;? extends T&gt;，需要写入T的dest是消费者，因此声明为List&lt;? super T&gt;。</span><br></pre></td></tr></table></figure>

<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我们已经讨论了&lt;? extends T&gt;和&lt;? super T&gt;作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个?：</span><br><span class="line"></span><br><span class="line">void sample(Pair&lt;?&gt; p) &#123;</span><br><span class="line">&#125;</span><br><span class="line">因为&lt;?&gt;通配符既没有extends，也没有super，因此：</span><br><span class="line"></span><br><span class="line">不允许调用set(T)方法并传入引用（null除外）；</span><br><span class="line">不允许调用T get()方法并获取T引用（只能获取Object引用）。</span><br><span class="line">换句话说，既不能读，也不能写，那只能做一些null判断：</span><br><span class="line"></span><br><span class="line">static boolean isNull(Pair&lt;?&gt; p) &#123;</span><br><span class="line">    return p.getFirst() == null || p.getLast() == null;</span><br><span class="line">&#125;</span><br><span class="line">大多数情况下，可以引入泛型参数&lt;T&gt;消除&lt;?&gt;通配符：</span><br><span class="line"></span><br><span class="line">static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) &#123;</span><br><span class="line">    return p.getFirst() == null || p.getLast() == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</span><br><span class="line">        Pair&lt;?&gt; p2 = p; // 安全地向上转型</span><br><span class="line">        System.out.println(p2.getFirst() + &quot;, &quot; + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">    private T first;</span><br><span class="line">    private T last;</span><br><span class="line"></span><br><span class="line">    public Pair(T first, T last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getLast() &#123;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFirst(T first) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLast(T last) &#123;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上述代码是可以正常编译运行的，因为Pair&lt;Integer&gt;是Pair&lt;?&gt;的子类，可以安全地向上转型。</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用类似&lt;? super Integer&gt;通配符作为方法参数时表示：</span><br><span class="line"></span><br><span class="line">方法内部可以调用传入Integer引用的方法，例如：obj.setFirst(Integer n);；</span><br><span class="line"></span><br><span class="line">方法内部无法调用获取Integer引用的方法（Object除外），例如：Integer n = obj.getFirst();。</span><br><span class="line"></span><br><span class="line">即使用super通配符表示只能写不能读。</span><br><span class="line"></span><br><span class="line">使用extends和super通配符要遵循PECS原则。</span><br><span class="line"></span><br><span class="line">无限定通配符&lt;?&gt;很少使用，可以用&lt;T&gt;替换，同时它是所有&lt;T&gt;类型的超类。</span><br></pre></td></tr></table></figure>

<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Java的部分反射API也是泛型。例如：Class&lt;T&gt;就是泛型：</span><br><span class="line"></span><br><span class="line">// compile warning:</span><br><span class="line">Class clazz = String.class;</span><br><span class="line">String str = (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">// no warning:</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line">String str = clazz.newInstance();</span><br><span class="line">调用Class的getSuperclass()方法返回的Class类型是Class&lt;? super T&gt;：</span><br><span class="line"></span><br><span class="line">Class&lt;? super String&gt; sup = String.class.getSuperclass();</span><br><span class="line">构造方法Constructor&lt;T&gt;也是泛型：</span><br><span class="line"></span><br><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class);</span><br><span class="line">Integer i = cons.newInstance(123);</span><br><span class="line">我们可以声明带泛型的数组，但不能用new操作符创建带泛型的数组：</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt;[] ps = null; // ok</span><br><span class="line">Pair&lt;String&gt;[] ps = new Pair&lt;String&gt;[2]; // compile error!</span><br><span class="line">必须通过强制转型实现带泛型的数组：</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2];</span><br><span class="line">使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量ps，因为它的类型是泛型数组。但是，编译器不会检查变量arr，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作arr可能导致从ps获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</span><br><span class="line"></span><br><span class="line">Pair[] arr = new Pair[2];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">ps[0] = new Pair&lt;String&gt;(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">arr[1] = new Pair&lt;Integer&gt;(1, 2);</span><br><span class="line"></span><br><span class="line">// ClassCastException:</span><br><span class="line">Pair&lt;String&gt; p = ps[1];</span><br><span class="line">String s = p.getFirst();</span><br><span class="line">要安全地使用泛型数组，必须扔掉arr的引用：</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2];</span><br><span class="line">上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组ps进行操作，这种操作就是安全的。</span><br><span class="line"></span><br><span class="line">带泛型的数组实际上是编译器的类型擦除：</span><br><span class="line"></span><br><span class="line">Pair[] arr = new Pair[2];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">System.out.println(ps.getClass() == Pair[].class); // true</span><br><span class="line"></span><br><span class="line">String s1 = (String) arr[0].getFirst();</span><br><span class="line">String s2 = ps[0].getFirst();</span><br><span class="line">所以我们不能直接创建泛型数组T[]，因为擦拭后代码变为Object[]：</span><br><span class="line"></span><br><span class="line">// compile error:</span><br><span class="line">public class Abc&lt;T&gt; &#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        return new T[5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">必须借助Class&lt;T&gt;来创建泛型数组：</span><br><span class="line"></span><br><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    return (T[]) Array.newInstance(cls, 5);</span><br><span class="line">&#125;</span><br><span class="line">我们还可以利用可变参数创建泛型数组T[]：</span><br><span class="line"></span><br><span class="line">public class ArrayHelper &#123;</span><br><span class="line">    @SafeVarargs</span><br><span class="line">    static &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        return objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ss = ArrayHelper.asArray(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(1, 2, 3);</span><br><span class="line">谨慎使用泛型可变参数</span><br><span class="line">在上面的例子中，我们看到，通过：</span><br><span class="line"></span><br><span class="line">static &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    return objs;</span><br><span class="line">&#125;</span><br><span class="line">似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] arr = asArray(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        // ClassCastException:</span><br><span class="line">        String[] firstTwo = pickTwo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(firstTwo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;</span><br><span class="line">        return asArray(k1, k2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        return objs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">直接调用asArray(T...)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。</span><br><span class="line"></span><br><span class="line">如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。</span><br><span class="line"></span><br><span class="line"> 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</span><br><span class="line">更详细的解释请参考《Effective Java》“Item 32: Combine generics and varargs judiciously”。</span><br></pre></td></tr></table></figure>

<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">部分反射API是泛型，例如：Class&lt;T&gt;，Constructor&lt;T&gt;；</span><br><span class="line"></span><br><span class="line">可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；</span><br><span class="line"></span><br><span class="line">可以通过Array.newInstance(Class&lt;T&gt;, int)创建T[]数组，需要强制转型；</span><br><span class="line"></span><br><span class="line">同时使用泛型和可变参数时需要特别小心。</span><br></pre></td></tr></table></figure>

<h2 id="集合-廖雪峰"><a href="#集合-廖雪峰" class="headerlink" title="集合(廖雪峰)"></a>集合(廖雪峰)</h2><h3 id="java集合简介"><a href="#java集合简介" class="headerlink" title="java集合简介"></a>java集合简介</h3><h3 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h3><h3 id="编写equals方法"><a href="#编写equals方法" class="headerlink" title="编写equals方法"></a>编写equals方法</h3><h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><h3 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h3><h3 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h3><h3 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h3><h3 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h3><h3 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h3><h3 id="使用Queue"><a href="#使用Queue" class="headerlink" title="使用Queue"></a>使用Queue</h3><h3 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h3><h3 id="使用Deque"><a href="#使用Deque" class="headerlink" title="使用Deque"></a>使用Deque</h3><h3 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h3><h3 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h3><h3 id="使用Collections"><a href="#使用Collections" class="headerlink" title="使用Collections"></a>使用Collections</h3><h2 id="多线程-廖雪峰"><a href="#多线程-廖雪峰" class="headerlink" title="多线程(廖雪峰)"></a>多线程(廖雪峰)</h2><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程线程关系</span><br><span class="line">进程线程优缺点</span><br><span class="line">多任务实现方式</span><br></pre></td></tr></table></figure>

<h3 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两种创建方法，第二种有便捷方式</span><br><span class="line">sleep()</span><br><span class="line">不能直接run，要用start()</span><br><span class="line">优先级</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join()</span><br><span class="line">join(20)</span><br></pre></td></tr></table></figure>

<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interrupt</span><br><span class="line">当目标线程调用join()后，调用方interrupt，会捕获到异常</span><br><span class="line">标志位中断方法 </span><br><span class="line">volatile</span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setDaemon(true)</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原子操作</span><br><span class="line"></span><br><span class="line">synchronized(lock) &#123;</span><br><span class="line">    n = n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不需要synchronized的操作</span><br><span class="line"></span><br><span class="line">有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作</span><br><span class="line"></span><br><span class="line">不可变对象无需同步</span><br></pre></td></tr></table></figure>

<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全</span><br><span class="line"></span><br><span class="line">对于static方法，是没有this实例的，因为static方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的Class实例，因此，对static方法添加synchronized，锁住的是该类的Class实例。</span><br></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">死锁</span><br><span class="line">可重入锁 synchronized</span><br></pre></td></tr></table></figure>

<h3 id="使用wait和notify"><a href="#使用wait和notify" class="headerlink" title="使用wait和notify"></a>使用wait和notify</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.wait(); 释放当前锁 while中使用</span><br><span class="line">this.notify(); 让释放锁的线程从wait处获得锁 只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）</span><br><span class="line">notifyAll() 将唤醒所有当前正在this锁等待的线程 但只能有一个能获得锁</span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized String getTask() &#123;</span><br><span class="line">    while (queue.isEmpty()) &#123;</span><br><span class="line">        // 释放this锁:</span><br><span class="line">        this.wait();</span><br><span class="line">        // 重新获取this锁</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void addTask(String s) &#123;</span><br><span class="line">    this.queue.add(s);</span><br><span class="line">    this.notify(); // 唤醒在this锁等待的线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        var q = new TaskQueue();</span><br><span class="line">        var ts = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        for (int i=0; i&lt;5; i++) &#123;</span><br><span class="line">            var t = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    // 执行task:</span><br><span class="line">                    while (true) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(&quot;execute task: &quot; + s);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        var add = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">                // 放入task:</span><br><span class="line">                String s = &quot;t-&quot; + Math.random();</span><br><span class="line">                System.out.println(&quot;add task: &quot; + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                try &#123; Thread.sleep(100); &#125; catch(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        for (var t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TaskQueue &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public synchronized void addTask(String s) &#123;</span><br><span class="line">        this.queue.add(s);</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized String getTask() throws InterruptedException &#123;</span><br><span class="line">        while (queue.isEmpty()) &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用ReentrantLock"><a href="#使用ReentrantLock" class="headerlink" title="使用ReentrantLock"></a>使用ReentrantLock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock可以替代synchronized进行同步</span><br><span class="line">也是可重入锁</span><br><span class="line">和synchronized不同的是，ReentrantLock可以尝试获取锁</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public void add(int n) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</span><br></pre></td></tr></table></figure>

<h4 id="使用Condition"><a href="#使用Condition" class="headerlink" title="使用Condition"></a>使用Condition</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以实现synchronized的wait notify notifyall</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await signal() signalall() </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</span><br><span class="line"></span><br><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class TaskQueue &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private final Condition condition = lock.newCondition();</span><br><span class="line">    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addTask(String s) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTask() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            return queue.remove();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以实现多个线程同时读，不允许同时写</span><br><span class="line">只允许一个线程写，不允许读</span><br><span class="line"></span><br><span class="line">允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待</span><br></pre></td></tr></table></figure>

<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">    // 注意: 一对读锁和写锁必须从同一个rwlock获取:</span><br><span class="line">    private final Lock rlock = rwlock.readLock();</span><br><span class="line">    private final Lock wlock = rwlock.writeLock();</span><br><span class="line">    private int[] counts = new int[10];</span><br><span class="line"></span><br><span class="line">    public void inc(int index) &#123;</span><br><span class="line">        wlock.lock(); // 加写锁</span><br><span class="line">        try &#123;</span><br><span class="line">            counts[index] += 1;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            wlock.unlock(); // 释放写锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] get() &#123;</span><br><span class="line">        rlock.lock(); // 加读锁</span><br><span class="line">        try &#123;</span><br><span class="line">            return Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rlock.unlock(); // 释放读锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读的过程也可以写</span><br><span class="line">适合读的过程小概率发生写</span><br><span class="line"></span><br><span class="line">StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率</span><br><span class="line"></span><br><span class="line">显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</span><br><span class="line"></span><br><span class="line">不是可重入锁</span><br></pre></td></tr></table></figure>

<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final StampedLock stampedLock = new StampedLock();</span><br><span class="line"></span><br><span class="line">    private double x;</span><br><span class="line">    private double y;</span><br><span class="line"></span><br><span class="line">    public void move(double deltaX, double deltaY) &#123;</span><br><span class="line">        long stamp = stampedLock.writeLock(); // 获取写锁</span><br><span class="line">        try &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); // 释放写锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double distanceFromOrigin() &#123;</span><br><span class="line">        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁</span><br><span class="line">        // 注意下面两行代码不是原子操作</span><br><span class="line">        // 假设x,y = (100,200)</span><br><span class="line">        double currentX = x;</span><br><span class="line">        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span><br><span class="line">        double currentY = y;</span><br><span class="line">        // 此处已读取到y，如果没有写入，读取是正确的(100,200)</span><br><span class="line">        // 如果有写入，读取是错误的(100,400)</span><br><span class="line">        if (!stampedLock.validate(stamp)) &#123; // 检查乐观读锁后是否有其他写锁发生</span><br><span class="line">            stamp = stampedLock.readLock(); // 获取一个悲观读锁</span><br><span class="line">            try &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); // 释放悲观读锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种限制数量的锁</span><br><span class="line"></span><br><span class="line">Semaphore本质上就是一个信号计数器，用于限制同一时间的最大访问数量</span><br></pre></td></tr></table></figure>

<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AccessLimitControl &#123;</span><br><span class="line">    // 任意时刻仅允许最多3个线程获取许可:</span><br><span class="line">    final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">    public String access() throws Exception &#123;</span><br><span class="line">        // 如果超过了许可数量,其他线程将在此等待:</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        try &#123;</span><br><span class="line">            // TODO:</span><br><span class="line">            return UUID.randomUUID().toString();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 指定等待时间3秒内获取到许可:</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent</span><br><span class="line">这个库提供了一些线程安全的集合</span><br><span class="line"></span><br><span class="line">尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</span><br></pre></td></tr></table></figure>

<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><table>
<thead>
<tr>
<th>interface</th>
<th>non-thread-safe</th>
<th>thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>ArrayList</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td>ConcurrentHashMap</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet &#x2F; TreeSet</td>
<td>CopyOnWriteArraySet</td>
</tr>
<tr>
<td>Queue</td>
<td>ArrayDeque &#x2F; LinkedList</td>
<td>ArrayBlockingQueue &#x2F; LinkedBlockingQueue</td>
</tr>
<tr>
<td>Deque</td>
<td>ArrayDeque &#x2F; LinkedList</td>
<td>LinkedBlockingDeque</td>
</tr>
</tbody></table>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.atomic这个类封装了一些原子操作的类</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/haofeiyu/6356301">参考</a></p>
<h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int incrementAndGet(AtomicInteger var) &#123;</span><br><span class="line">    int prev, next;</span><br><span class="line">    do &#123;</span><br><span class="line">        prev = var.get();</span><br><span class="line">        next = prev + 1;</span><br><span class="line">    &#125; while ( ! var.compareAndSet(prev, next));</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：</span><br><span class="line"></span><br><span class="line">class IdGenerator &#123;</span><br><span class="line">    AtomicLong var = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public long getNextId() &#123;</span><br><span class="line">        return var.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">固定大小</span><br><span class="line">动态调整</span><br><span class="line">固定区间范围</span><br><span class="line">计划线程池</span><br></pre></td></tr></table></figure>



<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h3><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h3><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><h3 id="发送Email"><a href="#发送Email" class="headerlink" title="发送Email"></a>发送Email</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MUA</span><br><span class="line">MTA</span><br><span class="line">MDA</span><br><span class="line">SMTP 25 xx xx</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="接收Email"><a href="#接收Email" class="headerlink" title="接收Email"></a>接收Email</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP3 110 xxx</span><br><span class="line">IMAP 143 xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIME</span><br></pre></td></tr></table></figure>



<h3 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h3><h3 id="RMI远程调用"><a href="#RMI远程调用" class="headerlink" title="RMI远程调用"></a>RMI远程调用</h3></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">智汇君</div><div class="post-copyright__author_desc">路漫漫其修远兮，吾将上下而求索！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80%202/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/01/17/博学谷-零基础大数据在线就业班-第一阶段 java基础 2/')">博学谷-零基础大数据在线就业班-第一阶段 java基础2</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80%202/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tech智汇站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>大数据<span class="tagsPageCount">26</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">博学谷-零基础大数据在线就业班-第一阶段 java基础</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/17/web%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">web开发版本问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20spark%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 1</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%85%2017/" title="oracle数据库开发与应用 存储过程、函数和包 17"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 存储过程、函数和包 17</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%2016/" title="oracle数据库开发与应用 数据库编程 16"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 数据库编程 16</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%B8%B8%E6%A0%87%E5%92%8C%E5%BC%82%E5%B8%B8%2019/" title="oracle数据库开发与应用 游标和异常 19"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 游标和异常 19</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">智汇君</h1><div class="author-info__desc">路漫漫其修远兮，吾将上下而求索！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/contact/" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(/img/博客微信公众号图片.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-java%E5%9F%BA%E7%A1%80-2"><span class="toc-number">1.</span> <span class="toc-text">博学谷-零基础大数据在线就业班-第一阶段 java基础 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.1.</span> <span class="toc-text">泛型(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%81%E7%95%A5T"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">省略T</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">泛型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">编写泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">多个泛型类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%A6%E6%8B%AD%E6%B3%95cashifa"><span class="toc-number">1.1.4.</span> <span class="toc-text">擦拭法cashifa</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">Java泛型的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%81%B0%E5%BD%93%E7%9A%84%E8%A6%86%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">不恰当的覆写方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">泛型继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.5.</span> <span class="toc-text">extends通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extends%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">extends通配符的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8extends%E9%99%90%E5%AE%9AT%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">使用extends限定T类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.6.</span> <span class="toc-text">super通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94extends%E5%92%8Csuper%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">对比extends和super通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PECS%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">PECS原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">无限定通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">1.1.7.</span> <span class="toc-text">泛型和反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.2.</span> <span class="toc-text">集合(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%9B%86%E5%90%88%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">java集合简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99equals%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">编写equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Map"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99equals%E5%92%8ChashCode"><span class="toc-number">1.2.5.</span> <span class="toc-text">编写equals和hashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-number">1.2.6.</span> <span class="toc-text">使用EnumMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TreeMap"><span class="toc-number">1.2.7.</span> <span class="toc-text">使用TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Properties"><span class="toc-number">1.2.8.</span> <span class="toc-text">使用Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Set"><span class="toc-number">1.2.9.</span> <span class="toc-text">使用Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Queue"><span class="toc-number">1.2.10.</span> <span class="toc-text">使用Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PriorityQueue"><span class="toc-number">1.2.11.</span> <span class="toc-text">使用PriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Deque"><span class="toc-number">1.2.12.</span> <span class="toc-text">使用Deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Stack"><span class="toc-number">1.2.13.</span> <span class="toc-text">使用Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Iterator"><span class="toc-number">1.2.14.</span> <span class="toc-text">使用Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Collections"><span class="toc-number">1.2.15.</span> <span class="toc-text">使用Collections</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.</span> <span class="toc-text">多线程(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">多线程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">创建新线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.3.6.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.8.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify"><span class="toc-number">1.3.9.</span> <span class="toc-text">使用wait和notify</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ReentrantLock"><span class="toc-number">1.3.10.</span> <span class="toc-text">使用ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Condition"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">使用Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.3.10.1.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">1.3.11.</span> <span class="toc-text">ReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StampedLock"><span class="toc-number">1.3.12.</span> <span class="toc-text">StampedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">1.3.12.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.3.13.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">1.3.13.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrent"><span class="toc-number">1.3.14.</span> <span class="toc-text">Concurrent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">1.3.14.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic"><span class="toc-number">1.3.15.</span> <span class="toc-text">Atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-6"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.16.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">1.3.17.</span> <span class="toc-text">Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">1.3.18.</span> <span class="toc-text">CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoin"><span class="toc-number">1.3.19.</span> <span class="toc-text">ForkJoin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.3.20.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.21.</span> <span class="toc-text">虚拟线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">网络编程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">TCP编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">UDP编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81Email"><span class="toc-number">1.4.4.</span> <span class="toc-text">发送Email</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6Email"><span class="toc-number">1.4.5.</span> <span class="toc-text">接收Email</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.6.</span> <span class="toc-text">HTTP编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">RMI远程调用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题">无题</a><time datetime="2025-07-02T10:28:32.791Z" title="发表于 2025-07-02 18:28:32">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/" title="无题">无题</a><time datetime="2025-07-02T03:31:20.020Z" title="发表于 2025-07-02 11:31:20">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0PythonJava%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0PythonJava%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/" title="无题">无题</a><time datetime="2025-05-14T04:06:50.987Z" title="发表于 2025-05-14 12:06:50">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0Python/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0Python/" title="无题">无题</a><time datetime="2025-05-14T04:02:32.996Z" title="发表于 2025-05-14 12:02:32">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2025-04-16T02:11:28.562Z" title="发表于 2025-04-16 10:11:28">2025-04-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="智汇君" target="_blank">智汇君</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 0.88rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 0.88rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 0.88rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>26</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 0.88rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 0.88rem;">廖雪峰<sup>9</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>12</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("24/12/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 智汇君 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("24/12/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4792307_02gxbpyxcpwp.js?spm=a313x.manage_type_myprojects.i1.10.56323a81KZGFDE&amp;file=font_4792307_02gxbpyxcpwp.js# 阿里图标symbol 引用链接，主题会进行加载 symbol 引用"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>