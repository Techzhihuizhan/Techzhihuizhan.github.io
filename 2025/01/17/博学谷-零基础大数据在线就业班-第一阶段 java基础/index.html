<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>博学谷-零基础大数据在线就业班-第一阶段 java基础 | Tech智汇站</title><meta name="keywords" content="大数据"><meta name="author" content="智汇君"><meta name="copyright" content="智汇君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="博学谷-零基础大数据在线就业班-第一阶段 java基础"><meta name="application-name" content="博学谷-零基础大数据在线就业班-第一阶段 java基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="博学谷-零基础大数据在线就业班-第一阶段 java基础"><meta property="og:url" content="http://example.com/2025/01/17/博学谷-零基础大数据在线就业班-第一阶段 java基础/index.html"><meta property="og:site_name" content="Tech智汇站"><meta property="og:description" content="博学谷-零基础大数据在线就业班-第一阶段 java基础第一章 java基础语法环境搭建+入门java语言背景介绍java语言跨平台原理JRE和JDK JDK的下载和安装常用DOS命令PATH环境变量的配置HelloWorld案例12编译 javac xxx.java运行 java xxx  &amp;#x2F;&amp;#x2F; 不"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta property="article:author" content="智汇君"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta name="description" content="博学谷-零基础大数据在线就业班-第一阶段 java基础第一章 java基础语法环境搭建+入门java语言背景介绍java语言跨平台原理JRE和JDK JDK的下载和安装常用DOS命令PATH环境变量的配置HelloWorld案例12编译 javac xxx.java运行 java xxx  &amp;#x2F;&amp;#x2F; 不"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 智汇君","link":"链接: ","source":"来源: Tech智汇站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Tech智汇站',
  title: '博学谷-零基础大数据在线就业班-第一阶段 java基础',
  postAI: '',
  pageFillDescription: '博学谷-零基础大数据在线就业班-第一阶段 java基础, 第一章 java基础语法, 环境搭建+入门, java语言背景介绍, java语言跨平台原理, JRE和JDK, JDK的下载和安装, 常用DOS命令, PATH环境变量的配置, HelloWorld案例, Notepad软件的安装和使用, 注释, 关键字, 数据类型及转换, 常量, 变量介绍, 数据类型, 变量的定义和使用, 变量的注意事项, 运算符, 条件控制语句, 循环, 随机数+开发工具, 数组, 方法与debug, 进制, 二维数组, 第二章 面向对象基础, 第三章 API基础, StringBuilder, 常用构造方法, public StringBuilder(), public StringBuilder(String str), 常用成员方法, append, reverse, length, toString, StringBuilder如何提高的效率, 案例, StringBuffer(廖雪峰), StringJoiner(廖雪峰), 包装类型(廖雪峰), 进制转换, 处理无符号整型, Auto Boxing, 不变类, JavaBean(廖雪峰), JavaBean的作用, 枚举JavaBean属性, 枚举类(廖雪峰), enum, enum的比较, enum类型, name(), ordinal(), toString(), switch, 小结, 记录类(廖雪峰), record, 构造方法, 小结, 常用工具类(廖雪峰), Math, 绝对值, 最大或最小值, xy次方, √x, ex次方, e为底的对数, 以10为底的对数, 三角函数, 数学常量, 随机数, StrictMath, Random, SecureRandom, 异常处理(廖雪峰), java的异常, 捕获异常, 抛出异常, 自定义异常, NullPointerException, 使用断言, 使用JDK Logging, 使用Commons Logging, 使用Log4j, SLF4J和Logback, 反射(廖雪峰), Class类, 获取Class实例, 与instanceof比较, Class实例来创建对应类型的实例, 动态加载, 访问字段, 获取字段值, 设置字段值, 调用方法, 调用方法, 调用静态方法, 调用非public方法, 多态, 调用构造方法, 获取继承关系, 获取父类的Class, 获取interface, 继承关系, 动态代理, 注解(廖雪峰), 使用注解, 注解的作用, 注解的参数, 定义注解, 元注解, @Target, @Retention, @Repeatable, @Inherited, 如何定义Annotation, 处理注解, 使用注解博学谷零基础大数据在线就业班第一阶段基础第一章基础语法环境搭建入门语言背景介绍语言跨平台原理和的下载和安装常用命令环境变量的配置案例编译运行不需要后缀类名前有时类名必须与文件名一致一个程序必须有入口方法软件的安装和使用高级的记事本方便代码编写有行号配置默认代码语言和编码注释单行多行文档注释关键字关键字全小写常用代码编辑器里关键字有特殊颜色不是关键字数据类型及转换常量字符串常量整数常量小数常量字符常量布尔常量空常量变量介绍数据类型整数字节范围默认建议浮点数字节范围默认建议字符字节范围布尔字节范围变量的定义和使用变量的注意事项同名变量不可以重复定义一条语句可以定义多个变量用逗号隔开变量在使用之前一定要赋值定义变量类型时需要在数值后面加入或定义变量类型时需要在数值后面加入或定义的变量只在所在的大括号内有效当这个大括号执行完毕后内存中这个变量会消失运算符条件控制语句循环随机数开发工具数组方法与进制二维数组第二章面向对象基础第三章基础字符串串接在次数多的情况下如循环会很占内存生成临时对象可以解决不会生成临时对象它的方法可以实现链式操作核心就是方法执行完返回所以自己也可以实现类似的类提高字符串操作效率次字符串拼接用了用了可变字符串类可以视为一个容器来自于不需要手动导入直接打印的结果是容器里的内容不是地址常用构造方法默认创建一个空字符对象默认创建一个以传入字符串为基础的对象常用成员方法接受任意数据类型返回对象本身可以链式调用元素内容反转返回对象本身如何提高的效率案例字符串反转打印数组的样子廖雪峰这是早期的一个的线程安全版本它通过同步来保证多个线程操作也是安全的但是同步会带来执行速度的下降和接口完全相同现在完全没有必要使用廖雪峰类似用分隔符拼接数组的需求在不需要指定开头和结尾的时候用更方便包装类型廖雪峰引用类型可以赋值为表示空但基本类型不能赋值为那么如何把一个基本类型视为对象引用类型实际上因为包装类型非常有用核心库为每种基本类型都提供了对应的包装类型基本类型对应的引用类型通过操作符创建实例不推荐使用会有编译警告通过静态方法创建实例通过静态方法创建实例就是静态工厂方法它尽可能地返回缓存的实例以节省内存进制转换类本身还提供了大量方法例如最常用的静态方法可以把字符串解析成一个整数因为按进制解析还可以把整数格式化为指定进制的字符串表示为进制表示为进制表示为进制表示为进制表示为进制的包装类型还定义了一些有用的静态变量只有两个值其包装类型只需要引用提供的静态字段可表示的最大最小值类型占用的和数量最后所有的整数和浮点数的包装类型都继承自因此可以非常方便地直接通过包装类型获取各种基本类型向上转型为获取处理无符号整型在在中并没有无符号整型的基本数据类型和都是带符号整型最高位是符号位而语言则提供了支持的全部数据类型包括无符号整型无符号整型和有符号整型的转换在中就需要借助包装类型的静态方法完成例如是有符号整型范围是但如果把看作无符号整型它的范围就是我们把一个负的按无符号整型转换为中并没有无符号整型的基本数据类型和都是带符号整型最高位是符号位而语言则提供了支持的全部数据类型包括无符号整型无符号整型和有符号整型的转换在中就需要借助包装类型的静态方法完成例如是有符号整型范围是但如果把看作无符号整型它的范围就是我们把一个负的按无符号整型转换为因为的的二进制表示是以无符号整型转换后的就是类似的可以把一个按转换为把一个按转换为编译器可以帮助我们自动在和之间转型编译器自动使用编译器自动使用这种直接把变为的赋值写法称为自动装箱反过来把变为的赋值写法称为自动拆箱注意自动装箱和自动拆箱只发生在编译阶段目的是为了少写代码装箱和拆箱会影响代码的执行效率因为编译后的代码是严格区分基本类型和引用类型的并且自动拆箱执行时可能会报不变类所有的包装类型都是不变类我们查看的源码可知它的核心代码如下因此一旦创建了对象该对象就是不变的对两个实例进行比较要特别注意绝对不能用比较因为是引用类型必须使用比较仔细观察结果的童鞋可以发现比较较小的两个相同的返回较大的两个相同的返回这是因为是不变类编译器把自动变为为了节省内存对于较小的数始终返回相同的实例因此比较恰好为但我们绝不能因为标准库的内部有缓存优化就用比较必须用方法比较两个创建新对象时优先选用静态工厂方法而不是操作符如果我们考察方法的源码可以看到标准库返回的实例全部是缓存实例但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例廖雪峰在中有很多的定义都符合这样的规范若干实例字段通过方法来读写实例字段例如如果读写方法符合以下这种命名规范读方法写方法那么这种被称为字段比较特殊它的读方法一般命名为读方法写方法只有的属性称为只读属性例如定义一个只读属性对应的读方法是无对应的写方法类似的只有的属性称为只写属性很明显只读属性很常见只写属性不常见属性只需要定义和方法不一定需要对应的字段例如只读属性定义如下可以看出和也是一种数据封装的方法的作用主要用来传递数据即把一组数据组合成一个便于传输此外可以方便地被工具分析生成读写属性的代码主要用在图形界面的可视化设计中通过可以快速生成和例如在中先输入以下代码然后点击右键在弹出的菜单中选择在弹出的对话框中选中需要生成和方法的字段点击确定即可由自动完成所有方法代码枚举属性要枚举一个的所有属性可以直接使用核心库提供的枚举类廖雪峰为了让编译器能自动检查某个值在枚举的集合内并且不同用途的枚举需要不同的类型来标记不能混用我们可以使用来定义枚举类和定义的常量相比使用定义枚举有如下好处首先常量本身带有类型信息即类型是编译器会自动检查出类型错误例如下面的语句不可能编译通过其次不可能引用到非枚举的值因为无法通过编译最后不同类型的枚举不能互相比较或者赋值因为类型不符例如不能给一个枚举类型的变量赋值为枚举类型的值这就使得编译器可以在编译期自动检查出所有可能的潜在错误的比较使用定义的枚举类是一种引用类型前面我们讲到引用类型比较要使用方法如果使用比较它比较的是两个引用类型的变量是否是同一个对象因此引用类型比较要始终使用方法但类型可以例外这是因为类型的每个常量在中只有一个唯一实例所以可以直接用比较类型通过定义的枚举类和其他的有什么区别答案是没有任何区别定义的类型就是只不过它有以下几个特点定义的类型总是继承自且无法被继承只能定义出的实例而无法通过操作符创建的实例定义的每个实例都是引用类型的唯一实例可以将类型用于语句例如我们定义的枚举类编译器编译出的大概就像这样继承自标记为每个实例均为全局唯一构造方法确保外部无法调用操作符所以编译后的类和普通并没有任何区别但是我们自己无法按定义普通那样来定义必须使用关键字这是语法规定的因为是一个每个枚举的值都是实例因此这些实例有一些方法返回常量名例如返回定义的常量的顺序从开始计数例如改变枚举常量定义的顺序就会导致返回值发生变化例如和的就是不同的如果在代码中编写了类似这样的语句就要保证的枚举顺序不能变新增的常量必须放在最后但是如果不小心修改了枚举的顺序编译器是无法检查出这种逻辑错误的要编写健壮的代码就不要依靠的返回值因为本身是所以我们可以定义的构造方法并且给每个枚举常量添加字段这样就无需担心顺序的变化新增枚举常量时也需要指定一个值注意枚举类的字段也可以是非类型即可以在运行期修改但是不推荐这样做默认情况下对枚举常量调用会返回和一样的字符串但是可以被覆写而则不行我们可以给添加方法星期一星期二星期三星期四星期五星期六星期日覆写的目的是在输出时更有可读性注意判断枚举常量的名字要始终使用方法绝不能调用小结使用定义枚举类型它被编译器编译为通过获取常量定义的字符串注意不要使用通过返回常量定义的顺序无实质意义可以为编写构造方法字段和方法的构造方法要声明为字段强烈建议声明为适合用在语句中记录类廖雪峰假设我们希望定义一个类有两个变量同时它是一个不变类可以这么写为了保证不变类的比较还需要正确覆写和方法这样才能在集合类中正常使用后续我们会详细讲解正确覆写和这里演示不变类的写法目的是这些代码写起来都非常简单但是很繁琐从开始引入了新的类我们定义类时使用关键字把上述类改写为类代码如下仔细观察的定义把上述定义改写为相当于以下代码除了用修饰以及每个字段外编译器还自动为我们创建了构造方法和字段名同名的方法以及覆写和方法换句话说使用关键字可以一行写出一个不变类和类似我们自己不能直接从派生只能通过关键字由编译器实现继承构造方法编译器默认按照声明的变量顺序自动创建一个构造方法并在方法内给字段赋值那么问题来了如果我们要检查参数应该怎么办假设类的不允许负数我们就得给的构造方法加上检查逻辑注意到方法被称为它的目的是让我们编写检查逻辑编译器最终生成的构造方法如下这是我们编写的这是编译器继续生成的赋值代码作为的仍然可以添加静态方法一种常用的静态方法是方法用来创建这样我们可以写出更简洁的代码小结从开始提供新的关键字可以非常方便地定义使用定义的是不变类可以编写对参数进行验证可以定义静态方法常用工具类廖雪峰绝对值最大或最小值次方次方为底的对数以为底的对数三角函数数学常量随机数生成一个随机数的范围是每次都不一样如果我们要生成一个区间在的随机数可以借助实现计算如下区间在的随机数的范围是的范围是的范围是的整数有些童鞋可能注意到标准库还提供了一个它提供了和几乎一模一样的方法这两个类的区别在于由于浮点数计算存在误差不同的平台例如和计算的结果可能不一致指误差不同因此保证所有平台计算结果都是完全相同的而会尽量针对平台优化计算速度所以绝大多数情况下使用就足够了用来创建伪随机数所谓伪随机数是指只要给定一个初始的种子产生的随机数序列是完全一样的要生成一个随机数可以使用每次都不一样生成一个之间的每次都不一样生成一个之间的生成一个之间的有童鞋问每次运行程序生成的随机数都是不同的没看出伪随机数的特性来这是因为我们创建实例时如果不给定种子就使用系统当前时间戳作为种子因此每次运行时种子不同得到的伪随机数序列就不同如果我们在创建实例时指定一个种子就会得到完全确定的随机数序列前面我们使用的实际上内部调用了类所以它也是伪随机数只是我们无法指定种子有伪随机数就有真随机数实际上真正的真随机数只能通过量子力学原理来获取而我们想要的是一个不可预测的安全的随机数就是用来创建安全的随机数的异常处理廖雪峰可以没有的异常捕获异常抛出异常自定义异常使用断言使用核心库的程序一旦启动无法再修改配置且使用时需要指定命令使用负责充当日志第三库自动挂载其它日志系统或者负责实现日志底层使用上述结构虽然复杂但我们在实际使用的时候并不需要关心的而是通过配置文件来配置它以配置为例使用的时候我们把一个的文件放到下就可以让读取配置文件并按照我们的配置来输出日志下面是一个配置文件的例子定义日志格式定义文件名变量定义即目的地定义输出到屏幕日志格式引用上面定义的定义输出到文件文件名引用上面定义的根据文件大小自动切割日志保留最近份对级别的日志输出到对级别的日志输出到即上面定义的和前面介绍了和这一对好基友它们一个负责充当日志一个负责实现日志底层搭配使用非常便于开发有的童鞋可能还听说过和这两个东东看上去也像日志它们又是啥其实类似于也是一个日志接口而类似于是一个日志的实现为什么有了和又会蹦出来和这是因为有着非常悠久的开源历史不但本身是开源的而且我们用到的第三方库几乎全部都是开源的开源生态丰富的一个特定就是同一个功能可以找到若干种互相竞争的开源库因为对的接口不满意有人就搞了因为对的性能不满意有人就搞了从目前的趋势来看越来越多的开源项目从加转向了加和可以取代和始终使用的接口写入日志使用只需要配置不需要修改代码反射廖雪峰反射是为了解决在运行期对某个实例一无所知的情况下如何调用其方法类除了等基本类型外的其他类型全部都是包括包括的本质是数据类型是由在执行过程中动态加载的在第一次读取到一种类型时将其加载进内存每加载一种就为其创建一个类型的实例并关联起来注意这里的类型是一个名叫的它长这样以类为例当加载类时它首先读取文件到内存然后为类创建一个实例并关联起来这个实例是内部创建的如果我们查看源码可以发现类的构造方法是只有能创建实例我们自己的程序是无法创建实例的获取实例如何获取一个的实例有三个方法方法一直接通过一个的静态变量获取方法二如果我们有一个实例变量可以通过该实例变量提供的方法获取方法三如果知道一个的完整类名可以通过静态方法获取与比较因为实例在中是唯一的所以上述方法获取的实例是同一个实例可以用比较两个实例注意一下实例比较和的差别因为是类型因为是类型的子类因为返回因为用不但匹配指定类型还匹配指定类型的子类而用判断实例可以精确地判断数据类型但不能作子类型比较通常情况下我们应该用判断数据类型因为面向抽象编程的时候我们不关心具体的子类型只有在需要精确判断一个类型是不是某个的时候我们才使用判断实例因为反射的目的是为了获得某个实例的信息因此当我们拿到某个实例时我们可以通过反射获取该的信息实例来创建对应类型的实例如果获取到了一个实例我们就可以通过该实例来创建对应类型的实例获取的实例创建一个实例上述代码相当于通过可以创建类实例它的局限是只能调用的无参数构造方法带参数的构造方法或者非的构造方法都无法通过被调用动态加载在执行程序的时候并不是一次性把所有用到的全部加载到内存而是第一次需要用到时才加载由于为每个加载的创建了对应的实例并在实例中保存了该的所有信息包括类名包名父类实现的接口所有方法字段等因此如果获取了某个实例我们就可以通过这个实例获取到该实例对应的的所有信息这种通过实例获取信息的方法称为反射访问字段类提供了以下几个方法来获取字段根据字段名获取某个的包括父类根据字段名获取当前类的某个不包括父类获取所有的包括父类获取当前类的所有不包括父类获取字段获取继承的字段获取字段上述代码首先获取的实例然后分别获取字段继承的字段以及字段打印出的类似一个对象包含了一个字段的所有信息返回字段名称例如返回字段类型也是一个实例例如返回字段的修饰符它是一个不同的表示不同的含义以类的字段为例它的定义是我们用反射获取该字段的信息代码如下表示类型获取字段值利用反射拿到字段的一个实例只是第一步我们还可以拿到一个实例对应的该字段的值例如对于一个实例我们可以先拿到字段对应的再获取这个实例的字段的值上述代码先获取实例再获取实例然后用获取指定实例的指定字段的值运行代码如果不出意外会得到一个这是因为被定义为一个字段正常情况下类无法访问类的字段要修复错误可以将改为或者在调用前先写一句调用的意思是别管这个字段是不是一律允许访问可以试着加上上述语句再运行代码就可以打印出字段的值有童鞋会问如果使用反射可以获取字段的值那么类的封装还有什么意义答案是正常情况下我们总是通过来访问的字段编译器会根据和决定是否允许访问字段这样就达到了数据封装的目的而反射是一种非常规的用法使用反射首先代码非常繁琐其次它更多地是给工具或者底层框架来使用目的是在不知道目标实例任何信息的情况下获取特定字段的值此外可能会失败如果运行期存在那么它会根据规则进行检查有可能阻止例如某个可能不允许对和开头的的类调用这样可以保证核心库的安全设置字段值运行上述代码打印的字段从变成了说明通过反射可以直接修改字段的值同样的修改非字段需要首先调用调用方法我们已经能通过实例获取所有对象同样的可以通过实例获取所有信息类提供了以下几个方法来获取获取某个的包括父类获取当前类的某个不包括父类获取所有的包括父类获取当前类的所有不包括父类获取方法参数为获取继承的方法无参数获取方法参数为上述代码首先获取的实例然后分别获取方法继承的方法以及方法打印出的类似一个对象包含一个方法的所有信息返回方法名称例如返回方法返回值类型也是一个实例例如返回方法的参数类型是一个数组例如返回方法的修饰符它是一个不同的表示不同的含义调用方法当我们获取到一个对象时就可以对它进行调用我们以下面的代码为例如果用反射来调用方法需要以下代码对象获取方法参数为在对象上调用该方法并获取结果打印调用结果注意到有两个重载方法我们获取的是这个方法思考一下如何获取方法对实例调用就相当于调用该方法的第一个参数是对象实例即在哪个实例上调用该方法后面的可变参数要与方法参数一致否则将报错调用静态方法如果获取到的表示一个静态方法调用静态方法时由于无需指定实例对象所以方法传入的第一个参数永远为我们以为例获取方法参数为调用该静态方法并获取结果打印调用结果调用非方法和类似对于非方法我们虽然可以通过获取该方法实例但直接对其调用将得到一个为了调用非方法我们通过允许其调用此外可能会失败如果运行期存在那么它会根据规则进行检查有可能阻止例如某个可能不允许对和开头的的类调用这样可以保证核心库的安全多态我们来考察这样一种情况一个类定义了方法并且它的子类也覆写了方法那么从获取的作用于实例时调用的方法到底是哪个获取的方法对实例调用方法运行上述代码发现打印出的是因此使用反射调用方法时仍然遵循多态原则即总是调用实际类型的覆写方法如果存在上述的反射代码实际上相当于调用构造方法我们通常使用操作符创建新的实例如果通过反射来创建新的实例可以调用提供的方法调用的局限是它只能调用该类的无参数构造方法如果构造方法带有参数或者不是就无法直接通过来调用为了调用任意的构造方法的反射提供了对象它包含一个构造方法的所有信息可以创建一个实例对象和非常类似不同之处仅在于它是一个构造方法并且调用结果总是返回实例获取构造方法调用构造方法获取构造方法通过实例获取的方法如下获取某个的获取某个获取所有的获取所有注意总是当前类定义的构造方法和父类无关因此不存在多态的问题调用非的时必须首先通过设置允许访问可能会失败获取继承关系获取父类的有了实例我们还可以获取它的父类的运行上述代码可以看到的父类类型是的父类是的父类是除外其他任何非的都必定存在一个父类类型获取由于一个类可能实现一个或多个接口通过我们就可以查询到实现的接口类型例如查询实现的接口运行上述代码可知实现的接口有要特别注意只返回当前类直接实现的接口类型并不包括其父类实现的接口类型的父类是实现的接口是此外对所有的调用返回的是获取接口的父接口要用因为继承自对接口调用总是返回获取接口的父接口要用如果一个类没有实现任何那么返回空数组继承关系当我们判断一个实例是否是某个类型时正常情况下使用操作符如果是两个实例要判断一个向上转型是否成立可以调用因为可以赋值给因为可以赋值给因为可以赋值给因为不能赋值给动态代理我们来比较的和的区别可以实例化非不能实例化所有类型的变量总是通过某个实例向上转型并赋值给接口类型变量的有没有可能不编写实现类直接在运行期创建某个的实例呢这是可能的因为标准库提供了一种动态代理的机制可以在运行期动态创建某个的实例什么叫运行期动态创建听起来好像很复杂所谓动态代理是和静态相对应的我们来看静态代码怎么写定义接口编写实现类创建实例转型为接口并调用这种方式就是我们通常编写代码的方式还有一种方式是动态代码我们仍然先定义了接口但是我们并不去编写实现类而是直接通过提供的一个创建了一个接口对象这种没有实现类但是在运行期动态创建了一个接口对象的方式我们称为动态代码提供的动态创建接口对象的方式就叫动态代理一个最简单的动态代理实现如下传入传入要实现的接口传入处理调用方法的在运行期动态创建一个实例的方法如下定义一个实例它负责实现接口的方法调用通过创建实例它需要个参数使用的通常就是接口类的需要实现的接口数组至少需要传入一个接口进去用来处理接口方法调用的实例将返回的强制转型为接口动态代理实际上是在运行期动态创建字节码并加载的过程它并没有什么黑魔法把上面的动态代理改写为静态实现类大概长这样其实就是帮我们自动编写了一个上述类不需要源码可以直接生成字节码并不存在可以直接实例化接口的黑魔法小韭菜学生类现在有一位特殊的学生他是区长的儿子我们自然要对他额外照顾要给他加一下功能一种思路是定义一个类区长的儿子类他继承自学生类但世上儿子千千万有区长的儿子也有市长的儿子更有省长的儿子不能把他们挨个定义出来现在就可以使用动态代理机制动态的给区长的儿子加上功能以后碰到市长省长的儿子也同样处理作用就是当代理对象的原本方法被调用的时候会重定向到一个方法这个方法就是里面定义的内容同时会替代原本方法的结果返回接收三个参数代理后的实例对象对象被调用方法调用时的参数从定义方法我可以吃香喝辣从定义方法我的作文题目是我的区长父亲调用普通学生类的方法流程还是要走的还是要交一篇作文上去不能太明目张胆我的作文拿了区作文竞赛一等奖对这个实例对象代理生成一个代理对象被代理后生成的对象是通过接口的字节码增强方式创建的类而构造出来的它是一个临时构造的实现类的对象和基本就是决定了这个类到底是个怎么样的类而是决定了这个代理类到底是多了什么功能通过这些接口和类加载器拿到这个代理类然后通过反射的技术复制拿到代理类的构造函数最后通过这个构造函数个一对象出来同时用绑定这个对象最终实现可以在运行的时候才切入改变类的方法而不需要预先定义它学生接口能跑能吃能写作文小韭菜能跑能吃能写作文我在吃饭我在跑步我在写作文注解廖雪峰什么是注解注解是放在源码的类方法字段参数前的一种特殊注释注释会被编译器直接忽略注解则可以被编译器打包进入文件因此注解是一种用作标注的元数据使用注解注解的作用从的角度看注解本身对代码逻辑没有任何影响如何使用注解完全由工具决定的注解可以分为三类第一类是由编译器使用的注解例如让编译器检查该方法是否正确地实现了覆写告诉编译器忽略此处代码产生的警告这类注解不会被编译进入文件它们在编译后就被编译器扔掉了第二类是由工具处理文件使用的注解比如有些工具会在加载的时候对做动态修改实现一些特殊的功能这类注解会被编译进入文件但加载结束后并不会存在于内存中这类注解只被一些底层库使用一般我们不必自己处理第三类是在程序运行期能够读取的注解它们在加载后一直存在于中这也是最常用的注解例如一个配置了的方法会在调用构造方法后自动被调用这是代码读取该注解实现的功能并不会识别该注解注解的参数定义一个注解时还可以定义配置参数配置参数可以包括所有基本类型枚举类型基本类型以及枚举的数组因为配置参数必须是常量所以上述限制保证了注解在定义时就已经确定了每个参数的值注解的配置参数可以有默认值缺少某个配置参数时将使用默认值此外大部分注解会有一个名为的配置参数对此参数赋值可以只写常量相当于省略了参数如果只写注解相当于全部使用默认值举个栗子对以下代码就是一个注解第一个明确定义了三个参数第二个只定义了一个参数它实际上和是完全一样的最后一个表示所有参数都使用默认值定义注解语言使用语法来定义注解它的格式如下注解的参数类似无参数方法可以用设定一个默认值强烈推荐最常用的参数应当命名为元注解有一些注解可以修饰其他注解这些注解就称为元注解标准库已经定义了一些元注解我们只需要使用元注解通常不需要自己去编写元注解最常用的元注解是使用可以定义能够被应用于源码的哪些位置类或接口字段方法构造方法方法参数例如定义注解可用在方法上我们必须添加一个定义注解可用在方法或字段上可以把注解参数变为数组实际上定义的是数组只有一个元素时可以省略数组的写法另一个重要的元注解定义了的生命周期仅编译期仅文件运行期如果不存在则该默认为因为通常我们自定义的都是所以务必要加上这个元注解使用这个元注解可以定义是否可重复这个注解应用不是特别广泛经过修饰后在某个类型声明处就可以添加多个注解使用定义子类是否可继承父类定义的仅针对类型的有效并且仅针对的继承对的继承无效在使用的时候如果一个类用到了则它的子类默认也定义了该注解如何定义我们总结一下定义的步骤第一步用定义注解第二步添加参数默认值把最常用的参数定义为推荐所有参数都尽量设置默认值第三步用元注解配置注解其中必须设置和一般设置为因为我们自定义的注解通常要求在运行期读取一般情况下不必写和处理注解的注解本身对代码逻辑没有任何影响根据的配置类型的注解在编译期就被丢掉了类型的注解仅保存在文件中它们不会被加载进类型的注解会被加载进并且在运行期可以被程序读取如何使用注解完全由工具决定类型的注解主要由编译器使用因此我们一般只使用不编写类型的注解主要由底层工具库使用涉及到的加载一般我们很少用到只有类型的注解不但要使用还经常需要编写因此我们只讨论如何读取类型的注解因为注解定义后也是一种所有的注解都继承自因此读取注解需要使用反射提供的使用反射读取的方法包括判断某个注解是否存在于或例如判断是否存在于类使用反射读取例如获取定义的注解使用反射读取有两种方法方法一是先判断是否存在如果存在就直接读取第二种方法是直接读取如果不存在将返回读取方法字段和构造方法的和类似但要读取方法参数的就比较麻烦一点因为方法参数本身可以看成一个数组而每个参数又可以定义多个注解所以一次获取方法参数的所有注解就必须用一个二维数组来表示例如对于以下方法定义的注解要读取方法参数的注解我们先用反射获取实例然后读取方法参数的所有注解获取实例获取所有参数的第一个参数索引为的所有注解注解使用注解注解如何使用完全由程序自己决定例如是一个测试框架它会自动运行所有标记为的方法我们来看一个注解我们希望用它来定义一个字段的规则字段长度满足的参数定义在某个中我们可以使用该注解但是定义了注解本身对程序逻辑没有任何影响我们必须自己编写代码来使用注解这里我们编写一个实例的检查方法它可以检查实例的字段长度是否满足的定义遍历所有获取定义的如果存在获取的值如果值是判断值是否满足的这样一来我们通过注解配合方法就可以完成实例的检查注意检查逻辑完全是我们自己编写的不会自动给注解添加任何额外的逻辑',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-03 23:02:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Tech智汇站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 1.05rem;">AI<sup>1</sup></a><a href="/tags/ChatGPT/" style="font-size: 1.05rem;">ChatGPT<sup>1</sup></a><a href="/tags/CloudFlare/" style="font-size: 1.05rem;">CloudFlare<sup>2</sup></a><a href="/tags/EScrcpy/" style="font-size: 1.05rem;">EScrcpy<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 1.05rem;">GitHub<sup>4</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 1.05rem;">NodeJs<sup>1</sup></a><a href="/tags/PowerToys/" style="font-size: 1.05rem;">PowerToys<sup>1</sup></a><a href="/tags/US-KG/" style="font-size: 1.05rem;">US.KG<sup>1</sup></a><a href="/tags/Vip%E8%A7%86%E9%A2%91/" style="font-size: 1.05rem;">Vip视频<sup>1</sup></a><a href="/tags/seal/" style="font-size: 1.05rem;">seal<sup>1</sup></a><a href="/tags/yt-dlp/" style="font-size: 1.05rem;">yt-dlp<sup>1</sup></a><a href="/tags/%E4%BC%91%E7%9C%A0/" style="font-size: 1.05rem;">休眠<sup>1</sup></a><a href="/tags/%E5%85%8D%E8%B4%B9/" style="font-size: 1.05rem;">免费<sup>3</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 1.05rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8A%9F%E8%83%BD%E9%9B%86%E5%90%88%E8%BD%AF%E4%BB%B6/" style="font-size: 1.05rem;">功能集合软件<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D/" style="font-size: 1.05rem;">域名<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D%E6%89%98%E7%AE%A1/" style="font-size: 1.05rem;">域名托管<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7/" style="font-size: 1.05rem;">域名申请<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>26</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">大模型<sup>1</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 1.05rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E5%AD%97/" style="font-size: 1.05rem;">实时语音转文字<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 1.05rem;">廖雪峰<sup>7</sup></a><a href="/tags/%E6%89%8B%E6%9C%BA%E6%8A%95%E5%B1%8F/" style="font-size: 1.05rem;">手机投屏<sup>1</sup></a><a href="/tags/%E6%B3%A8%E9%94%80/" style="font-size: 1.05rem;">注销<sup>1</sup></a><a href="/tags/%E7%94%B5%E9%87%8F%E6%98%BE%E7%A4%BA/" style="font-size: 1.05rem;">电量显示<sup>1</sup></a><a href="/tags/%E7%9D%A1%E7%9C%A0/" style="font-size: 1.05rem;">睡眠<sup>1</sup></a><a href="/tags/%E7%A3%81%E5%8A%9B/" style="font-size: 1.05rem;">磁力<sup>1</sup></a><a href="/tags/%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2/" style="font-size: 1.05rem;">磁力搜索<sup>1</sup></a><a href="/tags/%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/" style="font-size: 1.05rem;">蓝牙设备<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E8%BA%AB%E4%BB%BD%E7%94%9F%E6%88%90/" style="font-size: 1.05rem;">虚拟身份生成<sup>1</sup></a><a href="/tags/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/" style="font-size: 1.05rem;">视频解析<sup>1</sup></a><a href="/tags/%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E5%B9%95/" style="font-size: 1.05rem;">视频转字幕<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%87%8D%E5%90%AF/" style="font-size: 1.05rem;">重启<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>12</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BD%AC%E6%96%87%E5%AD%97/" style="font-size: 1.05rem;">音视频转文字<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">109</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD/" itemprop="url">零基础大数据在线就业班</a></span></div></div><h1 class="post-title" itemprop="name headline">博学谷-零基础大数据在线就业班-第一阶段 java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80/"><header><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD/" itemprop="url">零基础大数据在线就业班</a><h1 id="CrawlerTitle" itemprop="name headline">博学谷-零基础大数据在线就业班-第一阶段 java基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">智汇君</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="undefined 2025-01-17 17:35:02">2025-01-17</time></header><h1 id="博学谷-零基础大数据在线就业班-第一阶段-java基础"><a href="#博学谷-零基础大数据在线就业班-第一阶段-java基础" class="headerlink" title="博学谷-零基础大数据在线就业班-第一阶段 java基础"></a>博学谷-零基础大数据在线就业班-第一阶段 java基础</h1><h2 id="第一章-java基础语法"><a href="#第一章-java基础语法" class="headerlink" title="第一章 java基础语法"></a>第一章 java基础语法</h2><h3 id="环境搭建-入门"><a href="#环境搭建-入门" class="headerlink" title="环境搭建+入门"></a>环境搭建+入门</h3><h4 id="java语言背景介绍"><a href="#java语言背景介绍" class="headerlink" title="java语言背景介绍"></a>java语言背景介绍</h4><h4 id="java语言跨平台原理"><a href="#java语言跨平台原理" class="headerlink" title="java语言跨平台原理"></a>java语言跨平台原理</h4><h4 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/ttyong/hexoBlog/raw/master/%E6%9E%97%E5%AD%90%E9%9B%A8%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/202311122356404.png" alt="image-20231112235606219"></p>
<h4 id="JDK的下载和安装"><a href="#JDK的下载和安装" class="headerlink" title="JDK的下载和安装"></a>JDK的下载和安装</h4><h4 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h4><h4 id="PATH环境变量的配置"><a href="#PATH环境变量的配置" class="headerlink" title="PATH环境变量的配置"></a>PATH环境变量的配置</h4><h4 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译 javac xxx.java</span><br><span class="line">运行 java xxx  // 不需要后缀zhui .class</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名前有public时，类名必须与文件名一致</span><br><span class="line">一个程序必须有入口方法main</span><br></pre></td></tr></table></figure>



<h4 id="Notepad软件的安装和使用"><a href="#Notepad软件的安装和使用" class="headerlink" title="Notepad软件的安装和使用"></a>Notepad软件的安装和使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高级的记事本，方便代码编写(有行号)</span><br><span class="line"></span><br><span class="line">配置默认代码语言和编码ascII</span><br></pre></td></tr></table></figure>

<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行 //</span><br><span class="line">多行 /*  */</span><br><span class="line">文档注释 /**  */</span><br></pre></td></tr></table></figure>

<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">关键字全小写</span><br><span class="line">常用代码编辑器里关键字有特殊颜色</span><br><span class="line"></span><br><span class="line">public </span><br><span class="line">class</span><br><span class="line">void</span><br><span class="line">static</span><br><span class="line"></span><br><span class="line">main不是关键字</span><br></pre></td></tr></table></figure>



<h3 id="数据类型及转换"><a href="#数据类型及转换" class="headerlink" title="数据类型及转换"></a>数据类型及转换</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串常量</span><br><span class="line">整数常量</span><br><span class="line">小数常量</span><br><span class="line">字符常量</span><br><span class="line">布尔常量</span><br><span class="line">空常量null</span><br></pre></td></tr></table></figure>



<h4 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h4><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/ttyong/hexoBlog/raw/master/%E6%9E%97%E5%AD%90%E9%9B%A8%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/202311130120919.png" alt="image-20231113012013098"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整数    字节   范围</span><br><span class="line">byte    1</span><br><span class="line">short	2</span><br><span class="line">int(默认) 	4   建议</span><br><span class="line">long	8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浮点数   字节   范围</span><br><span class="line">float 	4</span><br><span class="line">double(默认)	8     建议</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符    字节   范围</span><br><span class="line">char	2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔    字节   范围</span><br><span class="line">boolean 1</span><br></pre></td></tr></table></figure>



<h4 id="变量的定义和使用"><a href="#变量的定义和使用" class="headerlink" title="变量的定义和使用"></a>变量的定义和使用</h4><h4 id="变量的注意事项"><a href="#变量的注意事项" class="headerlink" title="变量的注意事项"></a>变量的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">同名变量不可以重复定义</span><br><span class="line">一条语句可以定义多个变量，用逗号隔开</span><br><span class="line">变量在使用之前一定要赋值</span><br><span class="line">定义float变量类型时，需要在数值后面加入F或f</span><br><span class="line">float n = 12.5f;</span><br><span class="line">定义long变量类型时，需要在数值后面加入L或l</span><br><span class="line">定义的变量只在所在的大括号内有效(当这个大括号执行完毕后，内存中这个变量会消失)</span><br></pre></td></tr></table></figure>



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h3 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h3><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h3 id="随机数-开发工具"><a href="#随机数-开发工具" class="headerlink" title="随机数+开发工具"></a>随机数+开发工具</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="方法与debug"><a href="#方法与debug" class="headerlink" title="方法与debug"></a>方法与debug</h3><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h2 id="第二章-面向对象基础"><a href="#第二章-面向对象基础" class="headerlink" title="第二章 面向对象基础"></a>第二章 面向对象基础</h2><h2 id="第三章-API基础"><a href="#第三章-API基础" class="headerlink" title="第三章 API基础"></a>第三章 API基础</h2><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符串串接，在次数多的情况下(如循环)会很占内存(生成临lin时对象)。StringBuilder可以解决，不会生成临时对象。</span><br><span class="line"></span><br><span class="line">它的方法可以实现链式操作。核心就是方法执行完返回this，所以自己也可以实现类似si的类。</span><br><span class="line"></span><br><span class="line">提高字符串操作效率(50000次字符串拼接，string用了2939ms，StringBuilder用了264ms)</span><br><span class="line">可变字符串类，可以视为一个容器</span><br><span class="line"></span><br><span class="line">来自于java.lang. 不需要手动导入</span><br><span class="line"></span><br><span class="line">直接打印的结果是容器里的内容，不是地址</span><br></pre></td></tr></table></figure>

<h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><h5 id="public-StringBuilder"><a href="#public-StringBuilder" class="headerlink" title="public StringBuilder()"></a>public StringBuilder()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认创建一个空字符对象</span><br></pre></td></tr></table></figure>

<h5 id="public-StringBuilder-String-str"><a href="#public-StringBuilder-String-str" class="headerlink" title="public StringBuilder(String str)"></a>public StringBuilder(String str)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认创建一个以传入字符串为基础的对象</span><br></pre></td></tr></table></figure>

<h4 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接受任意数据类型，返回对象本身(可以链式调用)</span><br></pre></td></tr></table></figure>

<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素内容反转 返回对象本身</span><br></pre></td></tr></table></figure>

<h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><h4 id="StringBuilder如何提高的效率"><a href="#StringBuilder如何提高的效率" class="headerlink" title="StringBuilder如何提高的效率"></a>StringBuilder如何提高的效率</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/ttyong/hexoBlog/raw/master/%E6%9E%97%E5%AD%90%E9%9B%A8%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/202311120847238.png" alt="image-20231112084743115"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/ttyong/hexoBlog/raw/master/%E6%9E%97%E5%AD%90%E9%9B%A8%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/202311120852533.png" alt="image-20231112085222322"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串反转</span><br><span class="line">打印数组的样子</span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer-廖雪峰"><a href="#StringBuffer-廖雪峰" class="headerlink" title="StringBuffer(廖雪峰)"></a>StringBuffer(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。</span><br><span class="line"></span><br><span class="line">StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer</span><br></pre></td></tr></table></figure>

<h3 id="StringJoiner-廖雪峰"><a href="#StringJoiner-廖雪峰" class="headerlink" title="StringJoiner(廖雪峰)"></a>StringJoiner(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类似用分隔符拼接数组的需求</span><br><span class="line">var sj = new StringJoiner(&quot;, &quot;);</span><br><span class="line">var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">String[] names = &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;</span><br><span class="line">var s = String.join(&quot;, &quot;, names);</span><br><span class="line">在不需要指定“开头”和“结尾”的时候，用String.join()更方便</span><br></pre></td></tr></table></figure>

<h3 id="包装类型-廖雪峰"><a href="#包装类型-廖雪峰" class="headerlink" title="包装类型(廖雪峰)"></a>包装类型(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">引用类型可以赋值为null，表示空，但基本类型不能赋值为null</span><br><span class="line"></span><br><span class="line">那么，如何把一个基本类型视为对象（引用类型）？</span><br><span class="line"></span><br><span class="line">实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型</span><br><span class="line"></span><br><span class="line">基本类型	对应的引用类型</span><br><span class="line">boolean	java.lang.Boolean</span><br><span class="line">byte	java.lang.Byte</span><br><span class="line">short	java.lang.Short</span><br><span class="line">int	java.lang.Integer</span><br><span class="line">long	java.lang.Long</span><br><span class="line">float	java.lang.Float</span><br><span class="line">double	java.lang.Double</span><br><span class="line">char	java.lang.Character</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 100;</span><br><span class="line">        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span><br><span class="line">        Integer n1 = new Integer(i);</span><br><span class="line">        // 通过静态方法valueOf(int)创建Integer实例:</span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        // 通过静态方法valueOf(String)创建Integer实例:</span><br><span class="line">        Integer n3 = Integer.valueOf(&quot;100&quot;);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 100;</span><br><span class="line">Integer n = Integer.valueOf(i);</span><br><span class="line">int x = n.intValue();</span><br><span class="line"></span><br><span class="line">Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</span><br></pre></td></tr></table></figure>

<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数：</span><br><span class="line"></span><br><span class="line">int x1 = Integer.parseInt(&quot;100&quot;); // 100</span><br><span class="line">int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer还可以把整数格式化为指定进制的字符串：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制</span><br><span class="line">        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制</span><br><span class="line">        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制</span><br><span class="line">        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制</span><br><span class="line">        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Java的包装类型还定义了一些有用的静态变量</span><br><span class="line"></span><br><span class="line">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">// int可表示的最大/最小值:</span><br><span class="line">int max = Integer.MAX_VALUE; // 2147483647</span><br><span class="line">int min = Integer.MIN_VALUE; // -2147483648</span><br><span class="line"></span><br><span class="line">// long类型占用的bit和byte数量:</span><br><span class="line">int sizeOfLong = Long.SIZE; // 64 (bits)</span><br><span class="line">int bytesOfLong = Long.BYTES; // 8 (bytes)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</span><br><span class="line"></span><br><span class="line">// 向上转型为Number:</span><br><span class="line">Number num = new Integer(999);</span><br><span class="line">// 获取byte, int, long, float, double:</span><br><span class="line">byte b = num.byteValue();</span><br><span class="line">int n = num.intValue();</span><br><span class="line">long ln = num.longValue();</span><br><span class="line">float f = num.floatValue();</span><br><span class="line">double d = num.doubleValue();</span><br></pre></td></tr></table></figure>

<h4 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在Java在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</span><br><span class="line"></span><br><span class="line">例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</span><br><span class="line"></span><br><span class="line">例如，byte是有符号整型，范围是-128~+127，但如果把byte看作无符号整型，它的范围就是0~255。我们把一个负的byte按无符号整型转换为int：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte x = -1;</span><br><span class="line">        byte y = 127;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); // 255</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); // 127</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。</span><br><span class="line"></span><br><span class="line">类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。</span><br></pre></td></tr></table></figure>



<h4 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java编译器可以帮助我们自动在int和Integer之间转型：</span><br><span class="line"></span><br><span class="line">Integer n = 100; // 编译器自动使用Integer.valueOf(int)</span><br><span class="line">int x = n; // 编译器自动使用Integer.intValue()</span><br><span class="line">这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</span><br><span class="line"></span><br><span class="line">装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer n = null;</span><br><span class="line">        int i = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下：</span><br><span class="line"></span><br><span class="line">public final class Integer &#123;</span><br><span class="line">    private final int value;</span><br><span class="line">&#125;</span><br><span class="line">因此，一旦创建了Integer对象，该对象就是不变的。</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer x = 127;</span><br><span class="line">        Integer y = 127;</span><br><span class="line">        Integer m = 99999;</span><br><span class="line">        Integer n = 99999;</span><br><span class="line">        System.out.println(&quot;x == y: &quot; + (x==y)); // true</span><br><span class="line">        System.out.println(&quot;m == n: &quot; + (m==n)); // false</span><br><span class="line">        System.out.println(&quot;x.equals(y): &quot; + x.equals(y)); // true</span><br><span class="line">        System.out.println(&quot;m.equals(n): &quot; + m.equals(n)); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建新对象时，优先选用静态工厂方法而不是new操作符。</span><br><span class="line"></span><br><span class="line">如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-廖雪峰"><a href="#JavaBean-廖雪峰" class="headerlink" title="JavaBean(廖雪峰)"></a>JavaBean(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在Java中，有很多class的定义都符合这样的规范：</span><br><span class="line"></span><br><span class="line">若干private实例字段；</span><br><span class="line">通过public方法来读写实例字段。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123; return this.name; &#125;</span><br><span class="line">    public void setName(String name) &#123; this.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123; return this.age; &#125;</span><br><span class="line">    public void setAge(int age) &#123; this.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果读写方法符合以下这种命名规范：</span><br><span class="line"></span><br><span class="line">// 读方法:</span><br><span class="line">public Type getXyz()</span><br><span class="line">// 写方法:</span><br><span class="line">public void setXyz(Type value)</span><br><span class="line"></span><br><span class="line">那么这种class被称为JavaBean</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean字段比较特殊，它的读方法一般命名为isXyz()：</span><br><span class="line"></span><br><span class="line">// 读方法:</span><br><span class="line">public boolean isChild()</span><br><span class="line">// 写方法:</span><br><span class="line">public void setChild(boolean value)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性：</span><br><span class="line"></span><br><span class="line">对应的读方法是int getAge()</span><br><span class="line">无对应的写方法setAge(int)</span><br><span class="line">类似的，只有setter的属性称为只写属性（write-only）。</span><br><span class="line"></span><br><span class="line">很明显，只读属性很常见，只写属性不常见</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下：</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123; return this.name; &#125;</span><br><span class="line">    public void setName(String name) &#123; this.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123; return this.age; &#125;</span><br><span class="line">    public void setAge(int age) &#123; this.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isChild() &#123;</span><br><span class="line">        return age &lt;= 6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看出，getter和setter也是一种数据封装的方法。</span><br></pre></td></tr></table></figure>

<h4 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</span><br><span class="line"></span><br><span class="line">通过IDE，可以快速生成getter和setter。例如，在Eclipse中，先输入以下代码：</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line">然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成getter和setter方法的字段，点击确定即可由IDE自动完成所有方法代码。</span><br></pre></td></tr></table></figure>

<h4 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector</span><br><span class="line"></span><br><span class="line">import java.beans.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        for (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(&quot;  &quot; + pd.getReadMethod());</span><br><span class="line">            System.out.println(&quot;  &quot; + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类-廖雪峰"><a href="#枚举类-廖雪峰" class="headerlink" title="枚举类(廖雪峰)"></a>枚举类(廖雪峰)</h3><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        if (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(&quot;Work at home!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Work at office!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">和int定义的常量相比，使用enum定义枚举有如下好处：</span><br><span class="line"></span><br><span class="line">首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</span><br><span class="line"></span><br><span class="line">int day = 1;</span><br><span class="line">if (day == Weekday.SUN) &#123; // Compile error: bad operand types for binary operator &#x27;==&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其次，不可能引用到非枚举的值，因为无法通过编译。</span><br><span class="line"></span><br><span class="line">最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值：</span><br><span class="line"></span><br><span class="line">Weekday x = Weekday.SUN; // ok!</span><br><span class="line">Weekday y = Color.RED; // Compile error: incompatible types</span><br><span class="line"></span><br><span class="line">这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</span><br></pre></td></tr></table></figure>

<h4 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。</span><br><span class="line"></span><br><span class="line">这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较：</span><br><span class="line"></span><br><span class="line">if (day == Weekday.FRI) &#123; // ok!</span><br><span class="line">&#125;</span><br><span class="line">if (day.equals(Weekday.SUN)) &#123; // ok, but more code!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过enum定义的枚举类，和其他的class有什么区别？</span><br><span class="line"></span><br><span class="line">答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点：</span><br><span class="line"></span><br><span class="line">定义的enum类型总是继承自java.lang.Enum，且无法被继承；</span><br><span class="line">只能定义出enum的实例，而无法通过new操作符创建enum的实例；</span><br><span class="line">定义的每个实例都是引用类型的唯一实例；</span><br><span class="line">可以将enum类型用于switch语句。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例如，我们定义的Color枚举类：</span><br><span class="line"></span><br><span class="line">public enum Color &#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译器编译出的class大概就像这样：</span><br><span class="line">public final class Color extends Enum &#123; // 继承自Enum，标记为final class</span><br><span class="line">    // 每个实例均为全局唯一:</span><br><span class="line">    public static final Color RED = new Color();</span><br><span class="line">    public static final Color GREEN = new Color();</span><br><span class="line">    public static final Color BLUE = new Color();</span><br><span class="line">    // private构造方法，确保外部无法调用new操作符:</span><br><span class="line">    private Color() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所以，编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。</span><br><span class="line"></span><br><span class="line">因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法：</span><br></pre></td></tr></table></figure>

<h5 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回常量名，例如：</span><br><span class="line"></span><br><span class="line">String s = Weekday.SUN.name(); // &quot;SUN&quot;</span><br></pre></td></tr></table></figure>

<h5 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">返回定义的常量的顺序，从0开始计数，例如：</span><br><span class="line">int n = Weekday.MON.ordinal(); // 1</span><br><span class="line"></span><br><span class="line">改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。例如：</span><br><span class="line">public enum Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br><span class="line">public enum Weekday &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">的ordinal就是不同的。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        if (day.dayValue == 6 || day.dayValue == 0) &#123;</span><br><span class="line">            System.out.println(&quot;Work at home!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Work at office!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);</span><br><span class="line"></span><br><span class="line">    public final int dayValue;</span><br><span class="line"></span><br><span class="line">    private Weekday(int dayValue) &#123;</span><br><span class="line">        this.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个int值。</span><br><span class="line"></span><br><span class="line">注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</span><br></pre></td></tr></table></figure>

<h5 id="toString"><a href="#toString" class="headerlink" title="toString()"></a>toString()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        if (day.dayValue == 6 || day.dayValue == 0) &#123;</span><br><span class="line">            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);</span><br><span class="line"></span><br><span class="line">    public final int dayValue;</span><br><span class="line">    private final String chinese;</span><br><span class="line"></span><br><span class="line">    private Weekday(int dayValue, String chinese) &#123;</span><br><span class="line">        this.dayValue = dayValue;</span><br><span class="line">        this.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">覆写toString()的目的是在输出时更有可读性。</span><br><span class="line"></span><br><span class="line">注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</span><br></pre></td></tr></table></figure>

<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        switch(day) &#123;</span><br><span class="line">        case MON:</span><br><span class="line">        case TUE:</span><br><span class="line">        case WED:</span><br><span class="line">        case THU:</span><br><span class="line">        case FRI:</span><br><span class="line">            System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case SAT:</span><br><span class="line">        case SUN:</span><br><span class="line">            System.out.println(&quot;Today is &quot; + day + &quot;. Work at home!&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new RuntimeException(&quot;cannot process &quot; + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Weekday &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum &#123; … &#125;；</span><br><span class="line"></span><br><span class="line">通过name()获取常量定义的字符串，注意不要使用toString()；</span><br><span class="line"></span><br><span class="line">通过ordinal()返回常量定义的顺序（无实质意义）；</span><br><span class="line"></span><br><span class="line">可以为enum编写构造方法、字段和方法</span><br><span class="line"></span><br><span class="line">enum的构造方法要声明为private，字段强烈建议声明为final；</span><br><span class="line"></span><br><span class="line">enum适合用在switch语句中。</span><br></pre></td></tr></table></figure>

<h3 id="记录类-廖雪峰"><a href="#记录类-廖雪峰" class="headerlink" title="记录类(廖雪峰)"></a>记录类(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">假设我们希望定义一个Point类，有x、y两个变量，同时它是一个不变类，可以这么写：</span><br><span class="line"></span><br><span class="line">public final class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int x() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int y() &#123;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写equals()和hashCode()，这里演示Point不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</span><br></pre></td></tr></table></figure>

<h4 id="record"><a href="#record" class="headerlink" title="record"></a>record</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record。把上述Point类改写为Record类，代码如下：</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point p = new Point(123, 456);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">record Point(int x, int y) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">仔细观察Point的定义：</span><br><span class="line">record Point(int x, int y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把上述定义改写为class，相当于以下代码：</span><br><span class="line">final class Point extends Record &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int x() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int y() &#123;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;Point[x=%s, y=%s]&quot;, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。</span><br><span class="line"></span><br><span class="line">换句话说，使用record关键字，可以一行写出一个不变类。</span><br><span class="line"></span><br><span class="line">和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</span><br><span class="line"></span><br><span class="line">假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑：</span><br><span class="line"></span><br><span class="line">public record Point(int x, int y) &#123;</span><br><span class="line">    public Point &#123;</span><br><span class="line">        if (x &lt; 0 || y &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意到方法public Point &#123;...&#125;被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</span><br><span class="line">public final class Point extends Record &#123;</span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        // 这是我们编写的Compact Constructor:</span><br><span class="line">        if (x &lt; 0 || y &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 这是编译器继续生成的赋值代码:</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">作为record的Point仍然可以添加静态方法。一种常用的静态方法是of()方法，用来创建Point：</span><br><span class="line"></span><br><span class="line">public record Point(int x, int y) &#123;</span><br><span class="line">    public static Point of() &#123;</span><br><span class="line">        return new Point(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Point of(int x, int y) &#123;</span><br><span class="line">        return new Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样我们可以写出更简洁的代码：</span><br><span class="line">var z = Point.of();</span><br><span class="line">var p = Point.of(123, 456);</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class：</span><br><span class="line"></span><br><span class="line">使用record定义的是不变类；</span><br><span class="line"></span><br><span class="line">可以编写Compact Constructor对参数进行验证；</span><br><span class="line"></span><br><span class="line">可以定义静态方法。</span><br></pre></td></tr></table></figure>

<h3 id="常用工具类-廖雪峰"><a href="#常用工具类-廖雪峰" class="headerlink" title="常用工具类(廖雪峰)"></a>常用工具类(廖雪峰)</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h5><h5 id="最大或最小值"><a href="#最大或最小值" class="headerlink" title="最大或最小值"></a>最大或最小值</h5><h5 id="xy次方"><a href="#xy次方" class="headerlink" title="xy次方"></a>xy次方</h5><h5 id="√x"><a href="#√x" class="headerlink" title="√x"></a>√x</h5><h5 id="ex次方"><a href="#ex次方" class="headerlink" title="ex次方"></a>ex次方</h5><h5 id="e为底的对数"><a href="#e为底的对数" class="headerlink" title="e为底的对数"></a>e为底的对数</h5><h5 id="以10为底的对数"><a href="#以10为底的对数" class="headerlink" title="以10为底的对数"></a>以10为底的对数</h5><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><h5 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h5><h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生成一个随机数x，x的范围是0 &lt;= x &lt; 1：</span><br><span class="line"></span><br><span class="line">Math.random(); // 0.53907... 每次都不一样</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下：</span><br><span class="line"></span><br><span class="line">// 区间在[MIN, MAX)的随机数</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double x = Math.random(); // x的范围是[0,1)</span><br><span class="line">        double min = 10;</span><br><span class="line">        double max = 50;</span><br><span class="line">        double y = x * (max - min) + min; // y的范围是[10,50)</span><br><span class="line">        long n = (long) y; // n的范围是[10,50)的整数</span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StrictMath"><a href="#StrictMath" class="headerlink" title="StrictMath"></a>StrictMath</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些童鞋可能注意到Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。</span><br></pre></td></tr></table></figure>

<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</span><br><span class="line"></span><br><span class="line">要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：</span><br><span class="line"></span><br><span class="line">Random r = new Random();</span><br><span class="line">r.nextInt(); // 2071575453,每次都不一样</span><br><span class="line">r.nextInt(10); // 5,生成一个[0,10)之间的int</span><br><span class="line">r.nextLong(); // 8811649292570369305,每次都不一样</span><br><span class="line">r.nextFloat(); // 0.54335...生成一个[0,1)之间的float</span><br><span class="line">r.nextDouble(); // 0.3716...生成一个[0,1)之间的double</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。</span><br><span class="line"></span><br><span class="line">这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</span><br><span class="line"></span><br><span class="line">如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r = new Random(12345);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(100));</span><br><span class="line">        &#125;</span><br><span class="line">        // 51, 80, 41, 28, 55...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。</span><br></pre></td></tr></table></figure>

<h4 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-廖雪峰"><a href="#异常处理-廖雪峰" class="headerlink" title="异常处理(廖雪峰)"></a>异常处理(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">xxx</span><br><span class="line">catch(xxxx e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;catch(xxx e)&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;finally&#123; //可以没有</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java的异常"><a href="#java的异常" class="headerlink" title="java的异常"></a>java的异常</h4><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><h4 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h4><h4 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h4><h4 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java核心库的，程序一旦启动无法再修改配置，且使用时需要指定命令</span><br></pre></td></tr></table></figure>

<h4 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负责充当日志API 第三库；自动挂载其它日志系统，jdk logging或者log4j(负责实现日志底层)</span><br></pre></td></tr></table></figure>

<h4 id="使用Log4j"><a href="#使用Log4j" class="headerlink" title="使用Log4j"></a>使用Log4j</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</span><br><span class="line"></span><br><span class="line">以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</span><br><span class="line"></span><br><span class="line">有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</span><br><span class="line"></span><br><span class="line">其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</span><br><span class="line"></span><br><span class="line">为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</span><br><span class="line"></span><br><span class="line">因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</span><br><span class="line"></span><br><span class="line">SLF4J和Logback可以取代Commons Logging和Log4j；</span><br><span class="line">始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。</span><br></pre></td></tr></table></figure>

<h3 id="反射-廖雪峰"><a href="#反射-廖雪峰" class="headerlink" title="反射(廖雪峰)"></a>反射(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</span><br></pre></td></tr></table></figure>

<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除了int等基本类型外，Java的其他类型全部都是class（包括interface）</span><br><span class="line"></span><br><span class="line">class（包括interface）的本质是数据类型（Type）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。</span><br><span class="line"></span><br><span class="line">每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样：</span><br><span class="line"></span><br><span class="line">public final class Class &#123;</span><br><span class="line">    private Class() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来：</span><br><span class="line"></span><br><span class="line">Class cls = new Class(String);</span><br><span class="line"></span><br><span class="line">这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。</span><br></pre></td></tr></table></figure>

<h5 id="获取Class实例"><a href="#获取Class实例" class="headerlink" title="获取Class实例"></a>获取Class实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如何获取一个class的Class实例？有三个方法：</span><br><span class="line"></span><br><span class="line">方法一：直接通过一个class的静态变量class获取：</span><br><span class="line"></span><br><span class="line">Class cls = String.class;</span><br><span class="line">方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello&quot;;</span><br><span class="line">Class cls = s.getClass();</span><br><span class="line">方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：</span><br><span class="line"></span><br><span class="line">Class cls = Class.forName(&quot;java.lang.String&quot;);</span><br></pre></td></tr></table></figure>

<h5 id="与instanceof比较"><a href="#与instanceof比较" class="headerlink" title="与instanceof比较"></a>与instanceof比较</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例：</span><br><span class="line"></span><br><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello&quot;;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line">boolean sameClass = cls1 == cls2; // true</span><br><span class="line">注意一下Class实例比较和instanceof的差别：</span><br><span class="line"></span><br><span class="line">Integer n = new Integer(123);</span><br><span class="line"></span><br><span class="line">boolean b1 = n instanceof Integer; // true，因为n是Integer类型</span><br><span class="line">boolean b2 = n instanceof Number; // true，因为n是Number类型的子类</span><br><span class="line"></span><br><span class="line">boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class</span><br><span class="line">boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用instanceof不但匹配指定类型，还匹配指定类型的子类。而用==判断class实例可以精确地判断数据类型，但不能作子类型比较。</span><br><span class="line"></span><br><span class="line">通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个Object实例时，我们可以通过反射获取该Object的class信息：</span><br><span class="line"></span><br><span class="line">void printObjectInfo(Object obj) &#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Class实例来创建对应类型的实例"><a href="#Class实例来创建对应类型的实例" class="headerlink" title="Class实例来创建对应类型的实例"></a>Class实例来创建对应类型的实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果获取到了一个Class实例，我们就可以通过该Class实例来创建对应类型的实例：</span><br><span class="line"></span><br><span class="line">// 获取String的Class实例:</span><br><span class="line">Class cls = String.class;</span><br><span class="line">// 创建一个String实例:</span><br><span class="line">String s = (String) cls.newInstance();</span><br><span class="line"></span><br><span class="line">上述代码相当于new String()。通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用</span><br></pre></td></tr></table></figure>

<h5 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</span><br><span class="line"></span><br><span class="line">由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</span><br><span class="line"></span><br><span class="line">这种通过Class实例获取class信息的方法称为反射（Reflection）</span><br></pre></td></tr></table></figure>

<h4 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class类提供了以下几个方法来获取字段：</span><br><span class="line"></span><br><span class="line">Field getField(name)：根据字段名获取某个public的field（包括父类）</span><br><span class="line">Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</span><br><span class="line">Field[] getFields()：获取所有public的field（包括父类）</span><br><span class="line">Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        // 获取public字段&quot;score&quot;:</span><br><span class="line">        System.out.println(stdClass.getField(&quot;score&quot;));</span><br><span class="line">        // 获取继承的public字段&quot;name&quot;:</span><br><span class="line">        System.out.println(stdClass.getField(&quot;name&quot;));</span><br><span class="line">        // 获取private字段&quot;grade&quot;:</span><br><span class="line">        System.out.println(stdClass.getDeclaredField(&quot;grade&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">    public int score;</span><br><span class="line">    private int grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上述代码首先获取Student的Class实例，然后，分别获取public字段、继承的public字段以及private字段，打印出的Field类似：</span><br><span class="line"></span><br><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个Field对象包含了一个字段的所有信息：</span><br><span class="line"></span><br><span class="line">getName()：返回字段名称，例如，&quot;name&quot;；</span><br><span class="line">getType()：返回字段类型，也是一个Class实例，例如，String.class；</span><br><span class="line">getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">以String类的value字段为例，它的定义是：</span><br><span class="line"></span><br><span class="line">public final class String &#123;</span><br><span class="line">    private final byte[] value;</span><br><span class="line">&#125;</span><br><span class="line">我们用反射获取该字段的信息，代码如下：</span><br><span class="line"></span><br><span class="line">Field f = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line">f.getName(); // &quot;value&quot;</span><br><span class="line">f.getType(); // class [B 表示byte[]类型</span><br><span class="line">int m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); // true</span><br><span class="line">Modifier.isPublic(m); // false</span><br><span class="line">Modifier.isProtected(m); // false</span><br><span class="line">Modifier.isPrivate(m); // true</span><br><span class="line">Modifier.isStatic(m); // false</span><br></pre></td></tr></table></figure>

<h5 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用反射拿到字段的一个Field实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</span><br><span class="line"></span><br><span class="line">例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上述代码先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。</span><br><span class="line"></span><br><span class="line">运行代码，如果不出意外，会得到一个IllegalAccessException，这是因为name被定义为一个private字段，正常情况下，Main类无法访问Person类的private字段。要修复错误，可以将private改为public，或者，在调用Object value = f.get(p);前，先写一句：</span><br><span class="line"></span><br><span class="line">f.setAccessible(true);</span><br><span class="line">调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。</span><br><span class="line"></span><br><span class="line">可以试着加上上述语句，再运行代码，就可以打印出private字段的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有童鞋会问：如果使用反射可以获取private字段的值，那么类的封装还有什么意义？</span><br><span class="line"></span><br><span class="line">答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。</span><br><span class="line"></span><br><span class="line">而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</span><br><span class="line"></span><br><span class="line">此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。</span><br></pre></td></tr></table></figure>

<h5 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行上述代码，打印的name字段从Xiao Ming变成了Xiao Hong，说明通过反射可以直接修改字段的值。</span><br><span class="line"></span><br><span class="line">同样的，修改非public字段，需要首先调用setAccessible(true)。</span><br></pre></td></tr></table></figure>

<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method：</span><br><span class="line"></span><br><span class="line">Method getMethod(name, Class...)：获取某个public的Method（包括父类）</span><br><span class="line">Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）</span><br><span class="line">Method[] getMethods()：获取所有public的Method（包括父类）</span><br><span class="line">Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="type">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上述代码首先获取Student的Class实例，然后，分别获取public方法、继承的public方法以及private方法，打印出的Method类似：</span><br><span class="line"></span><br><span class="line">public int Student.getScore(java.lang.String)</span><br><span class="line">public java.lang.String Person.getName()</span><br><span class="line">private int Student.getGrade(int)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个Method对象包含一个方法的所有信息：</span><br><span class="line"></span><br><span class="line">getName()：返回方法名称，例如：&quot;getScore&quot;；</span><br><span class="line">getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；</span><br><span class="line">getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：&#123;String.class, int.class&#125;；</span><br><span class="line">getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</span><br></pre></td></tr></table></figure>

<h5 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当我们获取到一个Method对象时，就可以对它进行调用。我们以下面的代码为例：</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello world&quot;;</span><br><span class="line">String r = s.substring(6); // &quot;world&quot;</span><br><span class="line">如果用反射来调用substring方法，需要以下代码：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意到substring()有两个重载方法，我们获取的是String substring(int)这个方法。思考一下如何获取String substring(int, int)方法。</span><br><span class="line"></span><br><span class="line">对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</span><br></pre></td></tr></table></figure>

<h5 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。我们以Integer.parseInt(String)为例：</span><br><span class="line"></span><br><span class="line">// reflection</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取Integer.parseInt(String)方法，参数为String:</span><br><span class="line">        Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);</span><br><span class="line">        // 调用该静态方法并获取结果:</span><br><span class="line">        Integer n = (Integer) m.invoke(null, &quot;12345&quot;);</span><br><span class="line">        // 打印调用结果:</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。</span><br></pre></td></tr></table></figure>

<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">h</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行上述代码，发现打印出的是Student:hello，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</span><br><span class="line"></span><br><span class="line">Method m = Person.class.getMethod(&quot;hello&quot;);</span><br><span class="line">m.invoke(new Student());</span><br><span class="line">实际上相当于：</span><br><span class="line"></span><br><span class="line">Person p = new Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>

<h4 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们通常使用new操作符创建新的实例：</span><br><span class="line"></span><br><span class="line">Person p = new Person();</span><br><span class="line">如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</span><br><span class="line"></span><br><span class="line">Person p = Person.class.newInstance();</span><br><span class="line">调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取构造方法Integer(int):</span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(int.class);</span><br><span class="line">        // 调用构造方法:</span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(123);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        // 获取构造方法Integer(String)</span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过Class实例获取Constructor的方法如下：</span><br><span class="line"></span><br><span class="line">getConstructor(Class...)：获取某个public的Constructor；</span><br><span class="line">getDeclaredConstructor(Class...)：获取某个Constructor；</span><br><span class="line">getConstructors()：获取所有public的Constructor；</span><br><span class="line">getDeclaredConstructors()：获取所有Constructor。</span><br><span class="line"></span><br><span class="line">注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</span><br><span class="line"></span><br><span class="line">调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败</span><br></pre></td></tr></table></figure>

<h4 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h4><h5 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">有了Class实例，我们还可以获取它的父类的Class：</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行上述代码，可以看到，Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型。</span><br></pre></td></tr></table></figure>

<h5 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口：</span><br><span class="line"></span><br><span class="line">// reflection</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        for (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行上述代码可知，Integer实现的接口有：</span><br><span class="line"></span><br><span class="line">java.lang.Comparable</span><br><span class="line">java.lang.constant.Constable</span><br><span class="line">java.lang.constant.ConstantDesc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</span><br><span class="line"></span><br><span class="line">// reflection</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        for (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer的父类是Number，Number实现的接口是java.io.Serializable。</span><br><span class="line"></span><br><span class="line">此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()：</span><br><span class="line"></span><br><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个类没有实现任何interface，那么getInterfaces()返回空数组。</span><br></pre></td></tr></table></figure>

<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：</span><br><span class="line"></span><br><span class="line">Object n = Integer.valueOf(123);</span><br><span class="line">boolean isDouble = n instanceof Double; // false</span><br><span class="line">boolean isInteger = n instanceof Integer; // true</span><br><span class="line">boolean isNumber = n instanceof Number; // true</span><br><span class="line">boolean isSerializable = n instanceof java.io.Serializable; // true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom()：</span><br><span class="line"></span><br><span class="line">// Integer i = ?</span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer</span><br><span class="line">// Number n = ?</span><br><span class="line">Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number</span><br><span class="line">// Object o = ?</span><br><span class="line">Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object</span><br><span class="line">// Integer i = ?</span><br><span class="line">Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer</span><br></pre></td></tr></table></figure>

<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们来比较Java的class和interface的区别：</span><br><span class="line"></span><br><span class="line">可以实例化class（非abstract）；</span><br><span class="line">不能实例化interface。</span><br><span class="line">所有interface类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</span><br><span class="line"></span><br><span class="line">CharSequence cs = new StringBuilder();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？</span><br><span class="line"></span><br><span class="line">这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。</span><br><span class="line"></span><br><span class="line">什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">定义接口：</span><br><span class="line"></span><br><span class="line">public interface Hello &#123;</span><br><span class="line">    void morning(String name);</span><br><span class="line">&#125;</span><br><span class="line">编写实现类：</span><br><span class="line"></span><br><span class="line">public class HelloWorld implements Hello &#123;</span><br><span class="line">    public void morning(String name) &#123;</span><br><span class="line">        System.out.println(&quot;Good morning, &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建实例，转型为接口并调用：</span><br><span class="line"></span><br><span class="line">Hello hello = new HelloWorld();</span><br><span class="line">hello.morning(&quot;Bob&quot;);</span><br><span class="line">这种方式就是我们通常编写代码的方式。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</span><br><span class="line"></span><br><span class="line">一个最简单的动态代理实现如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在运行期动态创建一个interface实例的方法如下：</span><br><span class="line"></span><br><span class="line">定义一个InvocationHandler实例，它负责实现接口的方法调用；</span><br><span class="line">通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：</span><br><span class="line">使用的ClassLoader，通常就是接口类的ClassLoader；</span><br><span class="line">需要实现的接口数组，至少需要传入一个接口进去；</span><br><span class="line">用来处理接口方法调用的InvocationHandler实例。</span><br><span class="line">将返回的Object强制转型为接口。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</span><br><span class="line"></span><br><span class="line">public class HelloDynamicProxy implements Hello &#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    public HelloDynamicProxy(InvocationHandler handler) &#123;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    public void morning(String name) &#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           this,</span><br><span class="line">           Hello.class.getMethod(&quot;morning&quot;, String.class),</span><br><span class="line">           new Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 小韭菜学生类</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ordinaryStudents</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrdinaryStudents</span>();</span><br><span class="line">        ordinaryStudents.eat();</span><br><span class="line">        ordinaryStudents.write();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在有一位特殊的学生，他是区长的儿子，我们自然要对他额外照顾，要给他加一下功能。</span></span><br><span class="line">        <span class="comment">// 一种思路是定义一个类：区长的儿子类，他继承自学生类，但世上儿子千千万，有区长的儿子，也有市长的儿子，更有省长的儿子，不能把他们挨个定义出来，</span></span><br><span class="line">        <span class="comment">// 现在就可以使用动态代理机制，动态的给区长的儿子加上功能，以后碰到市长、省长的儿子也同样处理。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// InvocationHandler作用就是，当代理对象的原本方法被调用的时候，会重定向到一个方法，</span></span><br><span class="line">        <span class="comment">// 这个方法就是InvocationHandler里面定义的内容，同时会替代原本方法的结果返回。</span></span><br><span class="line">        <span class="comment">// InvocationHandler接收三个参数：proxy，代理后的实例对象。 method，对象被调用方法。args，调用时的参数。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, handlerArgs) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 从定义eat方法。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;eat&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我可以吃香喝辣！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从定义write方法。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;write&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我的作文题目是《我的区长父亲》。&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用普通学生类的write方法，流程还是要走的，还是要交一篇作文上去，不能太明目张胆。</span></span><br><span class="line">                method.invoke(ordinaryStudents, handlerArgs);</span><br><span class="line">                System.out.println(<span class="string">&quot;我的作文拿了区作文竞赛一等奖！so easy!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 对这个实例对象代理生成一个代理对象。</span></span><br><span class="line">        <span class="comment">// 被代理后生成的对象，是通过People接口的字节码增强方式创建的类而构造出来的。它是一个临时构造的实现类的对象。</span></span><br><span class="line">        <span class="comment">// loder和interfaces基本就是决定了这个类到底是个怎么样的类。而h是InvocationHandler，决定了这个代理类到底是多了什么功能.</span></span><br><span class="line">        <span class="comment">// 通过这些接口和类加载器，拿到这个代理类class。然后通过反射的技术复制拿到代理类的构造函数，</span></span><br><span class="line">        <span class="comment">// 最后通过这个构造函数new个一对象出来，同时用InvocationHandler绑定这个对象。</span></span><br><span class="line">        <span class="comment">// 最终实现可以在运行的时候才切入改变类的方法，而不需要预先定义它。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">sonOfDistrict</span> <span class="operator">=</span> (Student) Proxy.newProxyInstance(ordinaryStudents.getClass().getClassLoader(), ordinaryStudents.getClass().getInterfaces(), handler);</span><br><span class="line">        sonOfDistrict.eat();</span><br><span class="line">        sonOfDistrict.write();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生接口，能跑，能吃，能写作文。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小韭菜，能跑，能吃，能写作文。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrdinaryStudents</span> <span class="keyword">implements</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在吃饭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在跑步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在写作文!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解-廖雪峰"><a href="#注解-廖雪峰" class="headerlink" title="注解(廖雪峰)"></a>注解(廖雪峰)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</span><br><span class="line"></span><br><span class="line">// this is a component:</span><br><span class="line">@Resource(&quot;hello&quot;)</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    int n;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void hello(@Param String name) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</span><br></pre></td></tr></table></figure>

<h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><h5 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</span><br><span class="line"></span><br><span class="line">Java的注解可以分为三类：</span><br><span class="line"></span><br><span class="line">第一类是由编译器使用的注解，例如：</span><br><span class="line"></span><br><span class="line">@Override：让编译器检查该方法是否正确地实现了覆写；</span><br><span class="line">@SuppressWarnings：告诉编译器忽略此处代码产生的警告。</span><br><span class="line">这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</span><br><span class="line"></span><br><span class="line">第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</span><br><span class="line"></span><br><span class="line">第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</span><br></pre></td></tr></table></figure>

<h5 id="注解的参数"><a href="#注解的参数" class="headerlink" title="注解的参数"></a>注解的参数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义一个注解时，还可以定义配置参数。配置参数可以包括：</span><br><span class="line"></span><br><span class="line">所有基本类型；</span><br><span class="line">String；</span><br><span class="line">枚举类型；</span><br><span class="line">基本类型、String、Class以及枚举的数组。</span><br><span class="line">因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</span><br><span class="line"></span><br><span class="line">注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</span><br><span class="line"></span><br><span class="line">此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</span><br><span class="line"></span><br><span class="line">如果只写注解，相当于全部使用默认值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">举个栗子，对以下代码：</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    @Check(min=0, max=100, value=55)</span><br><span class="line">    public int n;</span><br><span class="line"></span><br><span class="line">    @Check(value=99)</span><br><span class="line">    public int p;</span><br><span class="line"></span><br><span class="line">    @Check(99) // @Check(value=99)</span><br><span class="line">    public int x;</span><br><span class="line"></span><br><span class="line">    @Check</span><br><span class="line">    public int y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。</span><br></pre></td></tr></table></figure>

<h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java语言使用@interface语法来定义注解（Annotation），它的格式如下：</span><br><span class="line"></span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</span><br></pre></td></tr></table></figure>

<h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</span><br></pre></td></tr></table></figure>

<h6 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：</span><br><span class="line"></span><br><span class="line">类或接口：ElementType.TYPE；</span><br><span class="line">字段：ElementType.FIELD；</span><br><span class="line">方法：ElementType.METHOD；</span><br><span class="line">构造方法：ElementType.CONSTRUCTOR；</span><br><span class="line">方法参数：ElementType.PARAMETER。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，定义注解@Report可用在方法上，我们必须添加一个</span><br><span class="line">@Target(ElementType.METHOD)：</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组&#123; ElementType.METHOD, ElementType.FIELD &#125;：</span><br><span class="line"></span><br><span class="line">@Target(&#123;</span><br><span class="line">    ElementType.METHOD,</span><br><span class="line">    ElementType.FIELD</span><br><span class="line">&#125;)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。</span><br></pre></td></tr></table></figure>

<h6 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">另一个重要的元注解@Retention定义了Annotation的生命周期：</span><br><span class="line"></span><br><span class="line">仅编译期：RetentionPolicy.SOURCE；</span><br><span class="line">仅class文件：RetentionPolicy.CLASS；</span><br><span class="line">运行期：RetentionPolicy.RUNTIME。</span><br><span class="line"></span><br><span class="line">如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。</span><br><span class="line"></span><br><span class="line">@Repeatable(Reports.class)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：</span><br><span class="line"></span><br><span class="line">@Report(type=1, level=&quot;debug&quot;)</span><br><span class="line">@Report(type=2, level=&quot;warning&quot;)</span><br><span class="line">public class Hello &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</span><br><span class="line"></span><br><span class="line">@Inherited</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在使用的时候，如果一个类用到了@Report：</span><br><span class="line"></span><br><span class="line">@Report(type=1)</span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">则它的子类默认也定义了该注解：</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="如何定义Annotation"><a href="#如何定义Annotation" class="headerlink" title="如何定义Annotation"></a>如何定义Annotation</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">我们总结一下定义Annotation的步骤：</span><br><span class="line"></span><br><span class="line">第一步，用@interface定义注解：</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二步，添加参数、默认值：</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</span><br><span class="line"></span><br><span class="line">第三步，用元注解配置注解：</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</span><br></pre></td></tr></table></figure>

<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</span><br><span class="line"></span><br><span class="line">SOURCE类型的注解在编译期就被丢掉了；</span><br><span class="line">CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；</span><br><span class="line">RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。</span><br><span class="line"></span><br><span class="line">如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">因此，我们只讨论如何读取RUNTIME类型的注解。</span><br><span class="line">因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。</span><br><span class="line"></span><br><span class="line">Java提供的使用反射API读取Annotation的方法包括：</span><br><span class="line">判断某个注解是否存在于Class、Field、Method或Constructor：</span><br><span class="line"></span><br><span class="line">Class.isAnnotationPresent(Class)</span><br><span class="line">Field.isAnnotationPresent(Class)</span><br><span class="line">Method.isAnnotationPresent(Class)</span><br><span class="line">Constructor.isAnnotationPresent(Class)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">// 判断@Report是否存在于Person类:</span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用反射API读取Annotation：</span><br><span class="line"></span><br><span class="line">Class.getAnnotation(Class)</span><br><span class="line">Field.getAnnotation(Class)</span><br><span class="line">Method.getAnnotation(Class)</span><br><span class="line">Constructor.getAnnotation(Class)</span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">// 获取Person定义的@Report注解:</span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line">int type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：</span><br><span class="line"></span><br><span class="line">Class cls = Person.class;</span><br><span class="line">if (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：</span><br><span class="line"></span><br><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line">if (report != null) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</span><br><span class="line"></span><br><span class="line">public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</span><br><span class="line"></span><br><span class="line">// 获取Method实例:</span><br><span class="line">Method m = ...</span><br><span class="line">// 获取所有参数的Annotation:</span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line">// 第一个参数（索引为0）的所有Annotation:</span><br><span class="line">Annotation[] annosOfName = annos[0];</span><br><span class="line">for (Annotation anno : annosOfName) &#123;</span><br><span class="line">    if (anno instanceof Range r) &#123; // @Range注解</span><br><span class="line">        r.max();</span><br><span class="line">    &#125;</span><br><span class="line">    if (anno instanceof NotNull n) &#123; // @NotNull注解</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用注解-1"><a href="#使用注解-1" class="headerlink" title="使用注解"></a>使用注解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</span><br><span class="line"></span><br><span class="line">我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface Range &#123;</span><br><span class="line">    int min() default 0;</span><br><span class="line">    int max() default 255;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在某个JavaBean中，我们可以使用该注解：</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    @Range(min=1, max=20)</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @Range(max=10)</span><br><span class="line">    public String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</span><br><span class="line"></span><br><span class="line">void check(Person person) throws IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    // 遍历所有Field:</span><br><span class="line">    for (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        // 获取Field定义的@Range:</span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        // 如果@Range存在:</span><br><span class="line">        if (range != null) &#123;</span><br><span class="line">            // 获取Field的值:</span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            // 如果值是String:</span><br><span class="line">            if (value instanceof String s) &#123;</span><br><span class="line">                // 判断值是否满足@Range的min/max:</span><br><span class="line">                if (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;Invalid field: &quot; + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">智汇君</div><div class="post-copyright__author_desc">路漫漫其修远兮，吾将上下而求索！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/01/17/博学谷-零基础大数据在线就业班-第一阶段 java基础/')">博学谷-零基础大数据在线就业班-第一阶段 java基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tech智汇站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>大数据<span class="tagsPageCount">26</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8%20Hive%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9%20%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大数据开发工程师-第九周 Hive扩展内容 常见数据压缩格式的使用</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/17/%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%20java%E5%9F%BA%E7%A1%80%202/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博学谷-零基础大数据在线就业班-第一阶段 java基础2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20spark%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 1</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%85%2017/" title="oracle数据库开发与应用 存储过程、函数和包 17"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 存储过程、函数和包 17</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%2016/" title="oracle数据库开发与应用 数据库编程 16"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 数据库编程 16</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%B8%B8%E6%A0%87%E5%92%8C%E5%BC%82%E5%B8%B8%2019/" title="oracle数据库开发与应用 游标和异常 19"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 游标和异常 19</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">智汇君</h1><div class="author-info__desc">路漫漫其修远兮，吾将上下而求索！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/contact/" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(/img/博客微信公众号图片.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%AD%A6%E8%B0%B7-%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%BA%BF%E5%B0%B1%E4%B8%9A%E7%8F%AD-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">博学谷-零基础大数据在线就业班-第一阶段 java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 java基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">环境搭建+入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">java语言背景介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">java语言跨平台原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JRE%E5%92%8CJDK"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">JRE和JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">JDK的下载和安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">常用DOS命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">PATH环境变量的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloWorld%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">HelloWorld案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Notepad%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">Notepad软件的安装和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.10.</span> <span class="toc-text">关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据类型及转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">变量介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">变量的定义和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">变量的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text">条件控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.6.</span> <span class="toc-text">随机数+开发工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.7.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8Edebug"><span class="toc-number">1.1.8.</span> <span class="toc-text">方法与debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.9.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.10.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 面向对象基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-API%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 API基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.3.1.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">常用构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-StringBuilder"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">public StringBuilder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-StringBuilder-String-str"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">public StringBuilder(String str)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">常用成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#append"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">append</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reverse"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#length"><span class="toc-number">1.3.1.2.3.</span> <span class="toc-text">length</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.3.1.2.4.</span> <span class="toc-text">toString</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">StringBuilder如何提高的效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">StringBuffer(廖雪峰)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">StringJoiner(廖雪峰)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">包装类型(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">处理无符号整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Auto-Boxing"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">Auto Boxing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%98%E7%B1%BB"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">不变类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">JavaBean(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaBean%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">JavaBean的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BEJavaBean%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">枚举JavaBean属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">枚举类(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enum"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">enum的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">enum类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#name"><span class="toc-number">1.3.6.3.1.</span> <span class="toc-text">name()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ordinal"><span class="toc-number">1.3.6.3.2.</span> <span class="toc-text">ordinal()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toString"><span class="toc-number">1.3.6.3.3.</span> <span class="toc-text">toString()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.7.</span> <span class="toc-text">记录类(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#record"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">record</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.8.</span> <span class="toc-text">常用工具类(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-number">1.3.8.1.1.</span> <span class="toc-text">绝对值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.3.8.1.2.</span> <span class="toc-text">最大或最小值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#xy%E6%AC%A1%E6%96%B9"><span class="toc-number">1.3.8.1.3.</span> <span class="toc-text">xy次方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%88%9Ax"><span class="toc-number">1.3.8.1.4.</span> <span class="toc-text">√x</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ex%E6%AC%A1%E6%96%B9"><span class="toc-number">1.3.8.1.5.</span> <span class="toc-text">ex次方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#e%E4%B8%BA%E5%BA%95%E7%9A%84%E5%AF%B9%E6%95%B0"><span class="toc-number">1.3.8.1.6.</span> <span class="toc-text">e为底的对数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A510%E4%B8%BA%E5%BA%95%E7%9A%84%E5%AF%B9%E6%95%B0"><span class="toc-number">1.3.8.1.7.</span> <span class="toc-text">以10为底的对数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.8.1.8.</span> <span class="toc-text">三角函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.8.1.9.</span> <span class="toc-text">数学常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">1.3.8.1.10.</span> <span class="toc-text">随机数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StrictMath"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">StrictMath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SecureRandom"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">SecureRandom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.9.</span> <span class="toc-text">异常处理(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">java的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.9.4.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NullPointerException"><span class="toc-number">1.3.9.5.</span> <span class="toc-text">NullPointerException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="toc-number">1.3.9.6.</span> <span class="toc-text">使用断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JDK-Logging"><span class="toc-number">1.3.9.7.</span> <span class="toc-text">使用JDK Logging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Commons-Logging"><span class="toc-number">1.3.9.8.</span> <span class="toc-text">使用Commons Logging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Log4j"><span class="toc-number">1.3.9.9.</span> <span class="toc-text">使用Log4j</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLF4J%E5%92%8CLogback"><span class="toc-number">1.3.9.10.</span> <span class="toc-text">SLF4J和Logback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.10.</span> <span class="toc-text">反射(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.10.1.1.</span> <span class="toc-text">获取Class实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8Einstanceof%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.10.1.2.</span> <span class="toc-text">与instanceof比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Class%E5%AE%9E%E4%BE%8B%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.10.1.3.</span> <span class="toc-text">Class实例来创建对应类型的实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.10.1.4.</span> <span class="toc-text">动态加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">访问字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">1.3.10.2.1.</span> <span class="toc-text">获取字段值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">1.3.10.2.2.</span> <span class="toc-text">设置字段值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">调用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.3.10.3.1.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.3.2.</span> <span class="toc-text">调用静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%9D%9Epublic%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.3.3.</span> <span class="toc-text">调用非public方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.10.3.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.10.4.</span> <span class="toc-text">调用构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.10.5.</span> <span class="toc-text">获取继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84Class"><span class="toc-number">1.3.10.5.1.</span> <span class="toc-text">获取父类的Class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96interface"><span class="toc-number">1.3.10.5.2.</span> <span class="toc-text">获取interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.10.5.3.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.10.5.4.</span> <span class="toc-text">动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-%E5%BB%96%E9%9B%AA%E5%B3%B0"><span class="toc-number">1.3.11.</span> <span class="toc-text">注解(廖雪峰)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">使用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.11.1.1.</span> <span class="toc-text">注解的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.11.1.2.</span> <span class="toc-text">注解的参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.11.2.</span> <span class="toc-text">定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.11.2.1.</span> <span class="toc-text">元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Target"><span class="toc-number">1.3.11.2.1.1.</span> <span class="toc-text">@Target</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Retention"><span class="toc-number">1.3.11.2.1.2.</span> <span class="toc-text">@Retention</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Repeatable"><span class="toc-number">1.3.11.2.1.3.</span> <span class="toc-text">@Repeatable</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Inherited"><span class="toc-number">1.3.11.2.1.4.</span> <span class="toc-text">@Inherited</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89Annotation"><span class="toc-number">1.3.11.2.2.</span> <span class="toc-text">如何定义Annotation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.11.3.</span> <span class="toc-text">处理注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">1.3.11.3.1.</span> <span class="toc-text">使用注解</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/23/Geek%20Uninstaller%EF%BC%8C%E7%BB%BF%E8%89%B2%E5%85%8D%E5%AE%89%E8%A3%85%E8%BD%BB%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%8D%B8%E8%BD%BD%E5%B7%A5%E5%85%B7%EF%BC%81/" title="Geek Uninstaller，绿色免安装轻量的应用卸载工具！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Geek Uninstaller，绿色免安装轻量的应用卸载工具！"/></a><div class="content"><a class="title" href="/2025/01/23/Geek%20Uninstaller%EF%BC%8C%E7%BB%BF%E8%89%B2%E5%85%8D%E5%AE%89%E8%A3%85%E8%BD%BB%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%8D%B8%E8%BD%BD%E5%B7%A5%E5%85%B7%EF%BC%81/" title="Geek Uninstaller，绿色免安装轻量的应用卸载工具！">Geek Uninstaller，绿色免安装轻量的应用卸载工具！</a><time datetime="2025-01-23T14:05:38.000Z" title="发表于 2025-01-23 22:05:38">2025-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/%E6%8A%96%E9%9F%B3%E8%B0%B7%E6%AD%8Cplay%E7%89%88%EF%BC%8C%E7%9C%9F%E7%9A%84%E5%BE%88%E4%B8%9D%E6%BB%91%EF%BC%81/" title="抖音谷歌play版，真的很丝滑！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="抖音谷歌play版，真的很丝滑！"/></a><div class="content"><a class="title" href="/2025/01/22/%E6%8A%96%E9%9F%B3%E8%B0%B7%E6%AD%8Cplay%E7%89%88%EF%BC%8C%E7%9C%9F%E7%9A%84%E5%BE%88%E4%B8%9D%E6%BB%91%EF%BC%81/" title="抖音谷歌play版，真的很丝滑！">抖音谷歌play版，真的很丝滑！</a><time datetime="2025-01-22T04:43:48.000Z" title="发表于 2025-01-22 12:43:48">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/Quick%20Startup%EF%BC%8C%E5%BF%AB%E6%8D%B7%E5%A4%84%E7%90%86%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8A%A0%E5%BF%AB%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E9%80%9F%E5%BA%A6%EF%BC%81/" title="Quick Startup，快捷处理自启程序的工具，加快电脑开机速度！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Quick Startup，快捷处理自启程序的工具，加快电脑开机速度！"/></a><div class="content"><a class="title" href="/2025/01/22/Quick%20Startup%EF%BC%8C%E5%BF%AB%E6%8D%B7%E5%A4%84%E7%90%86%E8%87%AA%E5%90%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8A%A0%E5%BF%AB%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E9%80%9F%E5%BA%A6%EF%BC%81/" title="Quick Startup，快捷处理自启程序的工具，加快电脑开机速度！">Quick Startup，快捷处理自启程序的工具，加快电脑开机速度！</a><time datetime="2025-01-21T19:35:09.000Z" title="发表于 2025-01-22 03:35:09">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/%E5%BF%83%E7%BB%AA%E6%97%A5%E8%AE%B0/" title="心绪日记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="心绪日记"/></a><div class="content"><a class="title" href="/2025/01/22/%E5%BF%83%E7%BB%AA%E6%97%A5%E8%AE%B0/" title="心绪日记">心绪日记</a><time datetime="2025-01-21T16:49:22.000Z" title="发表于 2025-01-22 00:49:22">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/20/%E7%9B%90%E9%80%89%E6%95%85%E4%BA%8B%EF%BC%8C%E8%BF%99%E5%87%A0%E4%B8%AA%E7%BD%91%E7%AB%99%E8%B6%B3%E5%A4%9F%E4%BD%A0%E7%9C%8B%EF%BC%81/" title="盐选故事，这几个网站足够你看！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="盐选故事，这几个网站足够你看！"/></a><div class="content"><a class="title" href="/2025/01/20/%E7%9B%90%E9%80%89%E6%95%85%E4%BA%8B%EF%BC%8C%E8%BF%99%E5%87%A0%E4%B8%AA%E7%BD%91%E7%AB%99%E8%B6%B3%E5%A4%9F%E4%BD%A0%E7%9C%8B%EF%BC%81/" title="盐选故事，这几个网站足够你看！">盐选故事，这几个网站足够你看！</a><time datetime="2025-01-20T14:58:34.000Z" title="发表于 2025-01-20 22:58:34">2025-01-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="智汇君" target="_blank">智汇君</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">28</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI/" style="font-size: 0.88rem;">AI<sup>1</sup></a><a href="/tags/ChatGPT/" style="font-size: 0.88rem;">ChatGPT<sup>1</sup></a><a href="/tags/CloudFlare/" style="font-size: 0.88rem;">CloudFlare<sup>2</sup></a><a href="/tags/EScrcpy/" style="font-size: 0.88rem;">EScrcpy<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>4</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 0.88rem;">NodeJs<sup>1</sup></a><a href="/tags/PowerToys/" style="font-size: 0.88rem;">PowerToys<sup>1</sup></a><a href="/tags/US-KG/" style="font-size: 0.88rem;">US.KG<sup>1</sup></a><a href="/tags/Vip%E8%A7%86%E9%A2%91/" style="font-size: 0.88rem;">Vip视频<sup>1</sup></a><a href="/tags/seal/" style="font-size: 0.88rem;">seal<sup>1</sup></a><a href="/tags/yt-dlp/" style="font-size: 0.88rem;">yt-dlp<sup>1</sup></a><a href="/tags/%E4%BC%91%E7%9C%A0/" style="font-size: 0.88rem;">休眠<sup>1</sup></a><a href="/tags/%E5%85%8D%E8%B4%B9/" style="font-size: 0.88rem;">免费<sup>3</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 0.88rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8A%9F%E8%83%BD%E9%9B%86%E5%90%88%E8%BD%AF%E4%BB%B6/" style="font-size: 0.88rem;">功能集合软件<sup>1</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D/" style="font-size: 0.88rem;">域名<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D%E6%89%98%E7%AE%A1/" style="font-size: 0.88rem;">域名托管<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7/" style="font-size: 0.88rem;">域名申请<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>26</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">大模型<sup>1</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 0.88rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E5%AD%97/" style="font-size: 0.88rem;">实时语音转文字<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 0.88rem;">廖雪峰<sup>7</sup></a><a href="/tags/%E6%89%8B%E6%9C%BA%E6%8A%95%E5%B1%8F/" style="font-size: 0.88rem;">手机投屏<sup>1</sup></a><a href="/tags/%E6%B3%A8%E9%94%80/" style="font-size: 0.88rem;">注销<sup>1</sup></a><a href="/tags/%E7%94%B5%E9%87%8F%E6%98%BE%E7%A4%BA/" style="font-size: 0.88rem;">电量显示<sup>1</sup></a><a href="/tags/%E7%9D%A1%E7%9C%A0/" style="font-size: 0.88rem;">睡眠<sup>1</sup></a><a href="/tags/%E7%A3%81%E5%8A%9B/" style="font-size: 0.88rem;">磁力<sup>1</sup></a><a href="/tags/%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2/" style="font-size: 0.88rem;">磁力搜索<sup>1</sup></a><a href="/tags/%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/" style="font-size: 0.88rem;">蓝牙设备<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E8%BA%AB%E4%BB%BD%E7%94%9F%E6%88%90/" style="font-size: 0.88rem;">虚拟身份生成<sup>1</sup></a><a href="/tags/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/" style="font-size: 0.88rem;">视频解析<sup>1</sup></a><a href="/tags/%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E5%B9%95/" style="font-size: 0.88rem;">视频转字幕<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%87%8D%E5%90%AF/" style="font-size: 0.88rem;">重启<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>12</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BD%AC%E6%96%87%E5%AD%97/" style="font-size: 0.88rem;">音视频转文字<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("24/12/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 智汇君 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("24/12/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4792307_02gxbpyxcpwp.js?spm=a313x.manage_type_myprojects.i1.10.56323a81KZGFDE&amp;file=font_4792307_02gxbpyxcpwp.js# 阿里图标symbol 引用链接，主题会进行加载 symbol 引用"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>