<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>尚硅谷大数据技术之数据湖Hudi-2 | Tech智汇站</title><meta name="keywords" content="大数据"><meta name="author" content="智汇君"><meta name="copyright" content="智汇君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="尚硅谷大数据技术之数据湖Hudi-2"><meta name="application-name" content="尚硅谷大数据技术之数据湖Hudi-2"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="尚硅谷大数据技术之数据湖Hudi-2"><meta property="og:url" content="http://example.com/2025/01/17/Hudi 尚硅谷大数据技术之数据湖Hudi-2/index.html"><meta property="og:site_name" content="Tech智汇站"><meta property="og:description" content="尚硅谷大数据技术之数据湖Hudi-2核心概念基本概念时间轴TimeLine文件布局File Layout存储方式 12345接下来看一下hudi的文件布局啊，什么意思呢？也就是说hudi它在存储系统上面，它是怎么一个表现形式啊，说白了，比如说咱们用HDFS作为它的数据存储的话啊，它以什么样的格式，什"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta property="article:author" content="智汇君"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta name="description" content="尚硅谷大数据技术之数据湖Hudi-2核心概念基本概念时间轴TimeLine文件布局File Layout存储方式 12345接下来看一下hudi的文件布局啊，什么意思呢？也就是说hudi它在存储系统上面，它是怎么一个表现形式啊，说白了，比如说咱们用HDFS作为它的数据存储的话啊，它以什么样的格式，什"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-2/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 智汇君","link":"链接: ","source":"来源: Tech智汇站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Tech智汇站',
  title: '尚硅谷大数据技术之数据湖Hudi-2',
  postAI: '',
  pageFillDescription: '尚硅谷大数据技术之数据湖Hudi-2, 核心概念, 基本概念, 时间轴TimeLine, 文件布局File Layout, 存储方式, 文件管理, 索引, 原理, 索引选项, 全局索引与非全局索引, 索引选择策略, 对事实表的延迟更新, 对事件表的去重, 对维度表的随机更删, 表类型, COW表, MOR表, COW与MOR的对比, 查询类型(Query Types), Snapshot Queries, Incremental Queries, Read Optimized Queries, Read Optimized Queries是对Merge On Read表类型快照查询的优化, 不同表支持的查询类型尚硅谷大数据技术之数据湖核心概念基本概念时间轴文件布局存储方式接下来看一下的文件布局啊什么意思呢也就是说它在存储系统上面它是怎么一个表现形式啊说白了比如说咱们用作为它的数据存储的话啊它以什么样的格式什么样的目录来存储对应的数据还有原数据啊那其实这个这个地方我们可以类比为表的话它一张表对应是不是一个目录啊对吧那目录名就是表名那我们知道是不是可以有分区它在表明目录下面是不是还有分区目录那在分区目录当中存放的是不是就是数据文件这个是对不对啊那么也有点类似啊有点类似那一张表呢它也是体现为文件系统的一个目录啊也就是表的名字就是目录的名字那么在之后呢它同样有什么呢也有分区这个概念那这个分区跟有点类似啊它也是一个分区是一个目录一个分区是一个目录那在分区当中呢也包含了数据文件啊那么区别在于哪呢区别就在于来我用红色的标出来它在表的目录下面除了数据的这些分区目录之外啊它还有一个是原数据的目录里面存放了的一些原数据这张表的原数据啊表的原数据它是一个这么一个文件夹名称它这个文件夹在这个文件夹当中呢就有呃相关的一些原数据信息啊都在这里面啊所以大家可以看到呃如果是的话它的原数据是不是存放在数据库当中了默认是我们一般会改到像这种数据库是不是啊那么对于来讲呢它用的就是直接在文件存储器呃直接在文件系统上啊以目录以文件的方式来存储原数据啊这是一个第一个要注意的地方那第二个地方呢就是它的分区路径呃里面呢呃数据文件它跟不一样了啊它基本上只有两种啊第一种是什么呢列式存储的文件第二种呢是行式存储的文件他这个文件就是编码的啊前面我们也介绍了说它使用了开源的数据格式那其实这两种格式就很常见的啊行那可能简单这么一说大家应该都明白接下来给大家看一个呃实际的例子啊那这边我已经启动了我的的集群那大家看看我之前跑过的一个表就可以了啊现在大家应该还没跑啊但是大家先搂一眼吧这是我之前跑的呃随便找一张表那么大家看一下这个是我的路径而已那接下来这些是什么表明这是忽底表的表明了跟一样啊那我随便点一张表啊比如说好这个就是忽的表名路径在这个路径下面大家可以看到有什么一个这个就是所谓的原数据那后面这些呢是有我这张表是按照天来做一个分区的啊所以大家可以看到它的分区目录名啊就是某年某月某日那我们呃来点一下数据的分区来点进来之后大家可以看到目前我这张表啊有一个文件是什么点当然也会有什么啊当然我现在这张表还没有让它生成这个也就是其实没有执行一个啊这个后面再聊啊那正常的话还有的这么一个文件啊那除此之外大家看看是不是还有一个东西这个不是目录了你看它不是目录啊它是个文件啊每个分区它还有一个原数据文件来点一下啊我们看一下它里面很简单就是什么呢有一个说白了就是这个分区路径创建的时间时间戳啊它是一串数字是年月日分秒啊你看年月号啊这个是精确到毫秒是不是啊然后还有一个什么分区的深度也就是说你分区路径下还可以有啊其他分区就多级分区这种样子了现在我是一级分区所以它的深度只有什么啊好那这个点其实是数据文件你看我点一下你看在这边就能看到一些数据了啊这是数据啊阿波罗格式的行这个简单搂眼啊另外一个分区也一样啊接下来我们搂眼这个原数据目录啊点好点一下进来之后啊我先刷新一下那么大家在这里可以看到一些文件啊首先是一个点开头的啊它会自己会用的一些东西对吧像什么还有临时目录啊这些东西还有归档啊配置啊这些除此之外还有另外一些重要的东西是这个那前面是什么呢时间戳年月日分秒毫秒对吧精确到毫秒的大家注意我再强调一遍它的时间戳嗯并不是说按照距离年月号啊点距离多少个毫秒不是这个啊它直接就是年月日拼接在一起分秒拼接在一起好另外呢我们可以看到它后面都是什么我我们前面聊了里边啊其中的一种动作是不是叫增量提交对吧啊也就是说我其实使用的方式是增量提交另外呢还记得啊的组成吧啊我们看这个文件名就好前面这个是不是里面的一个什么呢是不是它发生的时时间嘛第二个什么什么这个是不是他的在后面这个是什么呢就是它的你看对吧当然还有一个是对吧那么有的人就有疑问了那为什么你看同一个时间同一个动作既有这个又有这个又有没后缀的呢那么大家注意看一下前面它们的大小分别是什么也就是说呃调度中还未开始的它是空的那就是没有嘛就不在这个状态嘛啊那正在执行中的也是那还有一个这个是完成的那说明它的状态就是已经完成的是这样啊它每一个它就是三种状态都对应一个文件啊都对应一个文件其他的也一样你看这个是不是有对吧那你再看这个这个是不是有个啊这个是不是有个这个是不是有个啊就大概的去搂眼就行那其他路径基本都是你现在看到的大部分是空的啊对吧还有另外的这个里面有一个啊一些具体的原数据确认好的原数据还还是一样啊有什么还有这个什么配置对吧这些嗯平时我们应该用不上你看像这个这是啊在哪里然后超时时间什么什么一堆东西你看参数名就能读得懂那临时路径呢是空的啊也是空的现在归档也是空的就看你有没有用上啊也没有用上啊刷新一下看一下户的配置啊好对吧这里就有一些护底生效的配置是什么样就这张表的一些配置啊行呃这个简单搂页就可以了这个是我们现在提到的文件布局也就是说它在文件系统上是怎么存储的啊要按照什么规则存储文件管理那么这个文件布局当中我们还要了解一个他对文件的一个管理因为我们知道前面也聊了一些特性它支持那个呃版本控制然后呢又可以去做一些对吧那这个时候就注意新版本跟老版本文件的一个问题了那我们先了解一个概念啊看这张图呃这个是一个分区路径啊大家注意啊外面这个大黑框表示的是某一个分区的护底表的某一个分区目录了在一个分区当中刚才带大家看的是不是有文件了啊其实也有可能有点文件是吧好那他还做了一件事他将这些跟封装成一个一个的也不是封装了啊就是划分为一个一个的文件组大家注意叫文件组那每一为什么叫呢因为它每一个组里面存储了多个文件片每一个文件片代表一个版本能理解吧啊比如说啊这是老版本就是现在目前最新的版本那我们看一下具体的说明呃将表组织成文件系统的目录对吧这个刚才看过了表名就是目录名啊分区也是个目录名表划分为多个分区对不对啊分区是包含该分区的一个文件夹类似于啊这前面这两点好理解在第三个啊每个分区中文件被组织成什么文件组另外有一个词大家记住由文件唯一标识什么意思呢啊我在一个分区路径下可能有多个文件组每一个文件组都有其对应的固定的每一个组有一个固定的文件啊记住这一点啊好那每个文件组里面包含可能有多个文件片叫对吧文件片啊每个文件片包含什么呢大家注意一个基本文件的这是列式存储多个日志文件的后缀啊这是多个啊那么正常来讲呃在一个基本文件就表示某一次提交或者合并后在那个时刻生成的一个所有的数据这不好理解是吧那后续再来聊啊也就是说正常的是有一个的文件的啊要么是提交之后要么是合并之后啊会生成的的文件呃那么如果是文件这是我们前面简单提到的是这种表里面啊它会有这种增量提交那就是这些日志文件就包含自生成基本文件以来对基本文件中的数据插入和更新那没没有这个是啊就写示拷贝这是里面的两种表啊回头我们后面会介绍啊先留个印象说白了文件片就是有有能理解吧是一个是多个啊另外一件事就是为什么会有多个文件片呢因为我们保存了多版本多版本的数据多版本并发控制啊那每一次操作它会合并这种点文件还有这种基本文件产生新的什么文件片哎大家注意这句话当我执行一次呢啊这些多个文件就会跟的进行一次合并生成一个大的新的文件啊那这样的话你看比如说他们那他们呃这个新生成的发可能文件是不是最最新最全的数据啊对吧啊这样就生成了一个新版本的一个一个数据文件另外有我们知道里面有一种操作叫清理对不对啊它就会清理不使用的或者旧的文件片对吧已回收因为可能我经过多次之后啊啊比如说我进行了十次那么这十次是不是会每一次都会对应一个新版本的数据文件生成是不是那时间越久这个越多的话你不可能所有的版本都存着是不是那肯定有个策略说哎我我满足什么规则的这些旧的版本文件片我要把它清理掉啊是有这么一个事儿好另外注意一个事啊那我们先来聊一下的文件的一些细节这个基本文件它在里面的的里面是记录了什么它里面用的是布隆过滤说白了就是有一个索引同学们啊有一个索引嗯他这样通过这个东西就能高效的去检测这个在不在啊只有不在的时候才去呃需要去扫描整个文件去消灭假阳性我们知道布隆过滤是不是有假阳性啊假阳性就是说布隆过滤这种实现方式我们只能百分百确定啊不存在但是如果不能过滤显示存在那是不是也有可能它不存在对吧有个假阳性率或者咱们直白大白话来讲就是有一个准确率的问题你说不在那就一定不在但是你说在那只能说可能在能理解这个意思吧因为你说在是有准确率的啊这个布隆过滤呃自个去了解吧它就有一个哈希函数还有多个哈希函数哎还有值啊怎么样去计算嗯呃总而言之这一段话什么意思呢也就是说呃这个里面它记录了每一条数据的一个唯一叫啊这个词大家稍微记一下啊会经常提到经常用到啊举个例子啊我有张表啊别管分不分区呢比如说我有数据啊这么三条数据吧啊那假那么这三条数据刚好就在一个文件里面啊啊就别说刚好就是在一个文件里面这个时候呢其实呃这个文件会记录一个索引那我们可以基于布隆来做这个索引的查找因为布隆布隆会快一点并且节省空间嘛效率高嘛是不是啊布隆过滤那这个时候呢哎比如说我现在要呃更新或者插入这个时候你是不是得嗯先判断一下相同的在不在这个是由咱们去呃可以由我们去指定的啊就是这个啊比如说这个我用第一列作为也就是说第一行的是第二行是啊有点像什么有点像关系型数据库里面那种组件这种概念能理解吧啊类似于组件这个概念啊有点类似啊我只是说类似好这个时候比如说我要插入一条的数据那这个时候他会呃判断一下这个有没有啊这个时候他请通过这个索引机制通过布隆的方式呃就能判断到哎我这个二是存在的那这个时候这条数据就可以单独去处理这条把它更新掉这也是实现呃行式还有部分列的的这种呃很重要的索引机制啊这个我在这里简单提一嘴啊简单提一嘴好再看下一点的也就是点这种后缀的是的编码对吧他通过积攒并且以为单位写出也就是说他并不是一条一条写的就想说这一点而已而是攒一批数据咱们去写一次那每一个呃一个文件一个日志快吧啊咱们叫快吧有一个魔法值大小上下文呃文本还有一个等信息用于数据读校验和过滤当然这些事不需要我们去关心啊这是他内部实现的一个机制对吧但是既然聊到就简单说一句那下面这张图就很明显了这是两种格式的文件一种是一种是那文件重要特性就是会做一个什么呃文件的原数据里面会有一个索引啊可以用布隆可以用其他的索引方式那就更复杂了对吧他记录了一堆东西好这个是文件布局好我们总结一下啊呃其实总结就是这张图还有上面这张图第一个呢就是我们在文件系统啊是以什么方式存储的一个表就是一个目录名对吧一个分区也是个目录名那跟呃表目录下除了分区目录还有一个原数据目录点呼顶啊就就这就完了呗啊那每个分区目录里面啊是数据文件要么是点要么是点啊就这两种就完事儿了呗啊再往下走呃就是这里要注意的一个多版本控制啊就是每个分区路径下面它是以文件组的方式来组织的啊有多个文件组每个文件组有一个唯一的啊记住这一点啊那每个文件组里面可能有多个文件片每一个文件片包含了一个多个啊具体有几个不一定当你进行合并啊或者先提交啊啊生成一个新的版本啊那最新最全的数据就在新版本里面嘛啊那老的版本也是个文件片新的版本也是一个文件片啊另外呢有一个清理清理器对应的清理策略会去清理旧的老的文件片啊这就完事了嘛索引原理那刚才也聊到了一个关于索引对吧那现在咱我们就来好好聊聊这个索引的一个东西那一开始也介绍了啊通过索引机制提供高效的那接下来问题就来我是怎么来高效的啊其实前面也简单讲过了啊它具体是给定一个东西叫对吧一个那它是由什么组成呢一个叫记录键对吧就代表你数据的一条一条的记录就叫啊然后加上什么呢分区路径大家注意这两个东西组起来叫它与文件那么刚才聊到了文件是什么一个文件组有一个唯一的文件啊记住了好那也就跟文件建立了一个唯一的映射这种映射关系第一次写入文件后保持不变大家注意第一次写入文件后保持不变这句话什么意思也就是说这就代表这个映射关系是固定的是唯一的啊就这个意思啊所以呢一个文件组包含了一批数据的所有版本记录啊我这个前面也聊了对吧啊有点拗口但是我们具体解读就是什么呢一个文件组里面有多个文件片每一个文件片都是不同的是呃不同的版本对不不对啊另外这个索引可以用来干嘛用来区分消息是插入还是要更新是不是嗯如果你是我找得到也就是说我我新来的这条数据呃如果原先数据里边没有那我就是要做嘛那如果原先数据里面有了相同的那说明这条数据是要干嘛是要更新嘛啊就这个意思那索引是不是啊就很重要了啊所以就很重要那下面是官网给出的例子啊这个索引有什么用啊再进一步理解一下为了消除不必要的读写引入了索引有了索引之后更新的数据可以快速被定位到对应的因为我们前面也聊到了就是它这个索引是不是跟那个文件的绑定对吧直接看图吧白色的是基本文件也就是黄黄色是更数数据先别管什么了反正就是这是现现有的数据呃然后黄色是后面新过来的数据啊可能是插入可能是更新对吧那如果有了索引什么意思呢我们一共有几个份这个更新的数据每一个是兆啊那这个时候呢呃比如说你如果没有索引大家想一想比如说就看这个就好了这个兆的文件我怎么知道我要往哪一个方去更新呢你是不是所有的地方都得干嘛都得去扫描一遍是不是扫描一下你这样全量扫描扫描一下你的这些数据是该往哪里去写去往哪里更新效率特别低但是如果有了索引这兆是不是就知道哎他要更新的东西在哪哎就是这一百兆对吧另外这是另外的兆的更新数据他是不是就知道他对应的呃数据在这兆里面我举个例子啊这兆里面有那这兆里面就有一的更新二的更新对吧那这一百兆是那这这黄色的这个里面是五要更新对吧那你看嘛它要更新的是他是不是找到无所在的基本文件就行了他不用所有的基本文件都去扫一遍能理解这意思吧也就是说他知道他的目标在哪这样的话他我们的合并开销是多少啊啊你看这一边呢是呃加个这个是不对吧这是四个文件组嘛呃那这样的话我们合起来是不是开销就是乘以嘛对不对这个很好理解对不对这个是大家都知道你要的对象在哪里对吧目标很明确那你就开销少好另外一种没有缩音的时候这是原先来四个基本文件啊四个基本文件在这摆着啊有兆的数据然后呢有八次的更新每一次二十五兆那现在问题就来了这兆他知道要去找谁吗他不知道吧所以你这一百兆的是不是要每一个基本文件是不是都要跟所有的更新数据做一次匹配啊对不对那这个时候你看它开销是多少每兆就得跟这些兆有八个这边合起来是对吧他是不是要扫描兆的数据哎然后把属于自己更新的部分摘过来所以它的一次开销是多少加他自己嘛所有的增呃更新是嘛加起来是不是对吧好那下一个基本文件兆的数据它也一样它是不是也要在这兆里面找到属于自己的更新数据它的开销是不是也是兆好那这四个基本文件这么一下呢它的开销是多少兆那你看这个差距是不是差了一倍啊对吧这个就是索引的好处让你不会漫无目的那如果用生活中的例子来讲这就索引的作用是不是好这是它的一个原理啊索引选项那理解完索引的基本原理接下来我们聊聊细节了呃那是从索引的作用来讲那么接下来忽底它支持哪一些索引的类型说白了也就是索引的实现方案实现方式那么简单总结来讲可以分为四大类啊四大类第一类呢就是我们前面讲到了布隆索引它就是用了布隆过滤器来判断诶我对应的这一条数据在不在那这条数据怎么判断是不是有个啊那怎么判断这个在不在呢就是我们指定了一个数据键记录键还有分区路径跟文件建立一个唯一映射啊就判断这个文件组里面这条数据在不在呗啊那判断在不在布隆是很常用的一种啊它也是默认的配置啊那我们前面讲呢它的优点是什么效率高而且我不用依赖外部的系统数据与索引可以保持一致性缺点就是布隆这种过滤布容过滤这种算法它本身的一个假阳性的问题说白了就准确率也就是说你说在它还真不一定在因为你可能说错了啊因为他有一个哈希冲突的问题啊那是你说不在他就一定不在能理解我意思吧呃当然它正常来讲用它也够了啊也够了啊就是兼顾效率啊另外一个是简单索引简单索引呢它其实是将我们更新还有删除操作的这个新数据跟老数据进行那么大家看到这个就知道这个操作特别重了它实现起来就是思路上最简单但是它的缺点也超级明显性能太差你想想那如果数据一多了呢你这个那还得了啊对吧那那那那不行啊那还有一种叫索引那什么意思呢他也不是说实现什么算法而是什么呢将索引的这个数据存放在里那说明什么说明你的所有数据太多了啊太多了那我们在插入数据的时候我们是不是要插入分区下面的某一个文件组啊那这个时候你在插入的过程中呃福迪呢他会向发起这个请求读取请求就查一下这张索引表看一下呃这个数据在不在也就是说它的区别就在于索引的存储位置啊存储位置我直我直接将全量的索引都保存在你就现查呗就这个意思啊对于小批次的查询效率是比较高的这是它的优点但是缺点也特别明显什么明显呢你这是要借助外部系统那你增加了运维的压力再者说如果你用的不好或者说你配置的不对啊像什么内存啊啊还有它的线程啊各种东西你没配好也就是说你并没有用好这个时候它的上不去反而成为你的瓶颈对吧所以你用的前提是嗯你对比较了解啊你也知道怎么去让发挥出它应该有的性能好马配好鞍嘛能理解我意思吧再有一个是忽底后期版本就开始支持了那这个时候他因为前面这些是针对于而言的用户最早它就支持的一个引擎啊主要支持引擎那么后期版本才出了一个支持那这个时候依赖于呢它单独对于索引存储可以存在哪呢呃可以存储在那个算子的一个状态里面去啊可以存到的状态因为本身是呃有状态的计算嘛对吧它用了的状态作为底层的索引存储每个数据在写入之前都会计算目标的一个的啊它的优点呢就不同于布隆啊它避免了每次重复的文件的一个查找那缺点呢嗯缺点我觉得可能的缺点就是对于因为你你这个索引也是存在这个状态里的嘛那如果你的这个索引数据特别大那的状态是不是变得特别大那进一步是不是就会影响这个是吧另外一方面会影响咱们的资源使用当然你可以对进行大状态的调优你可以使用你可以开启增量检查点啊等等这些那就看你对熟不熟了是不是啊啊所以我这边注意写的一点啊只有一种是什么其他的是可选的配置啊所以你要注意你用的是什么啊这个是我们索引这个索引里面的可选的不同方案不同类型全局索引与非全局索引在的索引当中啊它又区分了全局索引还有非全局索引那所谓的全局索引呢就是整张表而言建立的索引也就是说即使你做了分区那么我是整个所有的分区一起来看那每一个啊也就是那个所谓的啊数据键它是唯一的不会有重复的即使你的数据是在不同的分区那我也不允许你有重复的这个键啊那这样就能够确保给定的一个键只有一个对应的记录整张表的范围内但是这也有一个很明显的缺点呢如果我这张表特别大那大的你受得了吗对吧那你随着你咱们表的数据量越来越大你去做一个更新删除操作的时候你这个性能就越差对吧因为你要全表的去匹配那这样的话即使你做了索引但这样效率也高不了所以这种全局索引呢更适合用于小表啊就是表的数据量并不大那其实用全局索引呃比较理想那第二类就是非全局所谓的非全局那它的范围是什么呢分区啊对它在一个分区里面能够保证这个的唯一性也就是说一个分区里面这个只能有一个那不同的分区那里相同我管不了对吧那它是依靠它写入器为同一条记录就是同一条数据它的更新也好你的删除也好都提供相同的一个分区路径因为你这条数据是固定的嘛呃或者说咱们前面不是讲了一个嘛啊那因为它默认的实现其实就是非全局的所谓的非全局是咱们的哎就是什么呢那个再拼接上一个什么呢对吧啊我的记录键在拼接上一个分区路径这样它不就唯一了吗对吧那这样的话呃你对相同一条数据的更新也好删除也好它都能定位到这条数据所在的分区那这样就可以大幅的提高一个效率那这样的话大即使是大表啊相对于全局索引来讲呃它的性能会更加的好一点这个非常好理解啊那从索引的维护成本跟写入性能考虑呃大家都知道这个全局索引难度更大啊性能更差如果你数据量大的话啊那么好既然聊完这个那我们再对比一下前面聊到的这几个索引类型在这当中哪一些可以设置全局的哪一些只能是局部的呢啊那么大家注意了对于这个索引来讲他就是全局索引啊它没有非全局啊它就只有一种全局索引那么对于布隆也好还有简单索引也好这两种索引类型你可以选择是全局索引或者是非全局索引这个可以通过参数来配置那当然我前面也提到这个主要应用于引擎是不是啊那具体的配置方式呢就是这样啊就是一个参数啊这个是一个全局跟非全局那如果数据量足够大那一般来讲还是用非全局所以会好一点啊这也是一个默认的啊大家注意这个是默认的这是一个索引选择策略对事实表的延迟更新那么接下来就是我们这么多个索引怎么来选择呢或者说什么样的场景更适合什么样的索引这个那么下面给到大家的是官方的一个资料啊这个描述也好这个动图也好都是官方做的那我们一起来看一下第一个场景是对事实表的延迟更新什么意思呢呃熟悉数仓建模理论呢我们都知道我们通常会去构建一些事实表还有维度表对吧那对应呢我们会去构造各种模型像什么新型模型雪花模型星座模型这是基于维度建模理论总而言之呢我们通常在数仓里面都会有一个事实表和维度表那事实表其实就是对应我们的业务过程那比如说你如果你是电商场景那你应该就有大量的交易比如说订单的数据支付的数据啊还有比如说像什么加购物车的数据这种都是属于咱们的事实数据那这一些呢我们通常首先会在数据库当中存储大量的这些事实的交易数据对吧那除了电商场景还有其他的像共享出行的什么行程表股票买卖记录表啊这都是不同业务场景下的一些事实表啊电商的订单表呃那事实表有个特点就是什么呢啊随着你的业务在不断的就用户在使用啊不断的操作不断的去执行一些业务过程那么你事实表的数据应该是一直在不断的增长就比如说订单好了你每天都有人下单那你这个订单的数据应该是越来越大越来越大啊另外呢这些事实数据还可能发生什么呢更新更新而且更新的话我们还要考虑一个事情它更新的数据大概呢是很久以前的还是说最近的呢那么大家可以想一想比如说电商的订单表就好了一笔订单的状态要发生改变对吧啊比如说咱们退单呢或者从下单变为支付状态啊或者再再到最后的呃签收状态等等这些看你业务怎么定义啊呃这些是不是针对于最近的这些订单才有可能啊比如说你距间隔了一个月以上那么你这个订单的信息是不是基本上不会再变了因为从业务上来讲商家也不会再允许你超过一个月再去说做一些退单或者说我下完单一个月不不付款一个月后再付款这种应该是不会出现对吧所以呢这种更新事实数据的更新应该是发生在什么较新的记录上也就是说它的更新数据分布是有特点的啊都是最近的那么对于比较老的一些数据呃它的更新就比较少了啊因为这一笔订单这笔交易早就关闭了啊不会再变更了啊嗯总而言之呢就这种场景大部分的更新会发生在最新的几个时间分区上而小部分呢在旧的分区啊那这个是官方画的一个图啊这是一个数据库啊的存储也可以啊那么这边呢是根据什么分区呢你看订单创建日期啊比如说咱们到呃年月日这样子好那更多的是在什么最近的这一段时间那更早之前的这些数据基本上很少做一个变更啊好了对于这样的这种场景我们适合用什么布隆索引因为它可以帮我们去裁剪因为它里面可以比如说范围裁剪我举个举个例子啊它可以通过对吧呃我取一个最小最小最大区间啊命中了那就在这个区间里面找就好了对吧我把小于最小的大于最大的直接就裁剪掉了好就简单举个例子啊那布隆过滤天生就是用来判断呃用来判断在与不在是吧非常高效那如果我们生成了这个也就是我们回头指定生成的这个啊大家注意咱们反复聊到键这个概念就是指的啊可以某种顺序排列也就是说它是有序的那这样的话他就能够更多的去筛选尽可能的筛选出来啊就将不必要那些更多的就过滤掉了那这样性能就更高了啊那会用所有文件的键域来构造区间数键域就是键的范围比如说从哪到哪啊键域啊构造一个区间数这样能够更高效啊总而言之言而总之这一段话就是什么呢适合用布隆布隆可以做一个呃区间裁剪啊更高效嗯那如果我们为了更加高效的使用布隆过滤器进行一个比对的话嗯这边缓存的什么输入记录也就是说做了什么事的缓存并且使用了自定义分区器和统计规律来解决什么数据的倾斜啊偏斜有时候你看这边说布隆过滤器的伪证率其实就是什么常说的假阳性率啊过高会增加数据的打乱操作啊那这个时候呢也就是说如果假阳性率特别高的话为什么假阳性率会高啊啊大家应该知道布隆它的准确率或者说误差率是不是呃通过一个公式可以算出来那这个公式是不是跟很多呃因素有关系第一数据集的大小也就是说你整个数据量有多少第个可能你给到了这个空间有多少还有呢你这个系数还有哈希函数的个数啊等等这些都有关系那么呃其中一点就是数据量对吧啊数据量越大那么你这个假阳性率的可能性是不是就越大那个公式忘了自己可以去研究一下啊那这个时候我们就希望呃布隆过滤器的一些参数啊一些一些变量能够动态的调整可以啊我们只需要什么设置这个参数就可以了你看啊布隆首先指定为布隆索引的过滤类型指定为动态的就可以指定位动态它可以根据咱们总的数据量来调整布隆相关的一些参数而从而达到我们希望的那个假阳性率啊对于叫假阳性会更好理解啊这能理解吧啊或者既然说到这儿我就简单给大家看一眼吧呃因为有的人可能还不太熟啊不太熟啊啊比如说布隆你搜一下过滤器呃我看一下有没有原理的介绍啊看一下分钟理解啊随便找一篇啊我只想找到它的公式原理我就不讲了啊原理不讲了这篇没有给我们那个数学公式啊啊随便点啊呃这个也算吧但我想找一篇更全的哎你看啊呃那我们看也就是说跟公式有关系啊看这一篇哎详解布隆过滤器的原理使用场景注意试一下我看一下这个的好那我们看一下啊也就是说这些公式大家自己看一看就行了它有我们的数据量啊其中一个参数数据量一个是值一个是值一个是的大小这一节能够计算出一个一个它的阳性率啊或者说那这个时候我们就希望呃布隆过滤器的一些参数啊一些一些变量能够动态的调整可以啊我们只需要什么设置这个参数就可以了你看啊布隆首先指定为布隆索引的过滤类型指定为动态的就可以指定为动态它可以根据咱们总的数据量来调整布隆相关的一些参数而从而达到我们希望的那个假阳性率啊或者既然说到这儿我就简单给大家看一眼吧呃因为有的人可能还不太熟啊不太熟啊啊比如说布隆你搜一下过滤器呃我看一下有没有原理的介绍啊看一下分钟理解啊随便找一篇啊我只想找到它的公式原理我就不讲了啊原理不讲了这篇没有给我们那个数学公式啊啊随便点啊呃这个也算吧但我想找一篇更全的哎你看啊呃那我们看也就是说跟公式有关系啊看这一篇哎详解布隆过滤器的原理使用场景注意事项我看一下这个的好那我们看一下啊也就是说这些公式大家自己看一看就行了它有我们的数据量啊其中一个参数数据量一个是值一个是值一个是的大小这一节能够计算出一个一个它的阳性率啊或者说准确率或者也可以算为什么误报率这是第一个场景事实表啊总结起来是什么事实表这种场景呃更新主要集中在最近的日期那么我们用布隆就可以了对事件表的去重好第二种场景是对于事件表的去重大家注意是事件啊不是事实事件是什么呢比如说前端买点产生的这些呃事件流比如说呃点击流用户的点击买点产生的数据还有咱们物联网比如说车联网一些传感器产生的这个数据啊我们通常称为事件流嘛对吧还有广告点击这些啊广告曝光好那么这一些呢我们通常会将这个数据先采集进对吧这种消息队列那么而且这种的数据量一般呢是咱们业务数据库当中呃到倍也就是说事件事件的数据往往是大于事实的数据对吧也就是说数据库里的数据跟我埋点产生的数据哪个更多呢一般来讲是买点还有传感器产生的这种啊会更多一点而且他有一个特点他要不要更新呢这种事件的数据一般而言都是追加啊不存在更新大部分而言啊那即使有更新那可能也是最近的几个那这个时候呃涉及到一个数据重放啊可能是一个采集的一致性这些问题可能有一个重复的问题那这个时候去重也是一个很常见的一个需求吧对吧这个大家做过的话应该都很熟悉啊不管你是什么业务场景那接下来呢就是咱们对于这个呃你想要低消耗的对大数据量进行去重这个还是说还是比较难度的啊要么你就是挺浪费资源那其实如果咱们可以用间值存储来实现去重啊或者说这个量比说白了就一句话量比较大怎么办那可以如果你对比较熟悉并且呢你们公司当中你们环境当中有人可以维护运维这个并且能调的用的比较好那你可以考虑一下用啊因为它在呃底层的索引当中它不是简单的将索引数据就存进去了它也利用了像这种特性啊做了很多很多的一个处理跟优化啊但是呢这个事件数据还是不断膨胀的一直在膨胀那即使您要去代价也是比较大不是说不行是代价比较大呃但这种时候呢有范围裁剪功能的布隆所以才是比较好的你又可以裁剪过滤那这个时候我们这个可以怎么做呢可以用事件时间加上呃标记这一条事件的一个来组成这个键就好了那这样有什么特点你看这个时间戳它是不是一个递增哎对吧那这样的话就是一直在增长的一个单调递增的一个键好总而言之呢如果是这种布隆也更合适啊那么我们大家看完两个场景都发现哎布隆更合适啊所以其实布隆就是默认的默认就是用了布隆啊对维度表的随机更删那么对维度表的随机更新和删除什么叫维度表啊像什么地区啊时间呢呃渠道啊对吧这一些就是我们所谓的维度比如说你电商场景是不是还有呃商品维度对吧是哪一个品类的啊等等这一些包括什么用户维度表对吧记录了用户信息的这些表啊用户维度信息也就是说你在建模的时候肯定要去构建一些维度表那维度表有个特点啊它的更新和删除我举个例子一张用户表啊比如说你有张用户表呃有有名用户啊用户一是去年创建的啊注册的啊用户二是今年呃上半年注册的用户三是现在注册的那这个时候呢呃很久以前注册的一他有没有可能更改信息啊很有可能吧他可以更改他的呃绑定邮箱更改他的绑定手机号可以更改昵称可以更改地址是不是都可以改对吧也就是说你并不是说你的更新都集中在最近这一段时间而是不一定啊所以我们叫随机啊随机好那这种场景的话你用来去裁剪就不合适了因为比如说我有这么一个呃这么一个范围吧我这个表示时间顺序好吧表示时间顺序如果你是裁剪的话应该是什么呢呃筛选出一段那在这一段里边再去匹配这样效率高那我现在维度表这种场景是哎我指不定在我不会集中在某一段进行那个更新和删除我可能在这里可能在这里那你就没法把我提前拆剪掉了那这样的话你用布隆的话就不能够得到一个很好的效益啊就性能可能就啊没有发挥不出来了也就是说这个是随机写入那我们的更新操作会触及表里大多数文件大多数分区对吧啊这时候布布隆就不太好使啊即使使用了范围比较也还是检查所有文件啊那这种场景怎么办呢呃简单来讲既然是可能所有文件都可能涉及到那你就用简单索引就好了啊就不要做呃不要做那些花里胡哨的招了啊不要给自己呃搬起石头砸自己的脚啊没必要啊他不因为呢简单索引他不会提前裁剪啊不提前裁剪而直接是将所有文件跟所需字段连接啊就是嘛我们前面聊聊过嘛对吧呃但是这种场景你也可以考虑啊因为是你只要是对能够拿得下能得住那样也是可以的而且对于这种随机读写也是很擅长的是不是好了另外呢有一个小事情啊小事情就是什么呢呃我们用全局索引的是时候啊有可能涉及到分区路径需要更新哎你可能不好理解对吧呃如果你是按照年月日这种日期来作为分区字段那一般这个分区产生就不会变了是吧比如说你是年月号这个分区那基本上这个分区值就不会变了但是如果你用的不是日期呢啊举个例子啊如果你是按照城市来分区的一张用户表对吧比如说哎北京这个城市是一个分区深圳是一个分区对吧那北京比如说有用户呃深圳这个分区里面有用户的信息啊你是这么来做了对吧那就有可能出现什么呢用户他离开了北京他去了深圳那这个时候是不是对于这条数据来讲它的分区值是不是变了它的分区信息是不是变了对吧那这个怎么办呢这个时候咱们可以开启这个参数或那分下面还有一个参数那其实这两个分别对应的一个是用了布隆另外一个用的是简单索引啊你用的什么索引你就设置哪个参数啊那这个时候用的表会更好啊当然这个表后面再来聊啊下面就会聊到啊这是一个小事情啊就是分区路径会更新的这种特殊场景啊可以开启参数好了综上所述啊我们简单聊下来就是什么呢大部分场景事实表事件表事件流都可以用布隆就好了另外呢如果得住那就用第呃第二点呢如果是随机的更新这种场景那就是用简单索引啊或者用好了这都是一个取舍没有说谁绝对好谁绝对差啊也就是说更新频率更新的范围比较集中用够更好呃更新比较分散那就用简单索引或者好了就这样子表类型表前面聊了这么多概念那么接下来这个概念是大家必须要了解的就是表类型在当中它有两种表一种叫简单来讲就是写实拷贝另外一种表呢叫做叫读实合并啊那么大家记住啊这是物体特有的两种表类型那我们先来看第一种类型叫啊咱们简称啊那么它的特点是它的数据文件当中它只有一个基本的列文件列存的也就是这种所谓格式他没有点啊这个特点大家要记住啊因为点是增量提交的时候才有的啊这个时候没有那么对于每一个新批次的写入它都会创建相应的数据文件的新版本啊这句话大家好好品一下对于每一个新的批次也就是说我写入一批新的数据了那这个时候都会创建相应数据文件的新版本哎重点是什么新版本新的一个文件片也就是我举个例子啊原先在一张的表中它只有一个文件比如说啊它里面比如说存储了为一二三这么三条数据啊那现在呢我们要去追加写一个四跟五这么一批数据啊这条新的数据要写进来了那这个时候他会做什么呢呃他就会将原先老的也就原先的文件再加新增加的这些变更数据将他们合并起来然后呢就会变成一份新的啊这样子能理解这个意思吧这也是为什么叫写时拷贝拷贝的是什么呢拷贝的是原先的文件将原先文件都拷过来再将新增的部分及变化的部分合并进去再写入一个新的文件那新的文件它也是一个那这个时候呢对应我们前面聊到的一个概念叫什么呢文件片那这个一二三这个比如说它就是一个文件片啊比如说是一吧我们称之为一那么写示拷贝完啊合并完这个新的文件那可能我们就可以认为它是一个文件片它们都是在同一个文件组里面是吧嗯这也是为什么我们前面说到这个文件片可以理解为呃不同文件片是不同的数据版本好这简单理解啊呃新版本文件包含旧的文件记录集这个批次的记录那最新的这个文件片就是包含了全量最新的数据了好那下面看一个具体的例子啊其实大家基本理解了啊那当前呢是给到个有三个文件组那么目前呢他们的版本都是第一个版本啊第一个版本好那这个时候我们进行一个数据的写入新的写入那你看啊场景是这样在索引之后我们发现这些记录与啊文件组一文件组二匹配了也就是说什么呢啊我有一些数据是要属于更新操作的啊那这些数据对应的原先数据在文件组一和文件组二里面啊另另外呢有一些数据它是属于新的插入啊不是更新啊啊那个时候候我会将将的插入入写到一个新的文组组也就第四个组比如说啊好所以就变成下图这样子文件组一文件组二有些数据需要更新啊那这个时候他们就会对呃旧的呃一版本的数据还有更新的数据进行合并啊并且呢写入一个新的生成了一个版本那文件组同样的道理它也生成了一个版本新的文件片新的那文件组三呢没有变化啊那还有一些是新插入的数据啊就写入一个新的文件组文件组四好知道这个应该都好理解吧那基于这个大家就能想到了呃它是属于写入期间进行合并的也就是说我一批数据插入的啊我既要拷贝老的数据又要将老的数据将新写新过来的数据进行一个合并啊写入一个新的文件所以呢它写入的延迟相对会大一点但是是最早封底设计的一种呃表一种表它的优势就是它非常的简单另外有一个特点需要大家记入它并不需要进行大家注意啊如果是的表它并没有这个动作因为它每一次都写入的时候就进行合并合并成一个新的文件嘛啊所以呢它表就没有必要进行这种压缩合并操作啊也是用起来比较方便和简单好那么这个是我们对表的一个理解啊应该没什么难度表接下来我们看第二种类型的表也就是所谓的读实合并那么大家注意它包含什么样的文件呢第一它可能有文件大家注意我的描述啊可能有文件另外它一定会有一个基于行存的增量日志文件也就是格式的那么它具体的文件名呢就会看到点这么一个后缀啊这个我们前面也是简单给大家看过对吧有一些点好那为什么叫呢那是因为它的合并在读取端什么意思呢哎你看我现在是不是既有这个基本的列存文件另外呢还有每一次呃新增加的数据比如说插入或者更新的数据它这一批数据会记录在一个点文件对吧那再来一个新批次又这些数据又有插入有更新它可能又在一个新的点文件也就是说在这张表当中他是不是可能有又有多个那你读的时候该怎么读啊因为老的文件它里面可能包含了一些是过期的数据对吧啊比如说我们原先这里有一条这么一条数据然后后面我对它进行了呃更新那我是不是有一条数据比如说变成啊变成一啊这是更新后的数据那它过来它不会对原先文件进行处理而是什么呢将这一条更新的数据放在点文件对吧所以这个时候如果你只读这个那可能是不准的所以你要综合和点文件啊才能得到最新的结果这个表读的时候也好也好它都会一起在读的时候进行合并这也是为什么叫读时合并啊只有在我进行读取操作的时候我才会将跟进行一个合并好所以它的合并在读取端啊它而且呢它在写入的时候不会进行合并或者说创建新的数据文件对吧这个就区别于表它是写入的时候进行合并生成新的文件啊那不会也也就相当于说是反过来了当完成了标记索引之后呃对于具有要更新记录的现有数据文件是创建增量日志就我刚才说的文件啊那就像你看这一个文件组里面啊有也有那么大家要注意的一件事情是什么一定有的吗不一定如果我这张表呃是第一次有数据来大家注意听我描述啊这张表第一次有数据写入也就第一批数据来这个时候你没有文件第一批数据也是会追加到点文件里面去啊这个时候你就看不到回来就像我前面给大家看的时候是不是也只有一个点是吧啊当然呢后面它呃对于表有这个所谓的啊有不同的策略不同的条件当你满足这个合并的条件之后或者执行合并的时候就会将现有的和进行一个合并成一个新的文件啊这是会做的事儿啊读取端将实时合并基本文件也就是及各自的增量日志文件啊好了每次的读取延迟都比较高因为啊我们要查询时才进行一个合并操作另外就是我刚才提到的压缩机制也就是所谓的这个就是无论你读与否啊有没有就是即使你没有读这个如果触发的话它也是会进行啊文件的合并的啊它会将数据文件日志文件点合并在一起会创建新的那关于这个呢呃我们可以选择内联方式或者异步模式来运行而且他提供了不同的压缩策略那其中最常见的是基于什么提交的数量就像我刚才讲的我每经过三次提交每一次提交都会表每一次提交是不是都写入一个点文件了对吧啊比如说我有三次提交那就有三个点文件呃那这个时候我指定数量为三就那它就会触发自己的生成一个新的那么压缩完成之后读取端只要读取最新的数据文件而不用关心什么旧版的文件这样是不是呃这种机制是不是可以减轻咱们读实合并的一个性能问题对吧如果你从来不做那我每一次读都必然要跟旧版的跟新版的跟各种各多个文件进行一个线合命啊那效率就低低了啊所以这个也是很重要的一个事儿啊呃那下面一些细节呢就是什么呢表的写入行为根据索引会有一些区别啊如果我们用的是布隆索引它是无法对点这种文件生成索引的啊所以这个时候它会怎么做呢它会将插入的消息写入将更新的消息写入这个点大家注意这是针对布隆索引为什么呢因为它对这种啊不能生成索引那如果咱们用的是就是现象是不一样这个大家要明白如果用的是它是基于状态的索引那每次写入它都是的一个格式呃并且会不断的追加那这个时候它就不会说我的消息写入写入不是这样啊它统一都写入什么追加到好这个是一些区别啊那具体来讲就是回头咱们演示的时候啊啊如果咱们用引擎默认的布伦过滤就可以是这样子啊银色的跟对分开写那么如果是那就统一都写入到啊好这个就是表那么大家可以想一想对吧这两种表什么样的场景呃适合用什么表与的对比那接下来我们就来对比一下这两种表的优缺点啊区别在哪里啊那我们看一个从数据的延迟来讲谁更高啊更高一点啊的表反而会更低一点啊数据的延迟那么查询的延迟呢就是我查这张表啊需要多久时间为什么呀因为我要查的时候它是不是他是在写入的时候就进行合并了我查的时候它是不已经合并完了啊简单来理解是这样所以我查的时候是不是延迟更低一点是吧呃那么对于来讲你的查询延迟就高了因为你是读取查询的时候才进行一个合并啊那你肯定就相比要慢一点了啊啊对啊好行另外一个是更新的成本成本啊我要对表的数据进行一个更新谁的成本更高呢呃对于来讲它更高因为我们知道每一批数据来它是不是要把旧的拍回来跟新的数据进行一个合并写入一个新文件那如果呃我有一张表有一个盘毁的文件吧比如说这里有一万行数据那现在我对其中的某新来的数据是对某一行数据比如说为三的进行更新那这个时候他是不是同样得拷贝原先的一万条数据并且将新的数据跟老数据合并再写入一个新文件这个代价是不是有点大啊能理解这个意思吧啊这个代价就大了啊另外一个呢就是咱们的这个表他代价比较低为什么他不会动原先的对吧先不考虑这个呃我不会动我只会将新来的这些数据插入也好更新也好我都追加到那个点文件回头等或者等你查询的时候我先合并啊好行文件的大小呃它的是更小更低但是它更新的成本更高文件会更大一点啊但是它更新成本比较低写放大啊那不用讲它肯定是一个写放大的一个问题对吧我写的时候哎我要拷贝旧数据啊这代价就比较重了那么表呢它写会不会放大呢就呃相对来讲是低一点当然说了这么多大家应该有一个初步的印象但是理解不会很深入吧那咱们来个大白话啊比较适合什么批还有流计算这两种场景来考虑是不是更适合于批呀因为我们知道它有一个什么写放大的问题如果我原先的文件有一假设啊有一亿行当然不会这么做啊我们不会让它那么大有一亿行现在呃我来的数据这个批次只有一条是更新的数据那你是不是要拷贝原先一亿行更新的这一条进行合并代价有点重吧但是如果我来的是一批数据这里面包含了比如说万条那也就是说我做这么一次啊那还行对吧比你一条一条的去啊效率会更好一点所以呃建议就是表呢咱们还是用在批处理的一个场景会更好一点那表呢就是呃批也好流也好其实也都行但是如果是流式场景咱们更推荐表因为你想想什么叫流啊流处理啊流处理是不是数据源源不断的来是吧那如果不做处理咱们是不是数据是一条一条来的呀一条一条写入啊对不对那也就是说他写入会特别特别的频繁比如处理写入很频繁每次量又很小你用的话这个写放大问题就很严重特别严重啊没必要所以如果是流失场景特别是你用去同步一些数据过来呃咱们还是推荐用表当然不绝对啊不绝对啊如果你对虽然是流处理但是你做了一个展批的处理那其实也还行啊好这个是咱们啊主要一个对比啊心中有数啊也就是说偏向于或者呃只要有涨批吧不管是批处理还是流处理有涨批的这种更好一点呃呢更适合流式的写入啊流式的写入好这个取舍呢各大企业就一些大厂他们在用的时候啊呃流式场景也有用的也有用的啊就是说嗯你看吧这是我的一呃一些建议查询类型呢提供了三种不同的查询类型我们一起来了解一下第一种呢是快照查询什么叫快照呢简单来解就大家记住就是四个字叫全量最新哎我就要查询当前呃数据最新的一个状态全量最新就记住这四个字就行了这就是快照查询那区别于两种表类型有什么特点呢表你就是直接查询最新版本的文件就可以了这个好理解吧因为最新的这个文件肯定是全量最新对不对啊那表就不一样了呃表需要做一个什么呃就是说即使要去合并读的时候要去合并合并什么呢最新的文件片里面当中的基本文件也就是呃还有呢一些点里面的增量数据增量文件它会将他们合读取的时候进行合并合并的时候展示给你啊所以呢呃提供一个近实时的表因为它合并还需要一些延迟嘛是吧所以表你去查询的时候有一个读取延迟啊就在因为它作为一个现合并啊行这个是快照查询下面这张图简单搂一眼啊快照查询这什么意思呢呃大家注意看这边有四个什么呢文件组这是啊它这个字体可能容易看错啊这是然后这是表示四个文件组啊另外呢就是呃这个是表为例啊那我们看啊他在十点钟的时候啊用这个淡蓝色表示进行了一次那这个时候可能插入的呃只有两个文件组文件组一还有文件组你看他们有蓝色的对吧好再之后呢在绿色的这个时刻也就点分呃他又有一批新的数据了那这个时候呢可能涉及到什么呃文件组一文件组二里面数据的更新还有呢一批数据的插入啊也就是文件组三了啊所以大家可以看到一二呢这里有更新然后三呢是新插入好那么粉色的这个就点分的时候再一次一批数据这个时候可能涉及到文件组一文件组的更新对吧啊所以呢啊一二又更新了然后呢又有一批数据新的插入啊在文件组哎在所以呢这个是一个不是一个动图啊所以大家会看那完事之后呢我们可以看到你在点分的时候去查询它的全量最新快照是什么你看在分的时候你进行一个快照查询全量最新是什么是不是文件组二三里面的这三个文件呢对吧啊所以你看有文件组二三里面呢他们的版本都是分的时候这个时候文件组四还没有生成呢还没有呢能理解这个意思吧呃另外呢在我们点分之后这个时候你再去做一个快照查询询能达到什个效果呢呃首先文件组一文件组二是不是都有一个最新的文件是吧一二里都能查到那四呢也是在分的时候新插入的新生成的也能看到关键就在于三呢对于三来讲你可能觉得哎分的跟他没关系是吧虽然你没有数据的变更怎么样呢没无所谓但你现在是最新状态是什么你也展示出来呗啊所以你这里能看到什么呢文件组三它的版本还是停留在点分因为这就是它的最新版本了能理解这个意思吧这就是这张图的意思啊慢慢去解读看增量查询它可以查询给定的提交或者增量提交这个提交就对应咱们那个表的方式啊就是对应表的这种方式啊呃给定了这个某一次以来新写入的数据对吧就比如说刚才这个例子如果现在时间已经到了经过了点分的呃你可以怎么样呢你可以指定说哎我从点分之后或者从十点钟之后以来先提交而不用去查询这个之前的一些数据的啊这个时候我们而且还可以开启一个变更流啊变更流来启用增量的数据管道还记得咱们前面聊到护底的一个使用场景是不是有一个增量管道啊对吧那也可以依赖于它的增量查询啊说白了就是过滤一个某个之后新写入的数据啊其他就不要也就是说它不是全量最新啊不是全量执新而是指定之后新增加的这一部分数据还有一个叫读优化查询大家看描述的话是还有的最新快照有的人就有疑问了那这个跟快照查询不就一样吗哎大家注意咱们这边描述可不一样普通的对应的是表啊所以对于表来讲快照查询跟读优化是一样的但是对于表来讲就不一样这个这个也好都是对于而言的对不对读式合并那呃就是增量提交那我们知道呃增量提交完然后你再去查这个快照查询一定是全量最新但是就不一定了因为每次之后它是不是将老的跟多个进行一个合并生成一个新的什么新的是吧那这个新生成的这个一定是全量最新吗不一定啊为什么呢我可能在之后又进行了好几次的增量提交又多了好几个文件能理解吧如果是读优化视图它的区别在哪它只会查询最新之后的这个文件也就是说在这一次后面的这一些点它查不到了啊所以对于来讲它并不是全量最新能理解吧好吧那看下一句话他仅将最新的文件片最新文件片嘛的什么呢列文件暴露给查询这就我刚才讲了如果是表我在某一次之后它是生成了一个新的但在这之后呢它又多次提交又有又有新的点写过来了这个时候你只查到你没有查到没有合并啊啊这个是要注意的地方这个是读优化啊是对表类型快照查询的优化好那下面有一个具体的对比啊下面这张图就是对于表而言它的快照查询与读优化的一个对比那么在呃从点分开始差不多每分钟进行了一次增量提交是吧那么在点分的时候触发了一次大家注意那触发之后有什么特点呢就是会生成一个新的文件哎那对应的是哪一个呢哎文件组一文件组文件组在点分的时候之后生成的基本列文件啊用绿色表示好那我们接着往下看在分的时候分别进行的都是什么增量提交增量提交每一次提交是不是生成一个点文件对吧啊所以你看对于文件组一来讲它包含了呃的点点点那对于文件组二呢它有的有的有的点对吧那对于文件组四三啊压缩之后他没有新的数据来文件组四一开始是没有的但是在分和分的时候都是呃插入的数据嘛相当于是对吧插入的新插入的数据好那这一块呢它就有一个点一个点能理解吧好那接下来就是什么呢呃我们在分的时候进行查询这个是什么读优化的方式你去查呃按照点分这个这一次为基准的话你能查到什么呢读优化视图咱们说了他只查文件也就是说绿色的这三个能查到所以你看是并且这是分的时候那文件组四的这几个点它就查不到了查不到那如果是快照查询它所有的都能查到啊因为它是全量最新能理解吧这个图想表达的就是这么一个意思好那这个读优化视图是专门针对表的一个快照查询的优化为什么要这么做呀刚才也讲了我读的不一定是全量最新那既然如此还要他干嘛啊其实就是为了查询效率你想想如果我是都是快照查询表每一次查询我都要进行一个读时合并代价还是有点重的我的读取延迟还是比较大的那如果这个时候我能接受呃稍微的滞后也就是说即使不是全量最新那也是相对来讲比较新的吧退而求其次嘛但是我的效率能有一个质的提升啊主要的目的在这里啊那你看呃数据延迟呢是比较低啊那读优化呢是比较高查询延迟呢快照比较高因为它要现合并啊那读优化呢比较低它直接读啊他不读好所谓的数据延迟这里怎么理解呢也就是说我现在点分的数据已经写入了对吧比如说就就刚才这个地方呃点分一次提交啊往文件组写入了点文件但是我却查不到我现在分钟去查我查不到那不就是有延迟吗我可能在等下一次这一些数据才可见对吧下一次之后这些呃合并之后这里才可见啊这个就是所谓的数据延迟嘛啊不是立马就能查到嘛不同表支持的查询类型那么看看不同的表支持的查询类型啊其实对于表来讲呢呃就简单的两种一个是全量最新的快照还有增量两种查询对于表就除了这两个多了一个读优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-03 23:19:54',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Tech智汇站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 1.05rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 1.05rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 1.05rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 1.05rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>31</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 1.05rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 1.05rem;">廖雪峰<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>10</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">93</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/" itemprop="url">尚硅谷大数据技术之数据湖Hudi</a></span></div></div><h1 class="post-title" itemprop="name headline">尚硅谷大数据技术之数据湖Hudi-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-2/"><header><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/" itemprop="url">尚硅谷大数据技术之数据湖Hudi</a><h1 id="CrawlerTitle" itemprop="name headline">尚硅谷大数据技术之数据湖Hudi-2</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">智汇君</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="undefined 2025-01-17 17:35:02">2025-01-17</time></header><h1 id="尚硅谷大数据技术之数据湖Hudi-2"><a href="#尚硅谷大数据技术之数据湖Hudi-2" class="headerlink" title="尚硅谷大数据技术之数据湖Hudi-2"></a>尚硅谷大数据技术之数据湖Hudi-2</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="时间轴TimeLine"><a href="#时间轴TimeLine" class="headerlink" title="时间轴TimeLine"></a>时间轴TimeLine</h4><h4 id="文件布局File-Layout"><a href="#文件布局File-Layout" class="headerlink" title="文件布局File Layout"></a>文件布局File Layout</h4><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081434196.png" alt="image-20240308143428151"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接下来看一下hudi的文件布局啊，什么意思呢？也就是说hudi它在存储系统上面，它是怎么一个表现形式啊，说白了，比如说咱们用HDFS作为它的数据存储的话啊，它以什么样的格式，什么样的目录来存储对应的数据，还有原数据啊，那其实这个这个地方我们可以类比为hive表。Hive的话，它一张表对应HDFS是不是一个目录啊，对吧？那目录名就是表名，那我们知道hive是不是可以有分区，它在表明目录下面是不是还有分区目录，那在分区目录当中存放的是不是就是数据文件，这个是hive对不对啊</span><br><span class="line"></span><br><span class="line">那么hudi也有点类似啊，有点类似，那hudi一张表呢，它也是体现为文件系统的一个目录啊，也就是表的名字就是目录的名字，那么在之后呢，它同样有什么呢？也有分区这个概念，那这个分区跟hive有点类似啊，它也是一个分区，是一个目录，一个分区是一个目录。那在分区当中呢，也包含了数据文件啊，那么区别在于哪呢？区别就在于来，我用红色的标出来，它在表的目录下面，除了数据的这些分区目录之外啊，它还有一个是原数据的目录，里面存放了hudi的一些原数据，这张表的原数据啊，表的原数据它是一个.hoodie这么一个文件夹名称，它这个文件夹在这个文件夹当中呢，就有呃，Timeline instant相关的一些原数据信息啊，都在这里面。</span><br><span class="line"></span><br><span class="line">啊，所以大家可以看到，呃，如果是hive的话，它的原数据是不是存放在数据库当中了，默认是derby，我们一般会改到像MYSQL这种数据库是不是啊，那么对于hudi来讲呢，它用的就是直接在文件存储器，呃，直接在文件系统上啊，以目录，以文件的方式来存储原数据啊，这是一个。第一个要注意的地方，那第二个地方呢，就是它的分区路径，呃里面呢，呃，数据文件它跟hive不一样了啊，它基本上只有两种啊，第一种是什么呢？列式存储的parquet文件，第二种呢，是行式存储的log文件，他这个log文件就是avro编码的啊，前面我们也介绍了hudi说它使用了开源的数据格式，那其实这两种格式就很常见的啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081440789.png" alt="image-20240308144030533"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">行，那可能简单这么一说大家应该都明白，接下来给大家看一个呃，实际的例子啊，那这边我已经启动了我的hudi的集群，那大家看看我之前跑过的一个hudi表就可以了啊，现在大家应该还没跑啊，但是大家先搂一眼吧，这是我之前跑的，呃，随便找一张表，那么大家看一下这个是我的路径而已。那接下来这些是什么表明，这是忽底表的表明了，跟hive一样啊，那我随便点一张表啊，比如说OdS_log,好，这个就是忽hudi的表名路径，在这个路径下面大家可以看到有什么一个.hoodie，这个就是所谓的原数据，那后面这些呢，是有我这张表是按照天来做一个分区的啊，所以大家可以看到它的分区目录名啊，就是某年某月某日，那我们呃，来点一下数据的分区来点。</span><br><span class="line"></span><br><span class="line">进来之后，大家可以看到目前我这张表啊，有一个文件是什么点log。当然也会有什么.parquet啊，当然我现在这张表还没有让它生成这个.parquet，也就是其实没有执行一个compassion啊，这个后面再聊啊，那正常的话还有.parquet的这么一个文件啊</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081444759.png" alt="image-20240308144433324"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081445912.png" alt="image-20240308144512890"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那除此之外大家看看是不是还有一个东西，这个不是目录了，你看它不是目录啊，它是个文件啊，每个分区它还有一个原数据文件来点一下啊，我们看一下它里面很简单，就是什么呢？有一个commit time,说白了就是这个分区路径创建的时间，时间戳啊，它是一串数字，是年月日10分秒啊，你看2022年9月20号18:46:40 692ms啊，这个是精确到毫秒是不是啊，然后还有一个什么分区的深度，也就是说你分区路径下还可以有啊其他分区。就多级分区这种样子了，现在我是一级分区，所以它的深度只有什么1啊好，那这个点log其实是数据文件，你看我点一下你看。在这边就能看到一些数据了啊。这是数据啊，阿波罗格式的，行，这个简单搂眼啊，另外一个分区也一样啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081448306.png" alt="image-20240308144836780"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接下来我们搂眼这个原数据目录啊，点.hoodie。好点一下进来之后啊，我先刷新一下，那么大家在这里可以看到一些文件啊，首先是一个点开头的啊，它会自己会用的一些东西，对吧？像什么schema，还有临时目录temp啊这些东西，还有归档archieve啊，hudi配置啊这些</span><br><span class="line"></span><br><span class="line">除此之外还有另外一些重要的东西是这个，那前面是什么呢？时间戳年月日10分秒毫秒对吧，精确到毫秒的，大家注意，我再强调一遍，它的时间戳，嗯，并不是说按照距离1970年1月1号啊，0点00:00:00 0ms距离多少个毫秒，不是这个啊，它直接就是年月日拼接在一起，10分秒拼接在一起，好另外呢，我们可以看到它后面都是什么，deltacommit，我我们前面聊了instant里边啊，其中的一种动作是不是叫增量提交，对吧？啊，也就是说我其实使用的方式是增量提交，deltacommit，另外呢，还记得instant。啊的组成吧，啊，我们看这个文件名就好，前面这个是不是instant里面的一个什么呢？是不是它发生的时时间嘛，第二个什么什么commit，这个是不是他的action。在后面这个是什么呢？就是它的state，你看inflight， requested对吧，当然还有一个是completed对吧？</span><br><span class="line"></span><br><span class="line">那么有的人就有疑问了，那为什么你看同一个时间，同一个动作既有。这个又有这个又有没后缀的呢？那么大家注意看一下前面它们的大小分别是什么，也就是说，呃，调度中还未开始的requested，它是空的，那就是没有嘛，就不在这个状态嘛啊，那正在执行中的inflight也是0，那还有一个，这个是完成的，那说明它的状态就是已经完成的，是这样啊，它每一个action，它就是三种状态都对应一个文件啊，都对应一个文件，其他的也一样，你看。这个是不是有2对吧，那你再看这个，这个是不是有3个啊，这个是不是有3个，这个是不是有3个啊，就大概的去搂眼就行，那其他路径基本都是你现在看到的大部分是空的啊。对吧。还有另外的这个aux里面有一个ckp_Meta啊，一些具体的原数据，确认好的原数据。还还是一样啊，有什么complete,inflight。还有这个什么配置对吧。这些嗯，平时我们应该用不上，你看像这个，这是Rose DB pass啊在哪里，然后超时时间什么什么一堆东西，你看参数名就能读得懂。那临时路径呢，是空的啊，Skimer也是空的，现在archive归档也是空的，就看你有没有用上啊，也没有用上啊，刷新一下看一下户的配置啊。</span><br><span class="line">好。对吧，这里就。有一些护底生效的配置是什么样？就这张表的一些配置啊，行呃，这个简单搂页就可以了，这个是我们现在提到的文件布局，也就是说它在文件系统上是怎么存储的啊，要按照什么规则存储？</span><br></pre></td></tr></table></figure>

<h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081713737.png" alt="image-20240308171259464"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">那么这个文件布局当中，我们还要了解一个他对文件的一个管理。因为我们知道hudi前面也聊了一些特性，它支持那个呃版本控制，然后呢又可以去做一些compassion，对吧？那这个时候就注意新版本跟老版本文件的一个问题了。那我们先了解一个概念啊，看这张图呃，这个是一个分区路径啊，大家注意啊，外面这个大黑框表示的是某一个分区的护底表的某一个分区目录了。在一个分区当中，刚才带大家看的是不是有.log文件了啊，其实也有可能有点.parquet文件是吧？好，那他还做了一件事，他将这些parquet跟log封装成一个一个的，也不是封装了啊，就是划分为一个一个的文件组。大家注意叫文件组file group。那每一为什么叫group呢？因为它每一个组里面存储了多个文件片，每一个文件片代表一个版本，能理解吧？啊，比如说file slice1啊，这是老版本，file slice2就是现在目前最新的版本。</span><br><span class="line"></span><br><span class="line">那我们看一下具体的说明。呃，hudi将表组织成文件系统的目录，对吧？这个刚才看过了，表名就是目录名啊，分区也是个目录名，表划分为多个分区，对不对啊？分区是包含该分区的一个文件夹，类似于hive啊，这前面这两点好理解。在第三个啊，每个分区中文件被组织成什么文件组？另外有一个词大家记住，由文件ID唯一标识，什么意思呢？啊，我在一个分区路径下可能有多个文件组，每一个文件组都有其对应的固定的ID，每一个组有一个固定的文件ID啊，记住这一点啊。好，那每个文件组里面包含可能有多个文件片叫file slice对吧？文件片啊每个文件片包含什么呢？大家注意一个基本文件.parquet的这是列式存储,多个日志文件.log的后缀啊，这是多个啊。</span><br><span class="line"></span><br><span class="line">那么正常来讲呃，在一个基本文件就表示某一次提交或者合并后，在那个时刻生成的一个所有的数据，这不好理解是吧？那后续再来聊啊，也就是说正常的是有一个.parquet的文件的啊，要么是提交之后，要么是合并之后啊，会生成的.parquet的文件。呃，那么如果是.log文件，这是我们前面简单提到的是MOR这种表里面啊，它会有这种增量提交，那就是.log，这些日志文件就包含自生成基本文件以来，对基本文件中的数据插入和更新。那COW没没有这个是copy on right啊，就写示拷贝，这是hudi里面的两种表啊，回头我们后面会介绍啊，先留个印象，说白了文件片就是有parquet有log能理解吧？parquet是一个log是多个啊</span><br><span class="line"> </span><br><span class="line">另外一件事就是为什么会有多个文件片呢？因为我们保存了多版本多版本的数据，多版本并发控制。啊，那每一次compassion操作它会合并这种点log文件，还有parquet这种基本文件，产生新的什么文件片。哎，大家注意这句话，当我执行一次compassion呢啊这些多个.log文件就会跟parquet的进行一次合并，生成一个大的新的parquet文件啊。那这样的话你看比如说他们那他们呃这个新生成的发可能文件是不是最最新最全的数据啊，对吧？啊，这样就生成了一个新版本的一个一个数据文件。</span><br><span class="line"></span><br><span class="line">另外有我们知道instant里面有一种操作叫清理，对不对啊？它就会清理不使用的或者旧的文件片，对吧？已回收。因为可能我经过多次compassion之后啊啊，比如说我进行了十次compassion，那么这十次是不是会每一次compassion都会对应一个新版本的数据文件生成，是不是？那时间越久这个compassion越多的话，你不可能所有的版本都存着，是不是？那肯定有个策略说，哎，我我满足什么规则的这些旧的版本文件片，我要把它清理掉啊，是有这么一个事儿。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081729048.png" alt="image-20240308172912723"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好。另外注意一个事啊，那我们先来聊一下parquet的文件的一些细节。这个基本文件它在里面的footer的meta里面是记录了什么record key，它里面用的是布隆过滤bloomfilter。说白了就是有一个索引，同学们啊有一个索引。嗯，他这样通过这个东西就能高效的去检测这个record key在不在啊，只有不在的时候才去呃需要去扫描整个文件，去消灭假阳性。我们知道布隆过滤是不是有假阳性啊，假阳性就是说布隆过滤这种实现方式，我们只能百分百确定啊不存在。但是如果不能过滤显示存在，那是不是也有可能它不存在，对吧？有个假阳性率，或者咱们直白大白话来讲，就是有一个准确率的问题。你说不在那就一定不在，但是你说在那只能说可能在能理解这个意思吧，因为你说在是有准确率的。啊，这个布隆过滤呃，自个去了解吧，它就有一个哈希函数，还有多个哈希函数，哎，还有K值啊，怎么样去计算？嗯，呃总而言之，这一段话什么意思呢？也就是说呃这个parket里面它记录了每一条数据的一个唯一key，叫record key。啊，这个词大家稍微记一下啊，会经常提到，经常用到啊。举个例子啊，我有张表啊，别管分不分区呢，比如说我有数据123啊1A2B3C这么三条数据吧。啊那假那么这三条数据刚好就在一个parquet文件里面啊啊，就别说刚好就是在一个parquet文件里面。这个时候呢其实呃这个Parquet文件会记录一个索引index。那我们可以基于布隆来做这个索引的查找。因为布隆布隆会快一点，并且节省空间嘛，效率高嘛，是不是啊？布隆过滤。那这个时候呢哎比如说我现在要呃更新或者插入，这个时候你是不是得嗯先判断一下相同key的在不在。这个key是由咱们去呃可以由我们去指定的啊，就是这个key啊，比如说1A这个key，我用第一列作为key，也就是说第一行的key是1，第二行key是2。</span><br><span class="line"></span><br><span class="line">啊，有点像什么？有点像关系型数据库里面那种组件这种概念能理解吧？啊，类似于组件这个概念啊有点类似啊，我只是说类似好这个时候比如说我要插入一条2D的数据，那这个时候他会呃判断一下2这个key有没有啊。这个时候他请通过这个索引机制，通过布隆的方式呃就能判断到哎我这个二是存在的，那这个时候这条数据就可以单独去处理这条把它更新掉，这也是hudi实现呃行式，还有部分列的upsert的这种呃很重要的索引机制啊，这个我在这里简单提一嘴啊简单提一嘴。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好，再看下一点hudi的log，也就是点log这种后缀的是avro的编码，对吧？他通过积攒buffer，并且以log block为单位写出。也就是说他并不是一条一条写的，就想说这一点而已，而是攒一批数据咱们去写一次log。那每一个呃log block一个文件，一个日志快吧啊，咱们叫log快吧。有一个魔法值magic number，大小size、上下文content，呃文本，还有一个footer等信息用于数据读、校验和过滤。当然这些事不需要我们去关心啊，这是他内部实现的一个机制，对吧？但是既然聊到就简单说一句</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403081735385.png" alt="image-20240308173513479"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那下面这张图就很明显了，这是两种格式的文件，一种是parquet，一种是log。那parquet文件重要特性就是会做一个什么呃，文件的原数据里面会有一个索引啊，可以用布隆，可以用其他的索引方式。那log就更复杂了，对吧？他记录了一堆东西。好，这个是文件布局。</span><br><span class="line"></span><br><span class="line">好，我们总结一下啊呃其实总结就是这张图，还有上面这张图。第一个呢就是我们在文件系统啊是以什么方式存储的。一个表就是一个目录名对吧？一个分区也是个目录名，那跟呃表目录下除了分区目录，还有一个原数据目录。点呼顶啊，就就这就完了呗啊，那每个分区目录里面啊是数据文件，要么是点part要么是点log啊，就这两种就完事儿了呗啊，再往下走。呃，就是这里要注意hudi的一个多版本控制啊，就是每个分区路径下面它是以文件组的方式来组织的啊，有多个文件组，每个文件组有一个唯一的ID啊，记住这一点啊，那每个文件组里面可能有多个文件片，每一个文件片包含了一个parquet多个log啊，具体有几个不一定。当你进行合并啊或者先提交啊啊生成一个新的版本啊，那最新最全的数据就在新版本里面嘛。啊那老的版本也是个文件片，新的版本也是一个文件片。啊，另外呢有一个清理清理器对应的清理策略，会去清理旧的老的文件片啊，这就完事了嘛。</span><br></pre></td></tr></table></figure>

<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403091428384.png" alt="image-20240309142816952"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那刚才也聊到了一个关于索引，对吧？那现在咱我们就来好好聊聊这个索引的一个东西。那一开始也介绍了hudi啊通过索引机制提供高效的upsert。那接下来问题就来，我是怎么来高效的啊，其实前面也简单讲过了啊，它具体是给定一个东西叫hoodiekey对吧？一个key那它是由什么组成呢？一个叫record key记录键对吧？Record就代表你数据的一条一条的记录，就叫record key啊。然后加上什么呢？分区路径partitionpath。大家注意这两个东西组起来叫hooodie key，它与文件ID那么刚才聊到了文件ID是什么？一个文件组有一个唯一的文件ID啊，记住了。好，那也就hooodie key跟文件ID建立了一个唯一的映射。这种映射关系第一次写入文件后保持不变。大家注意第一次写入文件后保持不变这句话什么意思？也就是说这就代表这个映射关系是固定的，是唯一的啊，就这个意思啊，所以呢一个文件组包含了一批数据的所有版本记录啊，我这个前面也聊了对吧？啊，有点拗口。但是我们具体解读就是什么呢？一个文件组里面有多个文件片，每一个文件片都是不同的，是呃不同的版本，对不不对啊，</span><br><span class="line"></span><br><span class="line">另外这个索引可以用来干嘛？用来区分消息是插入还是要更新，是不是？嗯，如果你是我找得到，也就是说我我新来的这条数据，呃，如果原先数据里边没有，那我就是要做insert嘛。那如果原先数据里面有了相同的key，那说明这条数据是要干嘛？是要更新嘛啊就这个意思，那索引是不是啊就很重要了啊，所以就很重要。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403091435986.png" alt="image-20240309143549664"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那下面是官网给出的例子啊，这个索引有什么用啊？再进一步理解一下，hudi为了消除不必要的读写，引入了索引。有了索引之后，更新的数据可以快速被定位到对应的file group。因为我们前面也聊到了，就是它这个索引是不是hoodiekey跟file group那个文件ID的绑定，对吧？直接看图吧，白色的是基本文件，也就是parquet，黄黄色是更数数据，先别管什么parquet .log了，反正就是这是现现有的数据。呃，然后黄色是后面新过来的数据啊，可能是插入，可能是更新，对吧？那如果有了索引什么意思呢？我们一共有几个？123456788份这个更新的数据，每一个是25兆。啊，那这个时候呢呃比如说你如果没有索引，大家想一想，比如说就看这个就好了。这个25兆的文件我怎么知道我要往哪一个方去更新呢？你是不是所有的地方都得干嘛都得去扫描一遍，是不是扫描一下，你这样全量扫描，扫描一下你的这些数据是该往哪里去写，去往哪里更新，效率特别低。但是如果有了索引，这25兆是不是就知道哎他要更新的东西在哪，哎，就是这一百兆对吧？另外这是另外的25兆的更新数据，他是不是就知道他对应的呃数据在这100兆里面。我举个例子啊，这100兆里面有123，那这25兆里面就有一的更新，二的更新，对吧？那这一百兆是456，那这这黄色的这个里面是五要更新对吧？那你看嘛它要更新的是5。他是不是找到无所在的基本文件就行了，他不用所有的基本文件都去扫一遍，能理解这意思吧？也就是说他知道他的目标在哪，这样的话他我们的合并开销是多少啊啊你看这一边呢是100呃加2个25，这个是不150对吧？这是四个文件组嘛，呃那这样的话我们合起来是不是开销就是600 150乘以4嘛，对不对？这个很好理解对不对？这个是大家都知道你要的对象在哪里，对吧？目标很明确，那你就开销少好另外一种没有缩音的时候，这是原先来四个基本文件啊，四个基本文件在这摆着啊，有400兆的数据，然后呢有八次的更新，每一次二十五兆。那现在问题就来了，这25兆他知道要去找谁吗？他不知道吧。所以你这一百兆的是不是要每一个基本文件是不是都要跟所有的更新数据做一次匹配啊？对不对？那这个时候你看它开销是多少，每100兆就得跟这些25兆有八个，这边合起来是200对吧？他是不是要扫描200兆的数据，哎，然后把属于自己更新的部分摘过来。所以它的一次开销是多少？100加200，他自己100嘛，所有的增呃更新是200嘛，加起来是不是300对吧？好，那下一个基本文件，100兆的数据它也一样，它是不是也要在这200兆里面找到属于自己的更新数据，它的开销是不是也是300兆？好，那这四个基本文件这么一下呢，它的开销是多少？1200兆，那你看这个差距是不是差了一倍啊？</span><br><span class="line"></span><br><span class="line">对吧？这个就是索引的好处，让你不会漫无目的。那如果用生活中的例子来讲，这就索引的作用是不是？好，这是它的一个原理啊。</span><br></pre></td></tr></table></figure>

<h5 id="索引选项"><a href="#索引选项" class="headerlink" title="索引选项"></a>索引选项</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">那理解完索引的基本原理，接下来我们聊聊细节了，呃，那是从索引的作用来讲，那么接下来忽底它支持哪一些索引的类型，说白了也就是索引的实现方案，实现方式</span><br><span class="line"></span><br><span class="line">那么简单总结来讲可以分为四大类啊，四大类第一类呢，就是我们前面讲到了布隆索引，它就是用了布隆过滤器来判断，诶，我对应的这一条数据在不在，那这条数据怎么判断，是不是有个hoodie key啊，那怎么判断这个key在不在呢？就是我们指定了一个数据键，记录键，还有分区路径跟file group ID文件ID建立一个唯一映射啊，就判断这个文件组里面这条数据在不在呗，啊那判断在不在，布隆是很常用的一种啊，它也是默认的配置啊，那我们前面讲呢，它的优点是什么？效率高，而且我不用依赖外部的系统，数据与索引可以保持一致性，缺点就是布隆这种过滤布容过滤这种算法，它本身的一个假阳性的问题，说白了就准确率，也就是说你说在它还真不一定在，因为你可能说错了啊，因为他有一个哈希冲突的问题啊。那是你说不在，他就一定不在，能理解我意思吧？呃，当然它正常来讲用它也够了啊，也够了啊，就是兼顾效率啊</span><br><span class="line"></span><br><span class="line">另外一个是简单索引，简单索引呢，它其实是将我们更新还有删除操作的，这个新数据跟老数据进行join，那么大家看到这个就知道这个操作特别重了，它实现起来就是思路上最简单，但是它的缺点也超级明显，性能太差，你想想那如果数据一多了呢，你这个join那还得了啊。对吧，那那那那不行啊。</span><br><span class="line"></span><br><span class="line">那还有一种叫hbase索引。那什么意思呢？他也不是说hbase实现什么算法，而是什么呢？将索引的这个数据存放在hbase里，那说明什么？说明你的所有数据太多了啊，太多了，那我们在插入数据的时候，我们是不是要插入分区下面的某一个文件组啊，那这个时候你在插入的过程中，呃，福迪呢，他会向hbase发起这个请求，读取请求，就查一下这张索引表，看一下，呃，这个数据在不在，也就是说它的区别就在于索引的存储位置啊，存储位置。我直我直接将全量的索引都保存在hbase,你就现查hbase呗，就这个意思啊，对于小批次的key查询效率是比较高的，这是它的优点，但是缺点也特别明显，什么明显呢？你这是要借助外部系统。那你增加了运维的压力，再者说如果hbase你用的不好，或者说你配置的不对啊，像什么内存啊，GC啊，还有它的线程啊，各种东西你没配好，也就是说你hbase并没有用好，这个时候它的QPS上不去，反而成为你的瓶颈。对吧，所以你用hbase index的前提是，嗯，你对hbase比较了解啊，你也知道怎么去让hbase发挥出它应该有的性能。好马配好鞍嘛，能理解我意思吧</span><br><span class="line"></span><br><span class="line">再有一个是忽底后期版本就开始支持flink了，那这个时候他因为前面这些是针对于Spark而言的用户，hudi最早它就支持的一个Spark引擎啊，主要支持Spark引擎，那么后期版本才出了一个支持flink，那这个时候依赖于flink呢，它单独对于索引存储可以存在哪呢？呃，可以存储在flink那个。Think算子的一个状态里面去啊，可以存到flink的状态，因为flink本身是呃，有状态的计算嘛，对吧，它用了flink的状态作为底层的索引存储。每个数据在写入之前都会计算目标的一个bucket的ID啊，它的优点呢，就不同于布隆啊，它避免了每次重复的文件的一个查找。那缺点呢，嗯，缺点我觉得可能的缺点就是对于因为你你这个索引也是存在这个flink状态里的嘛，那如果你的这个索引数据特别大。那flink的状态是不是变得特别大，那进一步是不是就会影响flink这个check point是吧，另外一方面会影响咱们flink的资源使用，当然你可以对flink进行大状态的调优，你可以使用RODB，你可以开启增量检查点啊等等这些，那就看你对flink熟不熟了，是不是啊。</span><br><span class="line">啊，所以我这边注意写的一点啊，flink只有一种是什么state based index。其他的index是Spark可选的配置啊，所以你要注意你用的是什么啊，这个是我们hudi索引，这个索引里面的可选的不同方案不同类型。</span><br></pre></td></tr></table></figure>

<h5 id="全局索引与非全局索引"><a href="#全局索引与非全局索引" class="headerlink" title="全局索引与非全局索引"></a>全局索引与非全局索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在hudi的索引当中啊，它又区分了全局索引还有非全局索引。那所谓的全局索引呢就是整张表而言建立的索引。也就是说即使你做了分区，那么我是整个所有的分区一起来看，那每一个key啊也就是那个所谓的record key啊，数据键它是唯一的，不会有重复的。即使你的数据是在不同的分区，那我也不允许你有重复的这个键啊，那这样就能够确保给定的一个键只有一个对应的记录整张表的范围内。但是这也有一个很明显的缺点呢，如果我这张表特别大，那大的你受得了吗？对吧？那你随着你咱们表的数据量越来越大，你去做一个更新删除操作的时候，你这个性能就越差，对吧？因为你要全表的去匹配，那这样的话即使你做了索引，但这样效率也高不了。所以这种全局索引呢更适合用于小表啊，就是表的数据量并不大，那其实用全局索引呃比较理想。</span><br><span class="line"></span><br><span class="line">那第二类就是非全局，所谓的非全局，那它的范围是什么呢？分区啊对它在一个分区里面能够保证这个key的唯一性。也就是说一个分区里面这个key只能有一个，那不同的分区那里key相同我管不了。对吧？那它是依靠它写入器为同一条记录，就是同一条数据。它的更新也好，你的删除也好，都提供相同的一个分区路径，因为你这条数据是固定的嘛。呃，或者说咱们前面不是讲了一个hoodiekey嘛啊那因为它默认的实现其实就是非全局的。所谓的非全局是咱们的record key，哎，就是什么呢？那个record key再拼接上一个什么呢？partionpath对吧？啊，我的记录键在拼接上一个分区路径，这样它不就唯一了吗？对吧？那这样的话呃你对相同一条数据的更新也好，删除也好，它都能定位到这条数据所在的分区。那这样就可以大幅的提高一个效率。那这样的话大即使是大表啊，相对于全局索引来讲，呃，它的性能会更加的好一点，这个非常好理解啊。</span><br><span class="line"></span><br><span class="line">那从索引的维护成本跟写入性能考虑，呃，大家都知道这个全局索引难度更大啊，性能更差。如果你数据量大的话啊，那么好，既然聊完这个，那我们再对比一下前面聊到的这几个索引类型。在这当中哪一些可以设置全局的，哪一些只能是局部的呢？啊，那么大家注意了，对于hbase这个索引来讲，他就是全局索引啊，它没有非全局啊，它就只有一种全局索引。</span><br><span class="line"></span><br><span class="line">那么对于布隆也好，还有简单索引也好，这两种索引类型你可以选择是全局索引或者是非全局索引。这个可以通过参数来配置。那当然我前面也提到这个主要应用于Spark引擎，是不是啊？那具体的配置方式呢就是这样啊，就是一个参数啊，hoodie.index.type=GLOBAL_BLOOM, GLOBAL_SIMPLE，这个是一个全局跟非全局。那如果数据量足够大，那一般来讲还是用非全局，所以会好一点啊，这也是一个默认的啊，大家注意这个是默认的。这是一个。</span><br></pre></td></tr></table></figure>

<h5 id="索引选择策略"><a href="#索引选择策略" class="headerlink" title="索引选择策略"></a>索引选择策略</h5><h6 id="对事实表的延迟更新"><a href="#对事实表的延迟更新" class="headerlink" title="对事实表的延迟更新"></a>对事实表的延迟更新</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那么接下来就是我们这么多个索引怎么来选择呢？或者说什么样的场景更适合什么样的索引。这个那么下面给到大家的是官方的一个资料啊，这个描述也好，这个动图也好，都是官方做的那我们一起来看一下，第一个场景是对事实表的延迟更新，什么意思呢？呃，熟悉数仓建模理论呢，我们都知道我们通常会去构建一些事实表还有维度表。对吧那对应呢我们会去构造各种模型，像什么新型模型、雪花模型、星座模型，这是基于维度建模理论。总而言之呢，我们通常在数仓里面都会有一个事实表和维度表。那事实表其实就是对应我们的业务过程。那比如说你如果你是电商场景，那你应该就有大量的交易。比如说订单的数据，支付的数据啊，还有比如说像什么加购物车的数据，这种都是属于咱们的事实数据。那这一些呢，我们通常首先会在数据库当中存储大量的这些事实的交易数据，对吧？那除了电商场景，还有其他的像共享出行的什么行程表，股票买卖记录表啊，这都是不同业务场景下的一些事实表啊，电商的订单表。呃，那事实表有个特点就是什么呢？啊，随着你的业务在不断的就用户在使用啊，不断的操作，不断的去执行一些业务过程。那么你事实表的数据应该是一直在不断的增长。就比如说订单好了，你每天都有人下单，那你这个订单的数据应该是越来越大越来越大。啊。另外呢这些事实数据还可能发生什么呢？更新更新。而且更新的话我们还要考虑一个事情，它更新的数据大概呢是很久以前的，还是说最近的呢？那么大家可以想一想，比如说电商的订单表就好了，一笔订单的状态要发生改变对吧？啊，比如说咱们退单呢，或者从下单变为支付状态啊，或者再再到最后的呃签收状态等等。这些看你业务怎么定义啊。呃这些是不是针对于最近的这些订单才有可能啊，比如说你距间隔了一个月以上，那么你这个订单的信息是不是基本上不会再变了。因为从业务上来讲，商家也不会再允许你超过一个月再去说做一些退单，或者说我下完单一个月不不付款，一个月后再付款，这种应该是不会出现，对吧？所以呢这种更新事实数据的更新应该是发生在什么较新的记录上。也就是说它的更新数据分布是有特点的啊，都是最近的。那么对于比较老的一些数据呃，它的更新就比较少了啊，因为这一笔订单，这笔交易早就关闭了啊，不会再变更了啊。</span><br><span class="line"></span><br><span class="line">嗯总而言之呢，就这种场景，大部分的更新会发生在最新的几个时间分区上，而小部分呢在旧的分区啊，那这个是官方画的一个图啊，这是一个数据库啊，nosql的存储也可以啊。那么这边呢是根据什么分区呢？你看订单创建日期啊，比如说咱们到呃年月日这样子好。那更多的是在什么最近的这一段时间，那更早之前的这些数据基本上很少做一个变更啊。好了，对于这样的这种场景，我们适合用什么布隆索引？因为它可以帮我们去裁剪，因为它里面可以比如说范围裁剪，我举个举个例子啊，它可以通过min max对吧？呃，我取一个最小最小最大区间啊，命中了，那就在这个区间里面找就好了，对吧？我把小于最小的，大于最大的直接就裁剪掉了。好，就简单举个例子啊，那布隆过滤天生就是用来判断呃用来判断在与不在，是吧？非常高效。那如果我们生成了这个key，也就是我们回头指定生成的这个record key啊，大家注意咱们反复聊到key键这个概念就是指的record key啊，可以某种顺序排列。也就是说它是有序的那这样的话他就能够更多的去筛选，尽可能的筛选出来啊，就将不必要那些更多的就过滤掉了，那这样性能就更高了啊，那hudi会用所有文件的键域来构造区间数。键域就是键的范围，比如说从哪到哪啊键域啊，构造一个区间数，这样能够更高效啊。</span><br><span class="line"></span><br><span class="line">总而言之，言而总之这一段话就是什么呢？适合用布隆布隆，可以做一个呃区间裁剪啊，更高效。嗯，那如果我们为了更加高效的使用布隆过滤器进行一个比对的话嗯。这边hudi缓存的什么输入记录，也就是说做了什么事的缓存。并且使用了自定义分区器和统计规律来解决什么数据的倾斜啊偏斜。有时候你看这边说布隆过滤器的伪证率，其实就是什么常说的假阳性率啊，过高会增加数据的打乱操作啊。</span><br><span class="line"></span><br><span class="line">那这个时候呢也就是说如果假阳性率特别高的话，为什么假阳性率会高啊啊大家应该知道布隆它的准确率或者说误差率是不是呃通过一个公式可以算出来。那这个公式是不是跟很多呃因素有关系。第一，数据集的大小，也就是说你整个数据量有多少。第2个可能你给到了这个bit mp空间有多少。还有呢你这个系数，还有哈希函数的个数啊等等，这些都有关系。那么呃其中一点就是数据量对吧？啊，数据量越大，那么你这个假阳性率的可能性是不是就越大？那个公式忘了自己可以去研究一下啊，那这个时候我们就希望呃布隆过滤器的一些参数啊，一些一些变量能够动态的调整。可以啊，我们只需要什么设置这个参数就可以了。你看啊hudi布隆首先指定为布隆索引的过滤类型，指定为动态的就可以指定位动态。它可以根据咱们总的数据量来调整布隆相关的一些参数，而从而达到我们希望的那个假阳性率啊。对于叫假阳性会更好理解啊。这能理解吧？啊，或者既然说到这儿，我就简单给大家看一眼吧。呃因为有的人可能还不太熟啊，不太熟啊啊比如说布隆，你搜一下过滤器。呃，我看一下有没有原理的介绍啊，看一下10分钟理解啊，随便找一篇啊，我只想找到它的公式，原理我就不讲了啊，原理不讲了。这篇没有给我们那个数学公式啊。啊，随便点啊。呃，这个也算吧，但我想找一篇更全的。哎，你看啊呃，那我们看也就是说跟公式有关系啊。看这一篇。哎，详解布隆过滤器的原理，使用场景，注意试一下。我看一下这个的。好，那我们看一下啊，也就是说这些公式大家自己看一看就行了。它有我们的数据量啊，其中一个参数，数据量一个是K值，一个是M值，一个是bit map的大小。这一节能够计算出一个一个它的阳性率啊，或者说。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那这个时候我们就希望呃布隆过滤器的一些参数啊，一些一些变量能够动态的调整。可以啊，我们只需要什么设置这个参数就可以了hoodie.bloom.index.filter.type=DYNAMIC_V0。你看啊hudi布隆首先指定为布隆索引的过滤类型，指定为动态的，就可以指定为动态。它可以根据咱们总的数据量来调整布隆相关的一些参数，而从而达到我们希望的那个假阳性率。啊，或者既然说到这儿，我就简单给大家看一眼吧。呃因为有的人可能还不太熟啊，不太熟啊啊比如说布隆，你搜一下过滤器。呃，我看一下有没有原理的介绍啊，看一下10分钟理解啊，随便找一篇啊，我只想找到它的公式，原理我就不讲了啊，原理不讲了。这篇没有给我们那个数学公式啊。啊，随便点啊。呃，这个也算吧，但我想找一篇更全的。哎，你看啊呃，那我们看也就是说跟公式有关系啊。看这一篇。哎，详解布隆过滤器的原理、使用场景、注意事项。我看一下这个的。好，那我们看一下啊，也就是说这些公式大家自己看一看就行了。它有我们的数据量啊，其中一个参数，数据量一个是K值，一个是M值，一个是bit map的大小。这一节能够计算出一个一个它的阳性率啊，或者说准确率，或者也可以算为什么误报率。</span><br><span class="line">这是第一个场景事实表啊，总结起来是什么？事实表这种场景呃更新主要集中在最近的日期，那么我们用布隆就可以了。</span><br></pre></td></tr></table></figure>

<h6 id="对事件表的去重"><a href="#对事件表的去重" class="headerlink" title="对事件表的去重"></a>对事件表的去重</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">好，第二种场景是对于事件表的去重大家注意是事件啊，不是事实事件是什么呢？比如说前端买点产生的这些呃事件流。比如说呃点击流，用户的点击买点产生的数据，还有咱们物联网，比如说车联网一些传感器产生的这个数据啊，我们通常称为事件流嘛对吧？还有广告点击这些啊广告曝光。好，那么这一些呢我们通常会将这个数据先采集进kafka对吧，这种消息队列。那么而且这种的数据量一般呢是咱们业务数据库当中呃10到100倍，也就是说事件事件的数据往往是大于事实的数据，对吧？也就是说数据库里的数据跟我埋点产生的数据哪个更多呢？一般来讲是买点还有传感器产生的这种啊会更多一点。而且他有一个特点，他要不要更新呢？这种事件的数据一般而言都是追加啊，不存在更新。大部分而言啊，那即使有更新，那可能也是最近的几个。那这个时候呃涉及到一个数据重放啊，可能是一个采集的一致性这些问题可能有一个重复的问题。那这个时候去重也是一个很常见的一个需求吧，对吧？这个大家做过的话应该都很熟悉啊，不管你是什么业务场景。</span><br><span class="line"></span><br><span class="line">那接下来呢就是咱们对于这个呃你想要低消耗的对大数据量进行去重，这个还是说还是比较难度的啊。要么你就是挺浪费资源，那其实如果咱们可以用间值存储来实现去重啊，或者说这个量比，说白了就一句话，量比较大怎么办？那可以如果你对hbase比较熟悉，并且呢你们公司当中，你们环境当中有人可以维护运维这个hbase，并且能调的用的比较好，那你可以考虑一下用hbase啊。因为它在呃底层的h base索引当中，它不是简单的将索引数据就存进去了。它也利用了h base像LSM tree这种特性啊，做了很多很多的一个处理跟优化啊，但是呢这个事件数据还是不断膨胀的，一直在膨胀。那即使您要去hbase代价也是比较大，不是说不行，是代价比较大。呃，但这种时候呢有范围裁剪功能的布隆，所以才是比较好的，你又可以裁剪过滤。那这个时候我们这个record key可以怎么做呢？可以用事件时间加上呃标记这一条事件的一个ID来组成这个键就好了event_ts+event_id。</span><br><span class="line"></span><br><span class="line">那这样有什么特点？你看这个时间戳它是不是一个递增，哎，对吧？那这样的话就是一直在增长的一个单调递增的一个键。好，总而言之呢，如果是这种布隆也更合适啊。那么我们大家看完两个场景都发现哎布隆更合适啊，所以其实布隆就是默认的，默认就是用了布隆啊。</span><br></pre></td></tr></table></figure>

<h6 id="对维度表的随机更删"><a href="#对维度表的随机更删" class="headerlink" title="对维度表的随机更删"></a>对维度表的随机更删</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">那么对维度表的随机更新和删除，什么叫维度表啊？像什么地区啊、时间呢呃渠道啊对吧？这一些就是我们所谓的维度。比如说你电商场景是不是还有呃商品维度对吧，是哪一个品类的啊等等这一些。包括什么用户维度表对吧？记录了用户信息的这些表啊。用户维度信息也就是说你在建模的时候肯定要去构建一些维度表。那维度表有个特点啊，它的更新和删除。我举个例子，一张用户表啊，比如说你有张用户表，呃，有123有3名用户啊。用户一是去年创建的啊注册的啊用户二是今年呃上半年注册的用户，三是现在注册的。那这个时候呢呃很久以前注册的一他有没有可能更改信息啊？很有可能吧，他可以更改他的呃绑定邮箱，更改他的绑定手机号，可以更改昵称，可以更改地址，是不是都可以改，对吧？也就是说你并不是说你的更新都集中在最近这一段时间，而是不一定啊，所以我们叫随机啊随机。</span><br><span class="line"></span><br><span class="line">好，那这种场景的话你用来去裁剪就不合适了。因为比如说我有这么一个呃这么一个范围吧，我这个表示时间顺序，好吧，表示时间顺序。如果你是裁剪的话应该是什么呢？呃，筛选出一段，那在这一段里边再去匹配，这样效率高。那我现在维度表这种场景是哎我指不定在我不会集中在某一段进行那个更新和删除。我可能在这里可能在这里，那你就没法把我提前拆剪掉了。那这样的话你用布隆的话就不能够得到一个很好的效益啊，就性能可能就啊没有发挥不出来了。也就是说这个是随机写入。那我们的更新操作会触及表里大多数文件，大多数分区，对吧？啊，这时候布布隆就不太好使啊，即使使用了范围比较也还是检查所有文件啊，那这种场景怎么办呢？</span><br><span class="line"></span><br><span class="line">呃，简单来讲，既然是可能所有文件都可能涉及到，那你就用简单索引就好了啊，就不要做呃不要做那些花里胡哨的招了啊不要给自己呃搬起石头砸自己的脚啊，没必要啊。他不因为呢简单索引他不会提前裁剪啊不提前裁剪，而直接是将所有文件跟所需字段连接啊，就是join嘛，我们前面聊聊过嘛，对吧？呃，但是这种场景你也可以考虑hbase啊，因为是你只要是对hbase能够拿得下，能hold得住，那样hbase也是可以的。而且hbase对于这种随机读写也是很擅长的，是不是？</span><br><span class="line"></span><br><span class="line">好了，另外呢有一个小事情啊，小事情就是什么呢？呃，我们用全局索引的是时候啊，有可能涉及到分区路径需要更新，哎，你可能不好理解对吧？呃，如果你是按照年月日这种日期来作为分区字段，那一般这个分区产生就不会变了是吧？比如说你是2022年9月1号这个分区，那基本上这个分区值就不会变了。但是如果你用的不是日期呢？啊举个例子啊，如果你是按照城市来分区的一张用户表，对吧？比如说哎北京这个城市是一个分区，深圳是一个分区对吧？那北京比如说有用户ABC呃，深圳这个分区里面有用户D的信息啊，你是这么来做了对吧？那就有可能出现什么呢？用户A他离开了北京，他去了深圳。那这个时候。是不是对于A这条数据来讲，它的分区值是不是变了，它的分区信息是不是变了，对吧？那这个怎么办呢？</span><br><span class="line"></span><br><span class="line">这个时候咱们可以开启这个参数，hoodie.bloom.index.update.partition.path=true或hoodie.simple.index.update.partition.path=true。那分下面还有一个参数，那其实这两个分别对应的一个是用了布隆，另外一个用的是简单索引。啊，你用的什么索引，你就设置哪个参数啊。那这个时候用MOR的表会更好啊，当然这个表后面再来聊啊，下面就会聊到啊，这是一个小事情啊，就是分区路径会更新的这种特殊场景啊，可以开启参数好了。</span><br><span class="line"></span><br><span class="line">综上所述啊，我们简单聊下来就是什么呢？大部分场景事实表、事件表、事件流都可以用布隆就好了。另外呢如果hbase hold得住，那就用hbase。</span><br><span class="line"></span><br><span class="line">第呃第二点呢，如果是随机的更新这种场景，那就是用简单索引啊或者用hbase。好了，这都是一个取舍，没有说谁绝对好，谁绝对差啊。也就是说更新频率，更新的范围比较集中，用bloom够更好，呃，更新比较分散，那就用简单索引或者hbase好了，就这样子。</span><br></pre></td></tr></table></figure>

<h4 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h4><h5 id="COW表"><a href="#COW表" class="headerlink" title="COW表"></a>COW表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前面聊了这么多概念，那么接下来这个概念是大家必须要了解的。就是表类型在hudi当中它有两种表，一种叫copy on write，简单来讲就是写实拷贝。另外一种表呢叫做merge on read，叫读实合并啊，那么大家记住啊，这是物体特有的两种表类型。</span><br><span class="line"></span><br><span class="line">那我们先来看第一种类型叫COW啊，咱们简称COW啊，copy on copy on write. 那么它的特点是它的数据文件当中，它只有一个基本的列文件列存的，也就是这种所谓.parquet格式。他没有点log啊，这个特点大家要记住啊，因为点log是增量提交的时候才有的啊，这个时候没有。那么对于每一个新批次的写入，它都会创建相应的数据文件的新版本啊，这句话大家好好品一下。对于每一个新的批次，也就是说我写入一批新的数据了，那这个时候都会创建相应数据文件的新版本。哎，重点是什么？新版本新的一个文件片，也就是我举个例子啊，原先在一张COW的表中，它只有一个parquet文件。比如说啊。它里面比如说存储了id为一二三这么三条数据啊，那现在呢我们要去追加写一个四跟五这么一批数据啊，4,5这2条新的数据要写进来了，那这个时候他会做什么呢？呃，他就会将原先老的，也就原先的parquet文件，再加新增加的这些变更数据，将他们合并起来。然后呢就会变成一份新的12345啊，这样子能理解这个意思吧？</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403101525962.png" alt="image-20240310152555403"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这也是为什么叫写时拷贝，拷贝的是什么呢？拷贝的是原先的parquet文件，将原先parquet文件都拷过来，再将新增的部分及变化的部分合并进去，再写入一个新的文件。那新的文件它也是一个parquet。那这个时候呢对应我们前面聊到的一个概念叫什么呢？文件片。那这个一二三这个比如说它就是一个文件片啊，比如说是一吧，我们称之为一fileslice1。那么写示拷贝完啊合并完这个新的parquet文件，那可能我们就可以认为它是一个文件片fileslice2，它们都是在同一个文件组里面是吧？嗯，这也是为什么我们前面说到这个文件片，可以理解为呃不同文件片是不同的数据版本。好，这简单理解啊呃新版本文件包含旧的文件记录集这个批次的记录，那最新的这个文件片就是包含了全量最新的数据了。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403101529312.png" alt="image-20240310152919086"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403101531001.png" alt="image-20240310153114556"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">好，那下面看一个具体的例子啊，其实大家基本理解了啊，那当前呢是给到3个file group。有三个文件组。那么目前呢他们的版本都是第一个版本啊第一个版本。好，那这个时候我们进行一个数据的写入，新的写入。那你看啊场景是这样，在索引之后我们发现这些记录与啊文件组一、文件组二匹配了。也就是说什么呢？啊，我有一些数据是要属于更新操作的啊，那这些数据对应的原先数据在文件组一和文件组二里面啊，另另外呢有一些数据它是属于新的插入啊，不是更新啊啊那个时候候我会将将的插入入写到一个新的文组组，也就第四个组。比如说啊好，所以就变成下图这样子，文件组一、文件组二有些数据需要更新啊，那这个时候他们就会对呃旧的呃V一版本的数据，还有更新的数据进行合并啊，并且呢写入一个新的parket，生成了一个V2版本。那文件组2同样的道理，它也生成了一个V2版本，新的文件片，新的parquet，那文件组三呢没有变化啊，那还有一些是新插入的数据啊，就写入一个新的文件组。文件组四好，知道这个应该都好理解吧。</span><br><span class="line"></span><br><span class="line">那基于这个大家就能想到了，呃，它是属于写入期间进行合并的。也就是说我一批数据插入的啊，我既要拷贝老的数据，又要将老的数据，将新写新过来的数据进行一个合并啊，写入一个新的文件。所以呢它写入的延迟相对会大一点。但是COW是最早封底设计的一种呃表一种表，它的优势就是它非常的简单。</span><br><span class="line"></span><br><span class="line">另外有一个特点需要大家记入，它并不需要进行compassion。大家注意啊，如果是COW的表，它并没有compassion这个动作。因为它每一次都写入的时候就进行合并，合并成一个新的parquet文件嘛。啊所以呢它COW表就没有必要进行这种压缩合并操作啊，也是用起来比较方便和简单。好，那么这个是我们对COW表的一个理解啊，应该没什么难度。</span><br></pre></td></tr></table></figure>

<h5 id="MOR表"><a href="#MOR表" class="headerlink" title="MOR表"></a>MOR表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们看第二种类型的表，merge on read, 也就是所谓的读实合并。那么大家注意它包含什么样的文件呢？第一，它可能有parquet文件，大家注意我的描述啊，可能有parquet文件。另外它一定会有一个基于行存的增量日志文件，也就是avro格式的。那么它具体的文件名呢，就会看到点log这么一个后缀啊，这个我们前面也是简单给大家看过，对吧？有一些点log。好，那为什么叫MOR呢？那是因为它的合并在读取端，什么意思呢？哎，你看我现在是不是既有这个基本的列存文件parquet。另外呢还有每一次呃新增加的数据，比如说插入或者更新的数据，它这一批数据会记录在一个点log文件，对吧？那再来一个新批次，又这些数据又有插入有更新，它可能又在一个新的点log文件。也就是说在这张MOR表当中，他是不是可能有parquet，又有多个log，那你读的时候该怎么读啊？因为老的parquet文件，它里面可能包含了一些是过期的数据，对吧？啊，比如说我们原先这里有一条1A这么一条数据，然后后面我对它进行了呃更新。那我是不是有一条数据，比如说A变成B啊变成一B啊，这是更新后的数据。那它过来它不会对原先parquet文件进行处理，而是什么呢？将这一条更新的数据放在点log文件，对吧？所以这个时候如果你只读这个parquet那可能是不准的。所以你要综合parque和点log文件啊，才能得到最新的结果。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403101602586.png" alt="image-20240310160209348"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这个MOR表读的时候parquet也好，log也好，它都会一起在读的时候进行合并。这也是为什么叫读时合并啊，只有在我进行读取操作的时候，我才会将parquet跟log进行一个合并。好。所以它的合并在读取端啊，它而且呢它在写入的时候不会进行合并或者说创建新的数据文件，对吧？这个就区别于COW表，它是写入的时候进行合并生成新的文件啊，那MOR不会也也就相当于说是反过来了</span><br><span class="line"></span><br><span class="line">当完成了标记索引之后，呃，对于具有要更新记录的现有数据文件，是创建增量日志，就我刚才说的.log文件啊，那就像你看这一个文件组里面啊有parquet也有log。那么大家要注意的一件事情是什么？一定有parquet的吗？不一定。如果我这张hudi表呃是第一次有数据，来，大家注意听我描述啊。这张表第一次有数据写入，也就第一批数据来，这个时候你没有parquet文件。第一批数据也是会追加到点log文件里面去啊，这个时候你就看不到PAS回来。就像我前面给大家看的时候，是不是也只有一个点log是吧？</span><br><span class="line"></span><br><span class="line">啊，当然呢后面它呃对于MOR表有这个所谓的compassion啊，有不同的策略，不同的条件。当你满足这个合并的条件之后，或者执行合并的时候，就会将现有的parquet和log进行一个合并成一个新的parquet文件。啊，这是compassion会做的事儿啊。读取端将实时合并基本文件，也就是parquet及各自的增量日志文件。啊，好了，每次的读取延迟都比较高，因为啊我们要查询时才进行一个合并操作。</span><br><span class="line"></span><br><span class="line">另外就是我刚才提到的压缩机制，也就是所谓的compassion。这个就是无论你读与否啊，有没有就是即使你没有读这个compassion，如果触发的话，它也是会进行啊文件的合并的啊，它会将数据文件parquet，日志文件点log合并在一起，会创建新的parquet。</span><br><span class="line"></span><br><span class="line">那关于这个compassion呢呃我们可以选择内联方式或者异步模式来运行，而且他提供了不同的压缩策略。那其中最常见的是基于什么？提交的数量。就像我刚才讲的，我每经过三次提交，每一次提交都会MOR表。每一次提交是不是都写入一个点log文件了，对吧？啊，比如说我有三次提交，那就有三个点log文件。呃，那这个时候我指定数量为三就compassion，那它就会触发自己的compassion，生成一个新的parquet。那么压缩完成之后，读取端只要读取最新的数据文件，而不用关心什么旧版的文件。这样是不是呃这种compassion机制是不是可以减轻咱们读实合并的一个性能问题，对吧？如果你从来不做compassion，那我每一次读都必然要跟旧版的parquet，跟新版的，跟各种各多个log文件进行一个线合命啊，那效率就低低了啊，所以这个compission也是很重要的一个事儿啊。</span><br><span class="line"></span><br><span class="line">呃那下面一些细节呢就是什么呢？MOR表的写入行为根据索引会有一些区别啊。如果我们用的是布隆索引，它是无法对点log这种文件生成索引的啊，所以这个时候它会怎么做呢？它会将插入的消息写入parquet，将更新的消息写入这个点log。大家注意这是针对布隆索引，为什么呢？因为它对avro这种啊log file不能生成索引。</span><br><span class="line"></span><br><span class="line">那如果咱们用的是flink，就是现象是不一样，这个大家要明白。如果用的是flink它是基于状态的索引，那每次写入它都是log的一个格式，呃，并且会不断的追加。那这个时候它就不会说我in sert的消息写入parquet，update写入log不是这样啊，它统一都写入什么log，追加到log。好，这个是一些区别啊。那具体来讲就是回头咱们演示的时候啊啊，如果咱们用sport引擎默认的布伦过滤就可以是这样子啊。银色的跟UP对分开写，那么如果是flink那就统一都写入到log啊。好，这个就是MOR表。那么大家可以想一想对吧，这两种表什么样的场景呃，适合用什么表？</span><br></pre></td></tr></table></figure>

<h5 id="COW与MOR的对比"><a href="#COW与MOR的对比" class="headerlink" title="COW与MOR的对比"></a>COW与MOR的对比</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111322448.png" alt="image-20240311132159848"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">那接下来我们就来对比一下这两种表的优缺点啊区别在哪里啊。那我们看一个从数据的延迟来讲谁更高啊。COW更高一点啊，MOR的表反而会更低一点啊，数据的延迟。</span><br><span class="line"></span><br><span class="line">那么查询的延迟呢就是我查这张表啊需要多久时间。COW为什么呀？因为我要查的时候，它是不是他是在写入的时候就进行合并了。我查的时候它是不已经合并完了啊，简单来理解是这样，所以我查的时候是不是延迟更低一点是吧？呃，那么对于MOR来讲，你的查询延迟就高了。因为你是读取查询的时候才进行一个合并啊，那你肯定就相比COW要慢一点了啊啊对</span><br><span class="line"></span><br><span class="line">啊，好行，另外一个是更新的成本，IO成本啊，我要对表的数据进行一个更新，谁的成本更高呢？呃，对于COW来讲它更高。因为我们知道每一批数据来，它是不是要把旧的拍回来，跟新的数据进行一个合并，写入一个新文件。那如果呃我有一张表，有一个盘毁的文件吧，比如说这里有一万行数据，那现在我对其中的某新来的数据是对某一行数据，比如说id为三的进行更新。那这个时候他是不是同样得拷贝原先的一万条数据，并且将新的数据跟老数据合并，再写入一个新文件。这个代价是不是有点大啊，能理解这个意思吧？啊，这个代价就大了啊，另外一个呢就是咱们的这个MOR表，他代价比较低。为什么他不会动原先的parquet对吧？先不考虑这个compassion，呃，我不会动，我只会将新来的这些数据插入也好，更新也好，我都追加到那个点log文件，回头等compassion或者等你查询的时候，我先合并啊</span><br><span class="line"></span><br><span class="line">好行parguate文件的大小，呃，COW它的是更小更低，但是它更新的IO成本更高。MOR文件会更大一点啊，但是它更新成本比较低。</span><br><span class="line"></span><br><span class="line">写放大啊，那COW不用讲，它肯定是一个写放大的一个问题，对吧？我写的时候哎我要拷贝旧数据啊，这代价就比较重了。那么MOR表呢它写会不会放大呢？就呃相对来讲是低一点。当然说了这么多，大家应该有一个初步的印象，但是理解不会很深入吧。</span><br><span class="line"></span><br><span class="line">那咱们来个大白话啊，COW比较适合什么？批还有流计算这两种场景来考虑，是不是更适合于批呀？因为我们知道它有一个什么写放大的问题。如果我原先的parquet文件有一假设啊有一亿行，当然不会这么做啊，我们不会让它那么大有一亿行现在呃我来的数据这个批次只有一条是更新的数据，那你是不是要拷贝原先一亿行更新的这一条进行合并，代价有点重吧。但是如果我来的是一批数据，这里面包含了比如说100万条，那也就是说我做这么一次啊，那还行，对吧？比你一条一条的去啊效率会更好一点。所以呃建议就是COW表呢，咱们还是用在批处理的一个场景会更好一点。</span><br><span class="line"></span><br><span class="line">那MOR表呢就是呃批也好，流也好，其实也都行。但是如果是流式场景，咱们更推荐MOR表。因为你想想什么叫流啊流处理啊，流处理是不是数据源源不断的来，是吧？那如果不做处理，咱们是不是数据是一条一条来的呀，一条一条写入啊，对不对？那也就是说他写入会特别特别的频繁，比如处理写入很频繁，每次量又很小。你用COW的话，这个写放大问题就很严重，特别严重啊，没必要。所以如果是流失场景，特别是你用CDC去同步一些数据过来，呃，咱们还是推荐用MOR表。当然不绝对啊不绝对啊。如果你对虽然是流处理，但是你做了一个展批的处理，那其实也还行啊。</span><br><span class="line"></span><br><span class="line">好，这个是咱们啊主要一个对比啊，心中有数啊。也就是说COW偏向于P或者呃只要有涨批吧，不管是批处理还是流处理，有涨批的这种更好一点。呃，MOR呢更适合流式的写入啊，流式的写入。好，这个取舍呢各大企业就一些大厂他们在用的时候啊，呃流式场景也有用COW的，也有用MOR的啊，就是说嗯你看吧，这是我的一呃一些建议。</span><br></pre></td></tr></table></figure>

<h4 id="查询类型-Query-Types"><a href="#查询类型-Query-Types" class="headerlink" title="查询类型(Query Types)"></a>查询类型(Query Types)</h4><h5 id="Snapshot-Queries"><a href="#Snapshot-Queries" class="headerlink" title="Snapshot Queries"></a>Snapshot Queries</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111450035.png" alt="image-20240311145011015"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hooody呢提供了三种不同的查询类型，我们一起来了解一下。第一种呢是快照查询。什么叫快照呢？简单来解就大家记住就是四个字叫全量最新。哎，我就要查询当前呃数据最新的一个状态，全量最新就记住这四个字就行了，这就是快照查询。</span><br><span class="line"></span><br><span class="line">那区别于两种表类型有什么特点呢？COW表你就是直接查询最新版本的parquet文件就可以了，这个好理解吧，因为最新的这个parquet文件肯定是全量最新，对不对啊？那MOR表就不一样了，呃，MOR表需要做一个什么？呃，就是说即使要去合并读的时候要去合并，合并什么呢？最新的文件片里面当中的基本文件，也就是parquet。呃，还有呢一些点log里面的增量数据，增量文件，它会将他们合读取的时候进行合并，合并的时候展示给你啊，所以呢呃提供一个近实时的表，因为它合并还需要一些延迟嘛，是吧？所以MOR表你去查询的时候有一个读取延迟啊，就在因为它作为一个现合并啊，行，这个是快照查询。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111414954.png" alt="image-20240311141444608"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面这张图简单搂一眼啊（COW快照查询），这什么意思呢？呃，大家注意看这边有四个什么呢文件组，这是file ID啊。它这个字体可能容易看错啊，这是file ID然后这是file ID1234表示四个文件组啊。另外呢就是呃这个是COW表为例啊，那我们看啊他在十点钟的时候啊，用这个淡蓝色表示进行了一次commit。那这个时候可能插入的呃只有两个文件组，文件组一还有文件组2，你看他们有蓝色的对吧？好，再之后呢在绿色的这个时刻，也就10点05分，呃，他又有一批新的数据commit了。那这个时候呢可能涉及到什么？呃，文件组一、文件组二里面数据的更新，还有呢一批数据的插入啊，也就是文件组三了啊，所以大家可以看到一二呢这里有更新，然后三呢是新插入。好，那么粉色的这个就10点10分的时候再一次commit一批数据，这个时候可能涉及到文件组一、文件组2的更新，对吧？啊，所以呢啊一二又更新了，然后呢又有一批数据新的插入啊，在文件组4。哎，在所以呢这个是一个不是一个动图啊，所以大家会看。那完事之后呢，我们可以看到你在10点05分的时候去查询它的全量最新快照是什么？你看在05分的时候，你进行一个快照查询，全量最新是什么？是不是文件组1二三里面的这三个parquet文件呢？对吧？啊，所以你看有文件组1二三里面呢，他们的版本都是5分的时候，这个时候文件组四还没有生成呢，还没有呢，能理解这个意思吧？</span><br><span class="line"></span><br><span class="line">呃，另外呢在我们10点10分commit之后，这个时候你再去做一个快照查询询能达到什个效果呢？呃，首先文件组一、文件组二是不是都有一个最新的parquet文件，是吧？一二里都能查到。那四呢也是在10分的时候新插入的，新生成的也能看到。关键就在于三呢。对于三来讲，你可能觉得哎10分的commit跟他没关系是吧？虽然你没有数据的变更怎么样呢？没无所谓，但你现在是最新状态是什么，你也展示出来呗啊，所以你这里能看到什么呢？文件组三它的版本还是停留在10点05分，因为这就是它的最新版本了，能理解这个意思吧？这就是这张图的意思啊，慢慢去解读。</span><br></pre></td></tr></table></figure>

<h5 id="Incremental-Queries"><a href="#Incremental-Queries" class="headerlink" title="Incremental Queries"></a>Incremental Queries</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111449696.png" alt="image-20240311144942588"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看增量查询，它可以查询给定的提交commit或者增量提交delta commit。这个提交就对应咱们那个COW表的方式啊，delta commit就是对应MOR表的这种方式啊，呃给定了这个某一次commit以来新写入的数据，对吧？就比如说刚才这个例子，如果现在时间已经到了，经过了10点10分的commit，呃，你可以怎么样呢？你可以指定说哎我从10点05分之后或者从十点钟之后以来先提交，而不用去查询这个commit之前的一些数据的啊。</span><br><span class="line"></span><br><span class="line">这个时候我们而且还可以开启一个变更流啊变更流来启用增量的数据管道。还记得咱们前面聊到护底的一个使用场景，是不是有一个增量管道啊，对吧？那也可以依赖于它的增量查询啊，说白了就是过滤一个某个commit之后新写入的数据啊，其他就不要。也就是说它不是全量最新啊，不是全量执新，而是指定commit之后新增加的这一部分数据。</span><br></pre></td></tr></table></figure>

<h5 id="Read-Optimized-Queries"><a href="#Read-Optimized-Queries" class="headerlink" title="Read Optimized Queries"></a>Read Optimized Queries</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111449663.png" alt="image-20240311144927506"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111502750.png" alt="image-20240311150233853"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还有一个叫读优化查询。大家看描述的话是commit还有compassion的最新快照。有的人就有疑问了，那这个跟快照查询不就一样吗？哎，大家注意咱们这边描述可不一样。普通的commit对应的是COW表啊，所以对于COW表来讲，快照查询跟读优化是一样的。但是对于MOR表来讲就不一样。这个delta commit，这个compassion也好，都是对于MOR而言的，对不对？读式合并，那delta commit呃就是增量提交。那我们知道呃增量提交完，然后你再去查这个快照查询一定是全量最新。但是compassion就不一定了。因为每次compassion之后，它是不是将老的parquet跟多个log进行一个合并，生成一个新的什么新的parquet是吧？那这个新生成的这个parquet一定是全量最新吗？不一定啊，为什么呢？我可能在compassion之后又进行了好几次的增量提交，又多了好几个.Log文件能理解吧？如果是读优化视图，它的区别在哪？它只会查询最新compparsion之后的这个parquet文件。也就是说在这一次parquet后面的这一些点log它查不到了啊，所以对于MOR来讲，它并不是全量最新能理解吧？</span><br><span class="line"></span><br><span class="line">好吧，那看下一句话，他仅将最新的文件片，最新文件片嘛的什么呢列文件暴露给查询。这就我刚才讲了，如果是MOR表，我在某一次compassion之后，它是生成了一个新的parquet。但在这之后呢，它又多次提交，又有又有新的点log写过来了。这个时候你只查到parquet  log你没有查到没有合并啊啊，这个是要注意的地方，这个是读优化啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111508650.png" alt="image-20240311150847465"></p>
<h5 id="Read-Optimized-Queries是对Merge-On-Read表类型快照查询的优化"><a href="#Read-Optimized-Queries是对Merge-On-Read表类型快照查询的优化" class="headerlink" title="Read Optimized Queries是对Merge On Read表类型快照查询的优化"></a>Read Optimized Queries是对Merge On Read表类型快照查询的优化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">好，那下面有一个具体的对比啊，下面这张图就是对于MOR表而言，它的快照查询与读优化的一个对比。那么在呃从10点01分开始，差不多每1分钟进行了一次增量提交是吧？那么在10点05分的时候触发了一次compassion，大家注意compassion，那触发compassion之后有什么特点呢？就是会生成一个新的parquet文件，哎，那对应的是哪一个呢？哎，文件组一、文件组2、文件组3。在10点05分的时候，compassion之后生成的基本列文件啊用绿色表示。好，那我们接着往下看，在06分、07080910的时候分别进行的都是什么？增量提交增量提交每一次提交是不是生成一个点log文件，对吧？啊，所以你看对于文件组一来讲，它包含了呃06的点log、08点log、09点log。那对于文件组二呢，它有07的、有09的、有10的点log对吧？那对于文件组四三啊，压缩之后他没有新的数据来。文件组四一开始是没有的，但是在06分和10分的时候都是呃插入的数据嘛，相当于是对吧插入的新插入的数据。好，那这一块呢它就有一个点log，一个点log能理解吧？</span><br><span class="line"></span><br><span class="line">好，那接下来就是什么呢？呃，我们在10分的时候进行查询，这个是什么？读优化的方式。你去查呃按照10点10分这个这一次commit为基准的话，你能查到什么呢？读优化视图，咱们说了他只查parquet文件，也就是说绿色的这三个能查到，所以你看是123，并且这是05分的时候，compassion那文件组四的这几个点log它就查不到了。查不到。</span><br><span class="line">那如果是快照查询，它所有的都能查到啊，因为它是全量最新，能理解吧？这个图想表达的就是这么一个意思。</span><br><span class="line"></span><br><span class="line">好，那这个读优化视图是专门针对MOR表的一个快照查询的优化。为什么要这么做呀？刚才也讲了，我读的不一定是全量最新，那既然如此还要他干嘛啊？其实就是为了查询效率。你想想如果我是都是快照查询MOR表，每一次查询我都要进行一个读时合并，代价还是有点重的，我的读取延迟还是比较大的那如果这个时候我能接受呃稍微的滞后，也就是说即使不是全量最新，那也是相对来讲比较新的吧。退而求其次嘛，但是我的效率能有一个质的提升啊，主要的目的在这里啊。</span><br><span class="line"></span><br><span class="line">那你看呃数据延迟呢是比较低啊，那读优化呢是比较高，查询延迟呢快照比较高，因为它要现合并啊，那读优化呢比较低，它直接读part ket啊，他不读log。好，所谓的数据延迟这里怎么理解呢？也就是说我现在10点10分的数据已经写入了，对吧？比如说就就刚才这个地方呃，10点10分一次提交啊，往文件组4写入了点log文件，但是我却查不到。我现在10分钟去查，我查不到，那不就是有延迟吗？我可能在等下一次compassion这一些数据才可见，对吧？下一次compassion之后，这些呃合并之后这里才可见啊，这个就是所谓的数据延迟嘛啊不是立马就能查到嘛。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111519712.png" alt="image-20240311151920329"></p>
<h6 id="不同表支持的查询类型"><a href="#不同表支持的查询类型" class="headerlink" title="不同表支持的查询类型"></a>不同表支持的查询类型</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么看看不同的表支持的查询类型啊。其实对于COW表来讲呢呃就简单的两种。一个是全量最新的快照，还有增量两种查询。</span><br><span class="line"></span><br><span class="line">对于MOR表就除了这两个多了一个读优化</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403111535059.png" alt="image-20240311153517398"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">智汇君</div><div class="post-copyright__author_desc">路漫漫其修远兮，吾将上下而求索！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/01/17/Hudi 尚硅谷大数据技术之数据湖Hudi-2/')">尚硅谷大数据技术之数据湖Hudi-2</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tech智汇站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>大数据<span class="tagsPageCount">31</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/17/git/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/17/github%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">github相关问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1</div></div></a></div><div><a href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi</div></div></a></div><div><a href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20spark%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 1</div></div></a></div><div><a href="/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-1/" title="尚硅谷大数据技术之数据湖Hudi-1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">尚硅谷大数据技术之数据湖Hudi-1</div></div></a></div><div><a href="/2025/01/17/Hudi%20%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3/" title="尚硅谷大数据技术之数据湖Hudi-3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">尚硅谷大数据技术之数据湖Hudi-3</div></div></a></div><div><a href="/2025/01/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8%20Hive%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9%20%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/" title="大数据开发工程师-第九周 Hive扩展内容 常见数据压缩格式的使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">大数据开发工程师-第九周 Hive扩展内容 常见数据压缩格式的使用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">智汇君</h1><div class="author-info__desc">路漫漫其修远兮，吾将上下而求索！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/contact/" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(/img/博客微信公众号图片.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-2"><span class="toc-number">1.</span> <span class="toc-text">尚硅谷大数据技术之数据湖Hudi-2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%B4TimeLine"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">时间轴TimeLine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80File-Layout"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">文件布局File Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">文件管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">索引选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">全局索引与非全局索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.1.3.4.</span> <span class="toc-text">索引选择策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8B%E5%AE%9E%E8%A1%A8%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0"><span class="toc-number">1.1.1.3.4.1.</span> <span class="toc-text">对事实表的延迟更新</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8B%E4%BB%B6%E8%A1%A8%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.1.1.3.4.2.</span> <span class="toc-text">对事件表的去重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E7%BB%B4%E5%BA%A6%E8%A1%A8%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%9B%B4%E5%88%A0"><span class="toc-number">1.1.1.3.4.3.</span> <span class="toc-text">对维度表的随机更删</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">表类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#COW%E8%A1%A8"><span class="toc-number">1.1.1.4.1.</span> <span class="toc-text">COW表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MOR%E8%A1%A8"><span class="toc-number">1.1.1.4.2.</span> <span class="toc-text">MOR表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COW%E4%B8%8EMOR%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.4.3.</span> <span class="toc-text">COW与MOR的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B-Query-Types"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">查询类型(Query Types)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Snapshot-Queries"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">Snapshot Queries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Incremental-Queries"><span class="toc-number">1.1.1.5.2.</span> <span class="toc-text">Incremental Queries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Read-Optimized-Queries"><span class="toc-number">1.1.1.5.3.</span> <span class="toc-text">Read Optimized Queries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Read-Optimized-Queries%E6%98%AF%E5%AF%B9Merge-On-Read%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%BF%AB%E7%85%A7%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.1.5.4.</span> <span class="toc-text">Read Optimized Queries是对Merge On Read表类型快照查询的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%A1%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.5.4.1.</span> <span class="toc-text">不同表支持的查询类型</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/python%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95%E7%A7%AF%E7%B4%AF/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/14/python%E5%B8%B8%E7%94%A8%E7%94%A8%E6%B3%95%E7%A7%AF%E7%B4%AF/" title="无题">无题</a><time datetime="2025-07-14T08:25:16.017Z" title="发表于 2025-07-14 16:25:16">2025-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/11/%E9%9D%A2%E8%AF%95%20Hbase/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/11/%E9%9D%A2%E8%AF%95%20Hbase/" title="无题">无题</a><time datetime="2025-07-11T09:24:44.656Z" title="发表于 2025-07-11 17:24:44">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题">无题</a><time datetime="2025-07-02T10:28:32.791Z" title="发表于 2025-07-02 18:28:32">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"/></a><div class="content"><a class="title" href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1">2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1</a><time datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2022黑马数据湖架构开发Hudi"/></a><div class="content"><a class="title" href="/2025/01/17/Hudi%202022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi">2022黑马数据湖架构开发Hudi</a><time datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="智汇君" target="_blank">智汇君</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">40</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 0.88rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 0.88rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 0.88rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>31</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 0.88rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 0.88rem;">廖雪峰<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>10</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("24/12/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 智汇君 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("24/12/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4792307_02gxbpyxcpwp.js?spm=a313x.manage_type_myprojects.i1.10.56323a81KZGFDE&amp;file=font_4792307_02gxbpyxcpwp.js# 阿里图标symbol 引用链接，主题会进行加载 symbol 引用"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>