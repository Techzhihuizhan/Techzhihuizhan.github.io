<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>尚硅谷大数据技术之数据湖Hudi-3 | Tech智汇站</title><meta name="keywords" content="大数据"><meta name="author" content="智汇君"><meta name="copyright" content="智汇君"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="尚硅谷大数据技术之数据湖Hudi-3"><meta name="application-name" content="尚硅谷大数据技术之数据湖Hudi-3"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="尚硅谷大数据技术之数据湖Hudi-3"><meta property="og:url" content="http://example.com/2025/01/17/尚硅谷大数据技术之数据湖Hudi-3/index.html"><meta property="og:site_name" content="Tech智汇站"><meta property="og:description" content="尚硅谷大数据技术之数据湖Hudi-3数据写 123456789那我们来聊一个hoodie当中的一个核心操作，也就数据写入的一些操作啊，还有一些基本的原理，这个大家就视情况来了解。如果你仅仅是应用呢，你这一块就简单搂一眼就可以。如果你想啊多了解深一点，那你就好好去了解这一块，研究这一块。啊那我们基本要"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta property="article:author" content="智汇君"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg"><meta name="description" content="尚硅谷大数据技术之数据湖Hudi-3数据写 123456789那我们来聊一个hoodie当中的一个核心操作，也就数据写入的一些操作啊，还有一些基本的原理，这个大家就视情况来了解。如果你仅仅是应用呢，你这一块就简单搂一眼就可以。如果你想啊多了解深一点，那你就好好去了解这一块，研究这一块。啊那我们基本要"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/17/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":270},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 智汇君","link":"链接: ","source":"来源: Tech智汇站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Tech智汇站',
  title: '尚硅谷大数据技术之数据湖Hudi-3',
  postAI: '',
  pageFillDescription: '尚硅谷大数据技术之数据湖Hudi-3, 数据写, 写流程(UPSERT), COW, MOR, 写流程(INSERT), COW, MOR, 写流程(INSERT OVERWRITE), Key生成策略amp删除策略, 数据读与Compaction, Hudi集成Spark, 环境准备amp启动Shell, Shell方式_准备及插入数据, Shell方式_查询数据amp文件命名源码, 转换成DF, 查询, 时间旅行查询, Shell方式_更新数据amp时间旅行查询, Shell方式_增量查询amp指定时间点查询, 增量查询, 重新加载数据, 获取指定beginTime, 创建增量查询的表, 查询增量表, 指定时间点查询, 实操, 第一次插入后查询, 第一次更新, 时间旅行, 第二次更新, 增量查询 一次插入 两次更新 查第一次更新之后, 增量查询 一次插入 两次更新 查第一次插入之后, Shell方式_删除数据amp覆盖数据, 删除数据, 覆盖数据, 查看当前表的key, 生成一些新的行程数据, 覆盖指定分区, 查询覆盖后的key发生了变化, SQL方式_环境准备amp创建表, 环境准备, 创建表, 创建非分区表, 创建分区表, 在已有的hudi表上创建新表-非分区, 在已有的hudi表上创建新表-分区表, 通过CTAS(Create Table As Select)建表-分区, 通过CTAS从其他表加载数据, 插入amp查询, 更新数据_Update, 更新数据_MergeInto, 删除amp覆盖数据, 修改表结构、分区amp存储过程尚硅谷大数据技术之数据湖数据写那我们来聊一个当中的一个核心操作也就数据写入的一些操作啊还有一些基本的原理这个大家就视情况来了解如果你仅仅是应用呢你这一块就简单搂一眼就可以如果你想啊多了解深一点那你就好好去了解这一块研究这一块啊那我们基本要知道的是的写入操作啊大概可以分为三大类啊第一类是所谓的也就是说插入或者更新那这个时候它是严格依赖于什么呢索引它是必须依赖于索引的也就是说的必须依赖于索引啊这也是的一个特点特性高效的啊还有结合索引另外呢他会去标记你是插入还是更新的数据另外呢根据不同表不同场景啊也就是说他有一定的策略啊去写做一些写入的行为啊这是的我们具体看啊另外一种就是就是指追加的方式其实啊那就是跳过索引啊就是你这个索引我不管了反正我有新的数据来我管你是什么样的我都直接就是追加追加追加追加啊但是这个呢嗯回头你要自己去做一个去重的一个处理啊还有一种是是那个批量插入批量插入这种是后面新版本提供的一种呃优化功能啊这样的性能会更好它会做一个排序然后进行一个写入啊它是对大数据量的表呃初始化的话用这种方式会更好一点啊嗯而且对文件大小的限制是最好的一个效果行那就是粗略的知道有有有对吧啊那最重要的默认的就是这个是我们一定要了解的写流程好那我们具体来看呢咱们就按照两种表来解读第一种是表它怎么做的第个呢就是怎么做的其实前面多多少少聊过我们再捋一遍啊对于表我们进行一个它是先什么呢按先对我们的这一批数据按照指定的去重举个例子啊比如说是这批数这是一批数据对吧啊那如果我们指定的第一列为我们的键那就就这个值就是这样了对吧那比如说你数据还有一条是不是有重复啊啊它会先按照指定这个哎先是给你去个重啊然后呢对这一批数据创建索引所以我们讲的就是呃对吧加上分区路径啊然后呢跟我们的文件文件组的呃形成一个映射关系啊也就是说会记录哎这一条数据呃对应的是哪一个啊行这个索引细节不聊了呃另外这个索引还有一个作用是区分我们是更新还是的呢就表示这个这个是第一次写入啊如果不是第一次写入那就是需要更新嘛这个好理解吧也就是通过创建索引并且区分更新还是插入那接下来既然要区分那就有不同的处理方案了一个是对于一个对于的如果是更新了他会找到这个啊咱们这个对应的这个呃文件片咱们所以不是维护了这个跟文件片的关系嘛对吧啊他能找到他找到这个文件片之后啊啊不是文件组啊那文件组再找最新的文件片然后再找到里面的文件文件什么意思呢我给你说啊就是它的呃就是如果你看到说什么基本文件呢列文件呢呃指的都是这么一回事儿就是指的这种文件好吧并且呢做一个什么完之后写入到新的什么也也就新的文件片就生成新的嘛这个就是更新那如果是纯粹的插入呢我不是更新呢啊他就有点不一样了呃他会先扫描当前分区下面的小文件也就是说有一个阈值啊这个参数可以控制比如说是十兆哎我说小于十兆的这个文件呃如果有那我这个插入的消息我就往里面去写往里面追加啊如果没有这种小的文件我怎么办呢啊没有小的让你蹭啊你蹭不了啊那怎么办那你就自己来呗你写一个新的不就完事了吗啊就写入一个新的文件组文件组里面的一个新的文件片能理解吧也就是说有地方蹭那就蹭啊没地方蹭就自己去开一间对吧啊这个简单啊这是那就麻烦了啊也不是麻烦啊就是跟索引有很大关系啊的话来如果是的写入啊那也好理解啊哪里呃首先还是一样根据咱们指定的数记录键或者叫数据键进行一个去重就刚才例子啊有啊呃然后再来一条你指定第一个字段为为这个键的话啊那就先按照这个键去重哎哎发现有两个一哎去个重我只保留一个啊好然后呢同样是什么创建索引然后这个索引也会区分是还是这个这两步跟是一样的啊是一样的好接下来就不一样了啊它对的跟分别是怎么处理呢我们来看啊对于如果因为正常咱们增量提交嘛是不是要写点文件前面我也简单提了得区分能不能建索引是不是如果是不可建索引也就是你用的是布隆啊说白了就是布隆嘛这也是默认的对不对他会干什么呢默认去分区内最小的如果建不了索引他就去蹭别人的能理解这个意思吧你建不了索引那我就去蹭别人了这是插入的消息啊然后蹭别人之后跟别人合并成新的一个文件片啊那如果没有小的基本文件可以蹭那就一样自己写一个新的呗新的文件组里面的新的片的新的这是见不了索引的时候啊就生活不能自理呗那如果你能够建索引也就是说如果你用的是对吧咱们就直接把这些联系起来你就好理解了如果你用的是它基于状态可以对建索引它直接干嘛呢它是追加文件什么样的呢小的如果没有小的文件可以蹭那就自己开个新的呗新的文件组新的文件片新的好吧嗯能不能理解这个意思啊简单来讲如果是插入消息呃索引啊就区分可不可以建所以不可见他就去蹭人家的小然后合并成新的啊如果蹭不了就自己写入一个新的新的文件组就行了啊如果可以见索引引它也是蹭但是它蹭的是什么小文件如果蹭不了就自己写一个新的啊一样的道理啊简单理解就是这样吧那如果是更新的消息这个就简单了你也不用说蹭不蹭的了你更新你就要找到你要你的老数据在哪对不对啊它会写对应的这个还有对应的文件片啊就老数据所在的位置啊直接什么呢呃最新的对吧那如果刚巧是最小的小文件也会进行一个合并生成新的文件片啊这个就你就不用管这个细节了啊反正如果是更新消息那就找到对应的是哪个组的啊你是要更新的数据在哪个组啊然后对应的新的文件片然后去追加就行了因为你一直追加你是不是不可能无限膨胀啊对吧你一直在追加对吧所以它达到一定的阈值会做一个滚动啊滚动生成一个新的好吧这个是的一些细节其实你说它有用吧也没用但是方便我们去理解呃一些现象比如说你去看的时候啊就看到那些文件的怎么有时候几个有时候又是怎么样怎么样对吧啊去方便理解写流程呃那其他的像这种写入流程就简单了啊咱们快速过啊啊还是区分两种表跟表啊那如果是它一样的先对呃通过这个啊进行一个去重啊你也可以选择不去重啊大家注意是可选的另外呢我们前面讲了啊不会创建索引呃接下来就是蹭的问题了啊如果有小的基本文件那就去合并啊生成新的否则呢没有小的可以蹭就写新的呗啊这个就了很粗暴很简单也简单一样我们可以按照这个去重也是可选也不创建索引那接下来无非又是那一坨式就是你这个文件有没有索引啊能不能索引对吧如果可索引并且有小的可以蹭那你就去追加啊如果没有那你就写呗写呃追加或者写新的一个文件呃这边是为什么是或写最新的文件因为咱们前面讲的不是有一个什么呢滚动吗就是说有大小限制啊好那么如果这个也不能够索引那直接就自己写个新的就完事了啊新的文件片大家注意是新的文件片啊写流程啊那呢这个是后面才支持的一个功能啊叫覆盖写呃他会在同一个分区中创建新的文件组并且呢现有的文件组被标记为删除这个就是区别它创建新的同时将旧的组大家注意它操作对象是组啊啊它将旧的组标记为删除啊根据新记录的数量创建新的文件组啊说白了就是重来啊那这边有一个小案例大家看就行了啊呃在插入之前呢这个时候分区有一个文件组一文件组对吧啊他们有一个版本的都有一个的文件啊那如果你是插入相同数量的记录覆盖也就是说原先有呃这个组有十条数据这个组有十条数据那这个时候你是的还是条写过来这个时候它会生成新的组跟新的组四啊并且是呃也各有一个的然后呢老的一跟二要被覆盖的这两个就在原数据中被标记为无效标记为删除就这么简单就是这么粗暴啊生成新的再把脑袋干掉过河拆桥对吧就这么简单那插入如果是更多的记录那其实没什么营养啊比如说原先只有条你覆盖写入是条那无非就是生成更多的新的什么文件组那同样的呢你要将呃翻译一翻案就老的在后原数据被标记为无效就是老的又被过河拆迁了啊好吧那其实这几个只是啰嗦一下啊啰嗦一下那如果是表有什么特点一样啊一模一样好吧这个就不啰嗦了嗯你看他们执行方面非常相似啊而且不会干扰咱们的这个呃然后可以减少文件的大小啊对吧因为你重新规划了嘛就相当于说你你旧改嘛你家老的自建房都推都都拆了然后通过规划去盖房子那肯定是呃空间使用更合理嘛是不是啊不浪费空间嘛啊行不需要更新关键路径中的外部索引对吧我不用去更新收引好吧还可以扩展清理策略呃缺点呢也有需要转发以前提交的原数据另外呢呃还有一些小问题当然这个缺点是在呃官方的一个呃啊设计当中的一个考虑啊这个咱们现在也不用去操心也就是说有一定的小代价吧一个是转发元数据第二个呢是将忽略老数据呃但是这个事不用我们关心他呃会有方案来忽略他们这个就简单介绍一下啊那咱们在这里面最常用的还是这个什么这是最重要的一个特性生成策略删除策略那其他的一些小东西咱们就简单了解一下就可以了啊比如说有一个的生成策略咱们前面一直讲索引对吧索引对应的是不是有个啊那由咱们的记录键跟分区路径组成的那这个地方这个记录键那可以怎么做啊然后分区路径又有哪些限制啊就简单说一下那首先这个是可以有多个字段组合的啊比如说我们的字段有啊啊然后比如说性别这么多个来几条数据吧一啊张三性别男呃年龄十八啊比如说这种数据你可以只以一个字段作为你也可以拼接这个跟性别作一个啊也可以啊就联合的的另外这个分区路径呢是可以有多个字段组合的呃多个字段组合呢为什么呢因为你分区是不是可以有多级分区啊也就多层目录呗多层那这个也是允许的另外呢如果你是非分区表也是可以的啊这个都无所谓啊另外就是比较重要删除策略对于数据的删除删除大家简单呃大家联想一下怎么删除数据呢嗯对吧或者说我在某一张分区表某个分区我里面有啊某呃别管是不是了啊就比如说某个分区下面有呃五条数据我想把第三条数据删了怎么办呢如果以前的传统做法你是不是你是不是一个进去是不是就把删给给删了对吧但这样大家操作比较重了如果我这个数据有一条你只删一条再写一遍啊没必要啊所以它有两种第一种呢是逻辑删我将字段全部标记为就可以了是吧除了之外的其他的我都全部标记为这是逻辑上的删除那第二种呢就是物理删就正儿八经删啊通过配置一个删除所有的输入记录就对吧另外一个就是利用它的机制指定我们的类为一个空的这样的话它会删除所有的记录啊另外呢还有一种方式呢就手动添加一个字段添加这个字段呢就是固定的字段名啊添加这个字段然后就可以了啊就标记为删除了这种是一些删除的策略啊那么整体来看呢核心优势最重要的是什么就是啊那基于咱们对更新也好删除也好它非常高效为什么呢索引对不对索引啊所以前面聊了这么多呀描了这么多概念其实最最重要的啊大家有必要去了解的好好理解的一个是什么时间轴这是基本的吧啊文件布局要了解吧那这个索引对不对表类型查询类型简单了解啊因为你回头一直用啊你要去用你肯定会涉及到那写操作最重要的就是这个啊就够了数据读与那接下来就剩一点小概念了啊数据读这一块前面都其实都介绍过了我不再啰嗦了就一个快照读取一个增量读取那还有一个叫流读那这个主要是在版本之后的这一边支持流读那当然后面我们也会去演示啊有一些实际案例去操作啊真正的是一个流式的读取它是会定期监控新增的改动文件将读取任务下派对吧给读了这个这个后面再唠吧你简单留个印象那我们聊一个来一起回忆一下它是什么表有的呀表啊记住啊不用那如果呃我是数据刚刚开始写那这个时候是不是没有也就是没有那这个时候你要就是什么呢它走的是类似表呃这种流程直接什么所有的文件生成一个文件就这么理解就完事儿了那如果呃现在已经有文件并且呢也有那怎么办呢啊他会先什么呢其实就是一个流程他会先读文件建立一个索引再读什么呢老的文件建完索引读读完读之后呢将它俩合并到新的一个文件啊就这么简单嘛啊另外要想强调的是咱们这个是可以走异步的什么叫异步啊啊我相信对同步异步这个概念应该还是有些人搞不太明白这是呃应该说作为一名开发基本的一人基本都要了解的吧那所谓的异步就是各管各的呗对吧就有点像咱们田径比赛当中的什么呢啊比如说米比赛吧啊是不是每个赛道一名选手对不对那你开始之后啊裁判发令之后是不是各跑各的你总不会说你跑得快你跑到前面说哎我等你一会儿你没有这回事吧你专心跑你自己的就行了是不是这是一个异步呢那还有一种同步你可以怎么理解米接力啊米接力啊如果上一棒米没跑完你下一棒不能跑你是不是得等啊是不是得阻塞呀啊那一般来讲这么来粗糙的理解就够了啊那这边的异步指的是什么呢呃就是咱们写入的这个动作跟我们执行他俩之间不用互相看脸色不用互相等待啊由你自己的条件来触发执行就行了我写入管我写入的就行了嗯那这个的呃的策略可以按照呃几次或者说按照固定的时间来触发这是有不同的策略对吧那一般来讲呃会用数量更多一点啊数量更多一点行这是咱们聊的一些小概念了后面几个就简单过啊接下来我们动手体验一下跟集成来操作护底表这么一个操作那么首先呢咱们还是要回顾一下底支持的一个版本那么前面也跟大家聊到了不同的呼底版本支持呢系列是不一样的啊那这边我列出了对于三的支持啊那要注意在当中呃支持的是没有啊没有那如果你想要你可能呢你得用最新呢只能用到当然呢对于二系列还支持啊这个我就不啰嗦了那一些新特性啊也是在才支持的那本教程呢咱们就以的为例啊那首先需要大家先去安装部署一下那么你可以通过这个地址直接去下载下来那我这边是有了下载下来之后呢你将这个踏包呃通过踏命令去做一个解压解压到对应的目录就可以了那么大家可以看一下我的下面已经解压了一份就是这个啊另外呢解压完之后最好还是配个环境变量啊方便使用哎点啊我习惯上写在这个文件里面在这呢我已经配了一个那这个路径啊写成你的路径就可以了修改完环境变量不要忘了做一个常规操作啊扫描一下这个环境啊那就可以了那么接下来呢呃我们需要集成只需要做一件事情就可以了将我们编译完的包放到的呃依赖路径下面即可啊那在哪呢我先把我老的那个删掉啊好我们听到沃尔弧底呃点一二里面有一个在这里呢有一个谋害啊蝶这个那么进来之后呢有一个就是咱们编译完的一个路径那里面有一个架包对吧嗯呃呃咱们要的是上面这个呃名字最短的这个就是好那我们拷贝它拷贝到点里面的驾驶放到这个里面就可以了啊我们拷贝过去那拷贝完事儿之后啊我们搂一眼吧那这个包已经在这里了这是我们编译完成的包那么接下来你我们只需要去启动我们的就可以那通呃呢怎么来操作这个护底呢呃你可以直接通过直接去快速的体验那你也可以去到你编呃打写成一个代码然后打成价包的方式去提交也可以啊那我们先介绍一下这个渲染的方式啊这样比较快啊快速的体验那么大家别忘了这个它对于依赖的加载它是静态加载的也就是说如果你已经是启动了一个呃什么样的集群比如说是真的弄的那么你添加新依赖需要重启一下它才能够加载到啊行这个不啰嗦了那么接下来呢大家注意这个启动命令啊里面呃启动的时候不同的版本它可能写法不太一样啊包括它的类不太一样这个大家可以去官网查阅啊有一个指南你看一下你对应版本有什么区别啊那如果是跟我一样就行了那么大家看一下啊然后呢指定几个参数那这些参数分别是什么哎一个序列化器指定为第个呢呃使用了一个啊咱们用的是什么还有一个呢是一个拓展项啊用的是啊指定这三个就可以了那么如果你需要用到之类的啊呃你记得启动一下那如果没有的话你不启动也行啊这个我就不不去啰嗦了那这个命令啊你就不要手敲了吧这个可是全类名啊啊也是一个固定写法啊如果你有其他参数要指定再去指定就好了啊咱们快速演示啊好回车好那这样就进入了这个交互式的命令行了就可以我们来一个快速的体验了集成环境准备启动接下来我们动手体验一下跟集成来操作表这么一个操作那么首先呢咱们还是要回顾一下支持的一个版本那么前面也跟大家聊到了不同的呼底版本支持呢系列是不一样的啊那这边我列出了对于三的支持啊那要注意在当中呃支持的是没有啊没有那如果你想要你可能呢你得用最新呢只能用到当然呢对于二系列还支持啊这个我就不啰嗦了那一些新特性啊也是在才支持的那本教程呢咱们就以的为例啊那首先需要大家先去安装部署一下那么你可以通过这个地址直接去下载下来那我这边是有了下载下来之后呢你将这个踏包呃通过踏命令去做一个解压解压到对应的目录就可以了另外呢解压完之后最好还是配个环境变量啊方便使用哎我习惯上写在这个文件里面在这呢我已经配了一个那这个路径啊写成你的路径就可以了修改完环境变量不要忘了做一个常规操作啊扫描一下这个环境啊那就可以了那么接下来呢呃我们需要集成只需要做一件事情就可以了将我们编译完的包放到的呃依赖路径下面即可下面有一个在这里呢有一个模块那么进来之后呢有一个就是咱们编译完的一个路径那里面有一个包对吧咱们要的是上面这个呃名字最短的这个就是拷贝到放到这个里面就可以了啊我们拷贝过去那么接下来你我们只需要去启动我们的就可以那呢怎么来操作这个护底呢呃你可以直接通过直接去快速的体验那你也可以去到你编呃打写成一个代码然后打成包的方式去提交也可以啊那我们先介绍一下这个的方式啊这样比较快啊快速的体验那么大家别忘了这个它对于依赖的加载它是静态加载的也就是说如果你已经是启动了一个呃什么样的集群比如说是真的弄的集群那么你添加新依赖需要重启一下它才能够加载到啊行这个不啰嗦了那么接下来呢大家注意这个启动命令啊里面呃启动的时候不同的版本它可能写法不太一样啊包括它的类不太一样这个大家可以去官网查阅啊有一个指南你看一下你对应版本有什么区别啊那如果是跟我一样就行了针对官网还有一个要指定啊那么大家看一下啊然后呢指定几个参数那这些参数分别是什么哎一个序列化器指定为第个呢呃使用了一个啊咱们用的是什么还有一个呢是一个拓展项啊用的是啊指定这三个就可以了那么如果你需要用到之类的啊呃你记得启动一下那如果没有的话你不启动也行啊这个我就不不去啰嗦了那这个命令啊你就不要手敲了吧这个可是全类名啊啊也是一个固定写法啊如果你有其他参数要指定再去指定就好了啊咱们快速演示啊好回车好那这样就进入了这个交互式的命令行了就可以我们来一个快速的体验了方式准备及插入数据那接下来我们要做什么事儿呢哎就是呃准备一些数据啊准备一些咱们来测试的一个数据啊数据有了之后呃来具体的操作一下各种操作像插入啊查询啊更新啊还有增量查询对吧啊增量的那还有指定时间点的查询啊删除覆盖等等这些方式那么这边呢不建议大家手敲了为什么呢啊有一些需要导入的包啊那这一块呢咱们就直接先拷贝啊来拷贝这些好那都完成之后接下来我们是呃通过它自带的一个类可以去生成数据那指定一个变量是表明那还有呢指定一个它的数据的路径那这一边为了快速演示咱们就用一个本地的就好了啊那么大家注意这个数据生成器这个类是谁呢是提供的啊提供的好了那么接下来呢呃我们就来演示一下插入数据表我们没有创建对吧呃无所谓啊第一批写入它会判断表是否存在不存在它就会自己创建的啊所以我们就直接写就可以了那么看一下这个写法啊首先呢我是将呃生成了什么呢十条数据啊生成十条数据然后呢做一个插入啊这是它固定它的一个啊这个就按照这么写就可以了然后呢将它转成一个啊是字符串啊之后呢将这个数据读成什么呢通过上下文然后并行化读取读取成一个什么呢读取进来啊那分区数我指定为啊然后呢直接去就可以了那读成了一个那通常来讲我们对操作都是用的语法啊你可以用去操作啊也可以写啊好来我们把它拿过来稍等一会儿好那其实上面这里就是生成的数据和呃我们转成了这个大概就是我们看一条就好了啊到这里啊这是一条数据啊有啊啊啊有啊对吧等等一些字段这是一个出行的一个交通数据好那接下来我们要将这个里的数据写入到里面那怎么写呢哎大家看啊是其实这个写法如果熟悉应该都熟了呃通过的方式去写就可以了那只要格式指定为那之所以能够指定为就是因为咱们已经集成好了那个包你已经放进去了那它就能识别这个格式接下来下面的这一些写法是特有的啊跟集成的时候特有的一些写法呃那这边我们是设置了一个啊快速入门的一个案例配置啊就简单的配置另外呢有几个东西先给大家讲一下一个叫这个东西是什么呢呃就是可以理解为预聚合为什么呢预聚合字段这个东西主要是通过来去重使用的另外一个东西是不是叫啊啊这个就是咱们前面一直在在一直在讲的指定为这个字段对吧那接下来就讲讲这个有什么用啊举一个例子啊比如说我的呃是呃有一条数据是呃那么呃值是比如说然后这个时间戳比如说是十那么如果我又来了一条数据其实这个语句和字段就指定了哎我当我的相同的时候因为我们是要保持唯一性对不对那如果出现重复它取哪一条啊哪个值它会取预聚合字段这个值较大的那个数据比如说有这两条数据啊都是这样啊都是重复了对吧那么它就会取下面这条字段啊假设咱们指定的是啊它就取大的啊所以这个可以简单理解为就是去重的时候用啊所以你就得呃考虑这个预聚合字段用什么比较合适啊通常来讲常规的就是用一个时间戳字呢就就比较理想啊那这个你也得去考虑啊用什么样的好一点最好你不要说出现大量重复的那就不合适了啊就类似于你去设计数据库一张表主键你来怎么设那其他的就没什么了这个是一个什么分区的字段啊用哪一个作为一个分区字的然后呢表名就没了然后呢模式选择一个覆盖然后保存到路径这个路径就是表的路径啊那你看我们上面已经定义了一对吧这个这是一个基本路径对吧路径就写到以表名作为一个文件夹的名称就可以了好吧好那就是关于这几个基本参数的解释那我们来做一下哈嗯好等他执行完执行完了对吧那么接下来我们怎么看呢在我们指定的这个路径下面应该是有的目录生成的表的目录还有它对应的什么原数据目录啊数据目录啊然后我们来搂一眼啊这个路径我们定义的是本地文件系统下面来我们瞅瞅一眼然后呢看一眼啊这个有点多对吧但是我们看到了有一个什么大家可以看到现在的这个文件夹是什么东西呢啊就是分区就是我们的分区目录呃这个就是亚洲对吧这个是美洲啊我们的分区是按照这一来的我们看一下这个数据啊这里有一个字段叫做啊我们指定它为分区字段对吧它的只有什么呢什什么啊美洲的啊什么什么什么你大家可以看到这个值是不是什么嵌套的有三层对吧那我们随便看一个吧比如说这这是其中一个分区啊是一级分区啊哎你是不是看到又有一层文件夹了那是因为咱们使用了多级分区啊也就是说多级目录了啊每周下面的这里还有这里啊哎随便看一个在里面还有一层对吧还有一层好再来再看就没了吧这里面只有一个什么文件点方式查询数据文件命名源码转换成那现在有了表我们来尝试着查询一下那查的话怎么查呢其实还是一样从去读取对应路径下的表啊这个这个我们直接去嘛啊直接之后呢格式指定为啊同样的道理由于我们集成的那个包所以他就能够识别了另外不要忘了他需要写一个也就写到对应的表路径啊你要读取的表的表路径啊一定要写到表路径啊然后呢我们需要呃我们再把它创建成一张临时的视图啊起个名字那这边要注意的是什么呢这张表我们知道分区字段它里面包含了多级分区啊对吧我们是有三级分区的那如果是老版本的以前的呃这个时候我们需要在表路径然后在拼接上呃这样子也就是说有几层路径你就要拼接几层那么当前版本就不需要它自己会去识别啊这是一个小事情也就是说你加载路径必须把每一级的分区路径都得表示出来啊用星号去拼接啊查询那我们就快速的把它注册成为一个啊好直接还是粘贴就行了啊这种写法就没必要去敲了啊浪费时间啊就很简单的语法好有了之后我们是不是可以直接查了呀啊你可以用去也可以用的语法来写啊然后可以写一个语句啊然后再一下啊我们搂一眼吧啊这个也没必要敲了那字段都是我们那个模拟数据我这边想说明的一点是什么呢我我尽量缩小哎看不清楚啊我想说的是其实每张呼底表它都有几个隐藏字段分别是什么呢你看那么你看这个是什么这就是我说的拼接年月日时分秒那我们仔细看一下啊这是年月日时分秒毫秒对吧它是直接拼在一块的啊而不是说距离年有多少时间戳好吧然后呢还有一个的一个序列号啊其实它基本就是一个时间戳然后再拼接上其他东西还有这个是什么这个是不是由我们去写入手指定的就是用的啊还有呢分区路径啊那这个是多级的看到没有再一块看到啊就就文件名对吧前面基本有几个五个隐藏字段啊一个小事情这是一个正常的查询你就会就就会了接下来呃说白了咱们的集成只是放一个包然后格式指定为还有一些配置项该指定的去指定就了接下来就是正常的一个操作了所以对大家来讲应该是没有什么学习成本的啊无非就是前面我们花了大量的时间去讲那个核心概念啊那些你把它理解就了用起来的话倒是没有什么难度啊没有难度时间旅行查询表示另外一个事儿呢就是还有一种查询方式是叫时间旅行的查询什么叫时间旅行啊啊就是我要查询指定时间点的一个就比如说呃现在的都多次了啊时间分是咱不是有个时间线嘛对不对时间轴嘛那我们说呢是一个一个的对不对啊每个都有对应的什么呢一个是它的的时间还有呢他的动作还有他的状态是不是啊那这个时候已经到了以后了那如果你想查的时候这个时刻的呃数据它的状态也是可以的你只需要指定一个的时间即可啊那我看一下咱们目前的这个应该都是一一回事儿啊应该都是一回事儿呃那具体呢就是这么一个配置项就可以了那我们试一下呗但是这个时间戳不对啊这个是以前的那我想想啊我们现在都一样呃那也简单怎么简单呢我们只需要再重复执行一下前面这个就行了就插入数据我们再插入一遍呗再插入一遍啊就这这呃我们改成就可以了呗稍等一下嗯好不就了吗说但是咱们一会儿再来吧因为后面咱们要讲更新数据更新数据其实有点类似于插入新的数据那回头咱们就要了啊这个咱们先呃简单理解一下一会儿再来玩嘛啊讲到更新的时候再来玩这个事儿啊好那接下来我给大家补充一点啊就是咱们可以看到这个地方这个文件前缀这么长那它到底是什么意思呢那我听我一一道来吧啊那么注意它的连接符是什么是下划线也就是说咱们根据下划线分成几块来看啊哎我先在这里切一刀呃然后这个下划线再切一刀哎然后这个后缀切移到它其实是由四部分组成第一部分是什么呢这么长的一串东西就是咱们前面一直讲的还记得吧咱们聊到索引的时候讲过呀呃每一个它它里面是不是按照文件组来组织的每一个文件组有一个唯一的啊当这个呃生成这个文件组生成的时候这个就已经固定了不会再变了啊它默认情况下是通过来取的啊也就是挺随机的啊然后中间这个东西呢嗯怎么理解呢这是它拼接了一个啊你可以不用管呃那后面这个东西应该就很熟了吧这个其实就是也就是说咱们那个啊好那最后一个是什么就后缀啊由于咱们它只有一个对吧没有什么点啊就简单了那如果你要看源码也简单啊呃这样呃我这边有一个写好的你直接搜什么呢我相应的依赖都放好了呃相应的依赖的这个依赖好那么接下来咱们直接搜啊加搜一个什么呢呃应该是叫你看啊就这里在这是的类啊它在这里有个方法叫啊当然它有两个有一个回头要被遗弃掉那这个东西呢大家就看一眼你看这字符串格式的话也就你看它是通过什么下划线来拼接的第一个是什么第二个是什么第三个第四个那我们来看吧第一个是什么呢第个是啥呢一个啊第三个呢是一个第个呢就是它的后缀啊扩展名嗯就知道这个文件起名是什么规律那说到这儿我顺便提一嘴那个如果是文件呢在同样这个类里面有一个啊我搜一下加有个啊那它同样的它是拼接了什么还有的后缀啊扩展名后面它还会跟上一个叫版本啊版本行嗯那就先到这儿了啊方式更新数据时间旅行查询那接下来我们了解一下怎么来做一个数据的更新那其实更新很简单我们直接用一个插入操作就可以了啊它如果判断存在那么就相当来说会做一个更新了啊因为我们说的对吧依赖于索引如果我判断存在那我就是做更新操作如果不存在那我就是做操作对吧就这么简单啊好那这个时候我们可以再一次的生成几条数据啊然后呢呃还是一样通过的方式往里写那这个时候注意了咱们的这个写模式要改为其他一模一样都不变跟我们前面插入的都一样啊那这个我们就直接拷贝就行了那完事之后呢就可以去做一个查询了那么大家注意保存模式通常是就是啊不要写啊除非是第一次建表啊第一次建表咱们还是用保险一点啊或者说你你有需求你就那这个时候呢我们再来查一下吧嗯我看一下啊前面的是多少啊啊什么对吧这个也是嗯都一样啊我们先看一下这边的变化吧啊呃可能数据没有在对应的这个分区里有体现啊你看哎这个有啊这是我们刚才这个路径呃这个表里面的这个分区下面之前呢只有上面这一个什么那现在多了一个什么呢这个这个时间点的对吧第二次那我们知道上面这个呃是属于这个是你看是一样对不对也就是说这两个文件属于同一个文件组但是是不同的啊那你看这个就不一样了啊然后这个提交时间也不一样了也就是说前面这个已经是旧的了这个是新的了那我看看我怎么把它查出来啊我们现在不是流式处理对吧所以这个可能要重新加载一下啊这是之前加载的我们虽然数据已经更新了表但是这个还是老的老的话那也简单我重新加载一个啊然后呢路径还是这个表名改一下对吧这样的话就了嘛这一次应该没问题那么大家可以看到现在的有什么呢有老的这个什么也有新的这个啊那是不是跟这个一样对吧因为它拼接的这个实力时间其实就是呃我们的啊这个地方大家就看得懂啊那是啊生成的咱们就不用去看了啊行那接下来我们顺便来玩一下时间旅行呗对吧那时间旅行有几种写法啊就是你去的时候啊就重新去创建这个然后呢你指定一个然后格式有种写法那现在我的话肯定是要用这个完整的这个来写吧哎我先构造一下啊哎拿过来呃好那这个这里的我要改成我自个儿了因为我现在只有两个嘛那就改成老的这个吧这个啊我旅行回去啊好然后完之后是不是可以生成一个啊对吧呃通过这个方式重新加载一遍我们能查查找到全量最新的那现在我希望恢复到某一个的对应的那个时刻的快照其实这个时间旅行就是查看某一个历史快照嘛回车那么大家看现在一共也就只有十条数据当时我们第一次是不是插入十条第二次又插了十条对吧第二次的十条可能有更新有新插入的那你看现在我也没有什么过滤条件啊一共只有什么这十条而且这个都是当时的这个就是所谓的时间旅行啊方式增量查询指定时间点查询增量查询那么接下来我们来聊一下这个增量查询它是怎么来实现的其实也很简单就是依赖于咱们这个胎卖还是这个时间轴啊所以说这个概念很重要那我们在这个轴上有多个对吧每个对应可能是我们一个动作啊那么他怎么来实现的比如说我这时间轴上有多个啊那所谓的增量查询其实很简单就是我们既然是时间轴我们就应该能够指定一个时间范围了啊所以他我们可以去指定一个叫还可以指定一个那所谓的增量查询啊比如说我写个我举个例子啊如果你想增量查询以后新增的数据啊之前的那些我不要啊我不想查我只想查之后有哪些新增的那简单你只需要怎么做呢你将指向那你不指定就行了表示说结束都要啊就后面的全都要这个就是所谓的增量查询那基于此呢你也可以想一想那如果我想要查询什么呢我想要类似前面咱们讲到一个时间旅行对吧你是不是可以跟指定为同一个时刻就可以了对吧那也可以实现一个时间旅行啊那包括后面这个指定时间点查询其实也是通过控制这两个东西的范围来实现的好吧那现在废话少说我们先来实现一个增量查询那么我们前面有过两次对吧那我们对这一张表的还是要重新加载一下啊我之前就重新加载一下吧好吧先加载进来好加载完之后我们来获取指定的开始时间啊那这个你也可以手动指定说具体的某一个但是如果你不想指定的话也可以通过咱们下面这个来实现就是什么呢哎我啊这个就是这个隐藏列啊那我们直接对它进行一个啊去重啊然后再呢一个排序之后呢我再用算子啊去啊然后呢再那当然咱们没有了好先看一眼这个吧好那其实大家可以看到我们这个只有两个啊只有这么两个好那既然只有这么两个呢那接下来呃开始的时间那就是看你也需要哪一个了那那为了更好的演示这样吧咱们再插入几次啊咱们再更新数据这里不是有一个哎啊是上面啊更新数据这里不是有一个的方式吗啊我们多执行几次就行了呗啊那我再执行三次吧也就是说呃我一共呢是插入过五次了啊应该有五个了你看这里有五个的对吧每一个版本它都保留下来了当然有对应的清理策略啊行那既然有这么多我再执行一下刚才这个哪一个呢就是咱们增量查询这里不是呃我先重新加载一下哈在读取这个路径啊创建为相同的这个表明好了那之后呢还是通过对去重然后排序啊封装成为一个再给大家看一下那大家也可以看到这里已经变了对吧那接下来我就直接指定为上一次啊上一次啊也就是说我们现在这里有五次了啊我指定从上一次这个地方开始增量的查询啊那我们来试一下呗那接下来我们就创建这个增量查询的表怎么创建呢还是一样格式维固定接下来关键是什么查询类型要改一下这个查询类型我们更改为叫增量查询啊这个就固定写法它封装好的一个常量啊你就照这么写就行接下来我们指定一个什么开始时间啊这个也是一个固定它封装好的一个常量啊然后把我们得到了这个传进来然后呢就正常去的啊这就了呗然后呢表明我表名就命名为一个增量表这个一个表名啊那接下来不要忘了这个先获取一下啊也就是说获取的是这个什么呃秒毫秒了这个好那么接下来就是创建这一张增量表增量表创建完了我们来查询这一张增量表看看它的啊是不是从我们指定的这个开始时间往后的这一些呢好吧那么可以看到这个是我们的开始时间啊好那我们看到现在能查出来的数据它的都是怎么样是不是都是大于这个时间呢啊前面应该都是一样都是秒的了啊前面这个分钟都是啊一样啊大家看你执行的时间了啊这个其实就是啊指定一个时间范围过滤出来所以它的实现原理特别简单但往往就是我们说对高端的食材往往只需要最简单的烹饪方式对吧这就是一个增量查询啊很简单啊呃那么其实大家也可以看到我们每一次数据变更都重新加载是为啥呢因为咱们基于这种渲染它纯粹就是一种什么批处理啊对吧我们不是实时的流处理啊所以呢利用增量查询我们能够在批处理的数据上创建啊流式的这种管道效果我举个例子呃咱们比如说用写的我可以是不是可以设置每分钟调度一次也就是说每分钟执行一次代码那这个时候你是不是可以每分钟通过不写死开始时间每一次获取的是不是都不一样对吧这样就可以实现一个哎分钟我只拿到这分钟的增量数据啊对不对就看起来像是一个流式的效果这是通过来做这么来一个实现啊重新加载数据获取指定创建增量查询的表查询增量表指定时间点查询好另外我们一起看一下这个指定时间点吧所谓的指定时间点是什么意思呢就是我现在有多次呃呃多个那比如说你指定到你要指定的是这一段时间啊它的一个状态就好了最新的一次我不要这个就是指定时间点那怎么实现呢其实就是什么将设置为最开始的地方将设置为指定的这个那这样就可以获取这一段时间的一个一个状态和数据了对不对这个跟时间旅行前面讲的那个什么那个还是有点区别的啊咱们来试一下吧好那你看我怎么做啊啊我将开始时间指定为表示最开始然后的呢我指定为上一次对吧这个写法我们前面唠过了啊好先获取这两个也就是说我指定的范围了指定完范围之后我们创建一张表啊叫时间点查询一样的格式为啊咱们去一下然后查询类型还是一样还是这种增量查询啊增量查询就可以指定跟啊这是固定写法啊然后把咱们获取到了两个时间传进来这个是这个是上一次也就是说还是这个啊从最开始一直到上一次然后呢创建了这个表名啊然后再进行一个查询很简单吧啊所以你把他的思想本质理解了就可以了那么大家可以看到这个有哪一些啊这些是不是通通都小于分秒呢毫秒对吧啊那这个是结束时间的这个时刻啊那剩下的这些都是比他小比他早的对不对啊有这么四次提交的时间我们能明显看到啊接下来可能大家会跟那个时间旅行搞混啊呃我刚才是不是创建了一张时间旅行的这个表对不对啊所以其实说白了这个时间旅行查询跟这种指定时间点呃其实咱们理解起来是一样啊只要你的开始时间是然后指定为某个点儿这个就等价于一个时间点一个意思啊一个意思呃行这个是咱们这个事儿啊实操它这个案例数据的生成方式是假如我每次生成同样的条数这些数据都是同样的数据只是数值发生了变化所以所以时间点只有条数据第一次插入后查询第一次更新时间旅行第二次更新增量查询一次插入两次更新查第一次更新之后增量查询一次插入两次更新查第一次插入之后方式删除数据覆盖数据删除数据那么接下来就该到删除数据这个事儿了删除数据前面我跟大家聊到了来我们看一下第三章核心概念有一个哎应该是在数据写里面有个删除的策略那来那我们说第一种是配置一个什么第二种是指定一个的为空啊空这个类删除所有的第三是添加一个标记字段对吧那接下来咱们是怎么做呢啊执行删除的话其实我这边做的是第一种方式指定一个啊然后呢指定为啊这就是第一种方式了那这种方式呢就是说咱们现在还是什么其实就是写入啊你写入比如说你你原先一这张表这五条数据然后呢你现在要删除跟那简单你构造一个和这条数据啊然后呢指定为做一个什么呢操作就可以了啊做一个吧啊做一个写入吧那这样的话它就会把跟给删掉其实他也是先标记的一样的就是这么简单嘛那我们看一下啊那首先我们先取要删的先看一下现在这张表啊原始的这张快照表现在有几条了先一下嗯呃有十条对吧啊有十条好还是这十条数据那么取其中的两条哎来我用了一个取其中的两条啊用来做删除构造成一个啊名字叫嘛然后呢将待删除的两条数据构建什么意思呢把这个前面获取到了这个东西啊生呃用他官方的一个类啊一个方法叫生成删除的数据啊就可以了再把这个最终构造成一个好吧构造完之后就是执行啊关键在哪里啊指定一个为啊然后呢你正常去就可以了啊其他的什么预聚合字段呃啊分区字段表明保持一致即可好了删除完之后我们再来统计一下行数有没有变化你要统计变化后的是不是要重新加载一下对吧所以不要忘了重新一下啊我这边叫一个新的啊无所谓啊然后还是这个表名啊你看原来的十现在变成了那这样的话就是实现一个删除的效果覆盖数据那聊完删除呢咱们也来聊聊另外一种场景就是覆盖对于我们的表或者一个分区来说如果呀你基本上整个分区的数据都要动了大变了那这个时候还不如直接覆盖掉来得快比你说呃一条条拎出来去做更新或者删除你还不如直接全部覆盖对吧啊破罐子破摔啊这样更好一点更简单一点那类似于的这种那咱们目前也是支持的呃好那我们看一下啊那首先我们统计一下当前表的啊那我们还是读取格式为读取这张表的路径然后我们将它的字段我们不是以它为吗对吧还有它的分区路径啊把它查出来啊然后排个序啊之后呢展现一下当前的那其实你查隐藏字段也一样啊它的隐藏字段其实就是这个拼这个嘛对吧那现在我就展示的更全一点好那现在的有这么一些那我们先生成一些新的要用来覆盖的数据那我还是再什么生成个呗啊然后呢呃再把这个生成的这些数据读成一个啊然后过滤一下啊为什么要过滤呢因为我生成的数据可能是每个分区的都有现在我只想演示的是我覆盖这个分区然后这个然后这个分区了啊其他的我就不想动了啊好执行接下来我们要覆盖这个圣弗兰西斯科这个分区了那怎么写呢其他这个写法都一样还是那么注意了我这个模式还是你不要说直接来一个啊这个我们说嗯当然也可以但是不太理想啊你得考虑你的索引这些是原数据啊你覆盖的只是数据本身那原数据这些是不是也要呃稍微更新一下另外呢就是指定一个操作的为就可以了啊那其他的什么预聚合字段啊还有分区字段该什么是什么啊表名该什么就什么好覆盖完之后我们再次执行这个东西来看一下有没有变化好不好啊你看是不不一样了你看前缀都知道不一样了啊这个就是要注意的是我刚才跟大家提到你不要说直接这个的这个为就完事了啊这种不规范啊不规范还是用方式来为什么呢又涉及到原数据的嗯查看当前表的生成一些新的行程数据覆盖指定分区查询覆盖后的发生了变化方式环境准备创建表环境准备前面我们尝试的用的方式来操作但毕竟还是要写一些代码对吧啊写等等这些可能不太方便那如果我们能够用方式来操作那就很舒服了啊那它也是支持的那么接下来我们来做啊第一个呢就是由于我们要启动一个的这么一个交互式的命令行客户端呃所以呢它会默认会去连接的啊所以我们需要呃需要做的就是将的原数据服务启动起来那这边就要求你的原数据服务是配置为外置的单独的服务而不是默认的内嵌啊什么意思呢啊说白了就是你的你看一下在这里你有没有配这个东西啊如果配的这个就表示它需要单独启动的一个原数据的外置服务啊啊针对行那我们起一下呗嗯啊去哪个路径都行啊我配的环境变量的啊啊我直接呢呃我直接后台启动吧日志也不要了那些我就不管了啊好那接下来我们看一下端口监听了没有好现在已经是监听状态啊这个服务应该是启动起来了那接下来我们就要启动这个这么一个客户端就可以了那同样要指定三个配置啊第一个第二个啊第三个就那么还是提供的那呢用的的那为什么会用到呢其实跟这个有关系那么大家知道什么叫呢啊学过的应该都知道啊直接翻译是目录的意思啊那如果我们简单的不讲那些专业术语简单来讲就是在数据库之上的一层呃抽象也就是说先有再有数据库叫比如说哪个库哪个库那我们知道每个库里面是不是有一张一张的啊啊这是常规的一个组织关系对吧那现在再多一层叫啊那外部系统啊比如说就可以通过这种的东西也比如说跟去做一个打通啊他有一个好那这边它默认实现其实它用的就是底层源码用的是啊所以这也是为什么如果你不启动这个东西你直接去启动啊会报错什么原数据服务什么啊拒绝连接呀啊无法实例化原数据啊这些东西啊那是因为这个事啊行啊那如果你的机器上面没有装你就简单装一下呗啊那装完之后最好配一下环境变量这样的话你就不用做额外的操作了如果没有环境变量啊也就这个时候你要手动拷贝你的配置文件到的配置目录下说白了就一句话你要能够让能读取到的配置就可以了啊要么你配环境变量要么你拷贝呃它的配置文件那我现在是只要原数据服务启动的呃我环境是能读到那个配置的所以我直接输入命令来启动我的那这个时候就进来了这个时候我比如说我呃看一眼那么大家能看到有这么多库对不对啊这些其实是我的什么我的当中存在的一些数据库啊这个就是我们的启动方式啊创建表那接下来我们讲一下这个建表语句啊在呃简单先下面看一个例子吧啊就是正常的写一个那就是然后定义字段的类型啊就行了那无非是在后面加一个啊表示为是表啊另外呢可以通过指定一些表的参数来指定相关参数像比如说最常见的是这三个第一个呢是也就是说表的类型你是还是在这边可以去做一个指定默认不指定的话都是我们在前面渲的时候并没有指定什么表类型对不对那是因为默认就是啊另外一个这个就等于所谓的啊就是我们的记录键啊那还有一个预聚合的字段这个我们说了主要是我主键相同啊这个时候该取哪一条数据去重的时候对吧啊以指定的预合并字段值大的为准啊那一般我们用时间戳会更好一点啊好这个就是一一些建表参数啊那这个主键如果我们不指定的话它默认是取得啊一个随唯一的随机值啊创建非分区表那我们尝试建一个吧啊那比如说我们先来创建一个非分区表这个地方呢我们建一个表呃那你看我这个语法只起了表明指定的字段的后面那个表参数都不指定也就是说这个时候我用的都是什么都是默认值默认值呢就是表默认的主键就是那默认的预聚合字段就是没有啊就是没有啊就这个意思啊我们来执行一下啊呃我们创建一个吧的当然你这个库无所谓啊那我你看这张表就好了吧啊你一下啊对吧啊那这张表我们建表时指定的这三个字段啊我们说了表它有个特点就是最前面会有个隐藏列啊那分别是什么提交时间提交序列号啊啊分区路径啊还有文件名啊这五个这个就是一个简单的建表那接下来来我们建一个的非分区表怎么建呢那简单前面都一样我不啰嗦了啊咱们快速过那就是表属性然后呢类型为啊那指定主键为字段啊指定预合并为字段啊这个是最完整的一个写法啊啊这个同样直接拿过来啊好前面同样有个什么隐藏列而且默认类型都是啊都是创建分区表那么如果我们要创建分区表用怎么样的语法呢啊也简单了解一下啊如果是个分区表呢无非就是大家注意位置啊是写在后面啊那么这个表属性是在分区语法的前面啊也就是说前面这个是我们刚刚试过的只要在后面加上那分区字段可以是多个字段表示多级分区啊就多级目录啊大家注意这个分区这个关键词是有结尾的啊不要忘了啊大家容易忘这个事儿啊然后指定表的路径这个跟的写法有点像吧啊所以对于大家来讲没有什么学习成本那我就手动敲一下吧啊比如说我的分区要按照跟啊来做一个分区那这个时候这张表就建好了我们下啊这呃你看那现在我们都看到了一个什么分区信息啊由于我们指定了两个分区字段啊好回头我们去插入数据的时候再来去看在已有的表上创建新表非分区那还有一种用的方式就是在我们已经存在的表再创建一张新表啊这种东西呢你可能以为是对吧什么叫呢就什么然后呢或者这种呃主要是吧但呃是支持没错啊这个是后面呃后面咱们来讲那还有一种用的方式就是我直接指定什么这个因为这个路径是已经存在的那这个时候呢呃我们不需要再去指定什么字段呢还有表属性这些东西为什么呢因为它可以自动识别模式还有配置因为大家还记得吧我们说表路径下面会有什么表路径下面会存储了咱们的原数据信息还记得吧因为它有一个所以咱们直接指定到它就会自动识别模式还有咱们的配置那如果你不要分区那你就不要写分区呗要分区你就就可以了就这么简单啊在已有的表上创建新表分区表通过建表非分区那就是将一个表的查询结果啊将它作为我的表啊这个语法我们应该是特别常见嘛呃另外大家注意它这种语法的话它是用批量插入作为写操作的啊啊批量插入也就是说帮将整个结果集一次性插入咱们这个啊好那呢咱们这边举了三种例子对吧啊分别是什么呢呃比如说我创建非分区表那说白了就是还是那几件事儿啊你表属性要不要指定要不要指定主键要不要指定预合并对吧呃另外呢就是要不要有字段啊就这几个都可以啊都灵活来设啊那你看下面就是既有又有主键又有啊预聚合又有分区这个是最完整的对吧好那这边哦对有一个事提醒就是咱们建表的时候啊我们的分区字段是不是不会写在建表的字段列表当中啊对吧这是额外的一个字段是不是但是在当中我们是这样的啊就是说你这个分区字段必须出现在你的定义的字段列表当中啊那么大家注意一下我是不是没有指定啊没有指定它默认会保存到的默认那个配置路径通过建表分区通过从其他表加载数据创建内部表通过加载数据那还有一种呢还可以什么用的方式来加载咱们前面讲的这个是不是包含了什么呢包含了一些属性配置还有字段信息啊那比如说你要创建一张内部表啊所谓那个表是咱们说的的啊那就是什么呢大家注意这边不是了啊如果你写的是那是一种外部表什么叫外部表呢外部表意思就是说我数据的路径啊可能在某个地方我单独指定就行了我的建表只是一个建表语句原数据而已好那可能是某个地方的对吧啊那如果是通过加载数据那除呃你可以用然后之后可以去单独指定一些配置啊这个咱们就了解一下就行啊然后呢再去他是不是也是按是起来就将这个数据加载到这张表里面那其实相当于就是什么就是说一些属性我要自己来定义而不是使用默认配置就这样而已嘛这个是简单说一下一个的用法插入查询现在呢我们就来给前面创建了几张表啊我们去插入一些数据啊然后我们先看一下这些表呃对吧那我们现在是有这么几张表了那比如说来一个非分区表啊就最开始建的这张表我们先这张表啊然后呢它的表结构是啥来着啊无所谓咱们直接拷贝吧啊是这张表没错啊就插入一条数据哎多了一个呃好回车由于咱们没指定啊啊所以它的路径会是在哪呢在这个地方啊咱们没有指定没没有指定对吧啊那这个时候我们就来到默认路径呗这里有一个那来了一个再看一看里面你看有一个啊这么一个数据库的路径都是依赖于文件系统的啊好那你看啊咱们现在有这么几个了那我们是这个固底看一下这里面现在是不是有一个对吧啊我们一起来回顾一下看一下原数据怎么看呢杠这里能看到什么呢点弧底点蝴蝶那还有一个什么分区的云数据啊我们说了没有指定分区字段那整个表的路径就是大的一个分区路径啊相当于是这样啊就相当于说有个默认的大分区啊行嗯呵呵好那同样对另一张表表我们也去插入一下呵呵对吧啊也是执行成功了我们来看一下数据有没有生成就这张啊你也可以直接去那个一下啊那你看也有帕灰特了啊好行啊这个应该都另外一种就是咱们的动态分区写法哎我就是说我我是一张分区表但是呢分区我不写死分区的值不写示哎我只需要传一个什么呢分区字段就可以那么回头呢咱们大家注意了你后面不是跟上一个吗啊反正总而言之跟上一个结果集最后的字段就跟分区字段匹配啊那比如说你分区字段是两个那么倒数第二个字段的值那就是呃这个的值那最后的一个值就是这个的值啊它是根据这个字段的顺序来对应的的这跟的一个用法还是基本一致的好那我们来尝试着哎我不指定分区让他去哎不对啊在这里让他去插入之后呢咱们只需要去看一看这个呃好那我们先看一下这张表呗呃是哪张表来着进来太多这张表是吧看确认一下啊啊行那就这个我们先看一下这里有没有呃不在这儿啊因为我们当时建表时候指定一个什么啊指定一个好那既然指定了我们就去在这看呗啊我再拷贝一个窗口出来哦这个是路径了现在就是那这样的话我的我看起了没有他豆粉是起的那么啊这里有啊我来到跟路径看看咱们指定的那个哎然后有个底啊然后你看这张表是不是现在就有了它不存在就会自动帮我们创建哎点进来哎发现了哎它自动在这个表路径下面生成了一个呃分区路径啊就咱们是动态插入的嘛啊还有原数据对吧这里面呢还有第二层分区还有呢哎这里就是一个回的文件了好嗯这个就是像分区呃动态插入啊动态分区插入这个可以说应该是特别常用特别好用啊另外一种就是往斜死的分区去做一个插入操作啊就还是同样的表咱们在银色的时候指定塔金水为具体的值那这样的话就是一个指定分区的插入了那么也是快速执行一下啊这些语法都跟或者说的语法啊如果你要指定为本地文件系统啊就比如说咱们创建表的时候这个地方呃你没有加协议默认就是是吧如果你要本地的话你应该是这么写呃啊对吧啊这样来写那就这就是一个本地的好那完事之后我们只需要确认什么刚才是不是只有一个十这么一个分区我们看看有没有生成新的分区啊你看现在是不是生成了一个的这个二级分区啊这里面也有数据了这个就是一些插入啊另外一个就单独介绍一个我们的这个批量导入这么一种插入方式这种一般是用来做一个呃历史数据的初始化啊举个例子啊呃你现在呢有大量的数据有比如说有亿条历史数据现在你们要开始上数据湖了啊要上了要数据路湖了那这个时候呢我建议说历史数据的导入就用这种方式啊啊那要用它呢其实就是呃开启两个配置第一个呢就是这个第二个呢就指定为插入模式为非研究模式啊非研究模式来我们先来执行一下比如说这张表我们再插入一条数据啊这个时候呃我们都不去指定这个参数对吧还没指定这个时候默认为什么啊我就是插入或更新啊插入或更新我们先查一下这张表啊之前呢我们是插入过一条数据是不是啊那现在相当于说我要把一的名字改为一下划线一啊这样子好先插入好完事之后呢我们再来查询那个隐藏字段咱们就不看了对吧我们只要看它的结果值哎你看这个是不是从原先的我看在哪个地方原先的一现在变成了一下划线一了啊这就实现了一个更新的效果嘛这个也被我们更新掉了嘛对吧啊我们说我们指定了那个预合并字段如果咱们的相同它就会取预合并字段值大的那条数据对吧那我们指定的为什么呢就是咱们的啊都是一啊然后呢这个大的就是这个啊就取它这就实现了一个更新覆盖的效果嗯行哼那我们要用银色的注意啊要求你这张表指定的玉合并的啊才可以啊要不然会报错的啊呃数据也会不准确这样的话就可以保证一个数据的一致性的插入的时候好那我们先把这两个参数给开启一下啊我们的方式让它临时生效啊就了啊一下好现在已经是触跟非严格了开启之后呢咱们再去插入大家可以看一下啊我再插入相当于说嗯这个内蒙又变了呢是啊也就看一下它的方式会是什么来我们再查询一遍这个时候你会发现哎居然有相同为一的存在也就是说它并没有执行我们这张表是有预合并字段的但是没有执行如果是前面这种的效果大家也看到它是不是直接覆盖掉更新掉啊对吧那现在是批量导入的话就不会了啊他就会把这条新的数据也插入进来而已啊而已嗯好那接下来查询就不用讲了查询就是一个语法就可以了啊那这个我们其实我们已经执行过了啊所以这个没什么好演示的这个大家都会啊谁都会啊那么查询这里呢我们需要单独来强调一下时间旅行那么在渲染方式当中我们已经试过了那么接下来我们用方式来实现啊那注意版本要求是要以上另外你要方式要求以上不然方式是不支持的那么为了避免前面的影响呢咱们不是开了一个吗对吧呃那这个地方我们先把它关掉把它制成一个那那个非严格模式还是保持非严格就可以了啊其他不动那我们再建一张新的表啊这个什么表一对吧字段还是这几个啊还有分区呢咱们还是以两个字段分区啊路径呢也指定一下呃呃组件预合并字段啊就这样子跟前面建表基本一样啊为了不干扰我们再建一张新的建完之后呢咱们开始插入数据了啊先插入这么一条简单的数据啊为一内为为啊后面是两个分区字段好插入完咱们在现查吧好现在说没找到他会去给我们创建的好我们查询一下数据呢缩小一点啊数据现在是进来了你看还有两个分区好那接下来我们对它进行修改现在我们是的模式对不对啊那这个时候呃组件相同那就会取域合并字段大的这一条也就是它也就可以将一更更新成了一啊你看后面这个分区一样的啊一样的好做一个更新操作哎嗯好更新完之后我直接上翻查询那我们缩小一点看一下这个值已经变了对不对啊已经从变成了也就是说现在进行了两次的那现在呢我们要基于第一次这个时候做一个时间旅行怎么写呢呃这么写啊就是你正常的查询加上一个什么语法呢什么什么东西呢当时的那个那我们刚才查过是有的对吧当时的时间是这个啊第二次提交的时间是这个那么就指定时间履行到这个时候啊去查如果查出来是那就说明就是没毛病了对吧啊那当然这边的写法有几种啊几种呃一个是写完整的时间戳年月日分秒毫秒另外一个呢是写一个日期格式的啊有有连接符的这种啊也可以再有一个呢你只写到日表示从点分开始啊那我们现在用就用第一种呗那这个时间戳我们就从刚才查询的零它对应的这个来就可以了好拷贝那这边注意加一个单引号啊单引号好行来回车哎注意看我们查出来的是什么零是吧哎我们把它的历史状态给查出来了如果你不加这个那查出来就是最新的一了这个就是世界旅行这个应该说还是比较好用啊可以查询多版本啊这个是世界旅行啊更新数据更新数据删除覆盖数据修改表结构分区存储过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-03 23:20:22',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Tech智汇站</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 1.05rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 1.05rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 1.05rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 1.05rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.05rem;">大数据<sup>27</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 1.05rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 1.05rem;">廖雪峰<sup>9</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>12</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">75</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/" itemprop="url">尚硅谷大数据技术之数据湖Hudi</a></span></div></div><h1 class="post-title" itemprop="name headline">尚硅谷大数据技术之数据湖Hudi-3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="post-meta-icon anzhiyufont anzhiyu-icon-calendar-days"></i><span class="post-meta-label">发表于</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="发表于 2025-01-17 17:35:02">2025-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/01/17/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3/"><header><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url">大数据</a><a class="post-meta-categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/" itemprop="url">尚硅谷大数据技术之数据湖Hudi</a><h1 id="CrawlerTitle" itemprop="name headline">尚硅谷大数据技术之数据湖Hudi-3</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">智汇君</span><time itemprop="dateCreated datePublished" datetime="2025-01-17T09:35:02.000Z" title="undefined 2025-01-17 17:35:02">2025-01-17</time></header><h1 id="尚硅谷大数据技术之数据湖Hudi-3"><a href="#尚硅谷大数据技术之数据湖Hudi-3" class="headerlink" title="尚硅谷大数据技术之数据湖Hudi-3"></a>尚硅谷大数据技术之数据湖Hudi-3</h1><h2 id="数据写"><a href="#数据写" class="headerlink" title="数据写"></a>数据写</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403112238411.png" alt="image-20240311223824434"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">那我们来聊一个hoodie当中的一个核心操作，也就数据写入的一些操作啊，还有一些基本的原理，这个大家就视情况来了解。如果你仅仅是应用呢，你这一块就简单搂一眼就可以。如果你想啊多了解深一点，那你就好好去了解这一块，研究这一块。啊</span><br><span class="line"></span><br><span class="line">那我们基本要知道的是hudi的写入操作啊，大概可以分为三大类啊。第一类是所谓的upsert，也就是说插入或者更新。那这个时候它是严格依赖于什么呢？索引。它是必须依赖于索引的。也就是说upset的必须依赖于索引啊，这也是hudi的一个特点特性，高效的upsert啊，还有结合索引。另外呢他会去标记你是插入还是更新的数据。另外呢根据不同表不同场景啊，也就是说他有一定的策略啊去写做一些写入的行为啊，这是upsert的我们具体看啊</span><br><span class="line"></span><br><span class="line">另外一种就是insert，就是指追加的方式。其实啊那就是跳过索引啊，就是你这个索引我不管了，反正我有新的数据来，我管你是什么样的，我都直接就是追加追加追加追加啊。但是这个呢嗯回头你要自己去做一个去重的一个处理啊。</span><br><span class="line"></span><br><span class="line">还有一种是bulk_insert，是那个批量插入，批量插入这种是后面新版本提供的一种呃优化功能啊，这样的性能会更好。它会做一个排序，然后进行一个写入啊，它是对大数据量的hudi表呃初始化的话，用这种方式会更好一点啊。嗯，而且对文件大小的限制是最好的一个效果。行，那就是粗略的知道有upsert，有insert，有bulk_insert对吧？</span><br><span class="line"></span><br><span class="line">啊，那最重要的默认的就是这个upsert是我们一定要了解的。</span><br></pre></td></tr></table></figure>

<h3 id="写流程-UPSERT"><a href="#写流程-UPSERT" class="headerlink" title="写流程(UPSERT)"></a>写流程(UPSERT)</h3><h4 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403112257831.png" alt="image-20240311225750511"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好，那我们具体来看呢，upsert咱们就按照两种表来解读。第一种是COW表它怎么做的。第21个呢就是MOR怎么做的。其实前面多多少少聊过，我们再捋一遍啊，对于COW表我们进行一个upsert，它是先什么呢？按先对我们的这一批数据按照指定的key去重</span><br><span class="line"></span><br><span class="line">举个例子啊，1A2B3C，比如说是这批数，这是一批数据对吧？啊，那如果我们指定的第一列为我们的键，那就就这个id值就是这样了，对吧？那比如说你数据还有一条1A是不是有重复啊啊，它会先按照指定这个key，哎，先是给你去个重啊，然后呢对这一批数据创建索引。所以我们讲的就是record key呃，对吧？加上分区路径啊，然后呢跟我们的文件id文件组的id呃形成一个映射关系啊，也就是说会记录哎这一条数据呃对应的是哪一个file id啊。行，这个索引细节不聊了。呃，另外这个索引还有一个作用是区分我们是更新还是insert的。insert呢就表示这个这个key是第一次写入啊。如果不是第一次写入，那就是需要更新嘛，这个好理解吧，也就是通过创建索引，并且区分更新还是插入。</span><br><span class="line"></span><br><span class="line">那接下来既然要区分，那就有不同的处理方案了。一个是对于update，一个对于insert的。如果是更新了，他会找到这个key啊。咱们这个hudikey对应的这个呃文件片，咱们所以不是维护了这个key跟文件片的关系嘛，对吧？啊，他能找到他找到这个文件片之后啊啊，不是文件组ID啊，那文件组ID再找最新的文件片，然后再找到里面的base文件。Base文件什么意思呢？我给你说啊，parquet就是它的呃，就是如果你看到说什么基本文件呢，列文件呢呃parquet指的都是这么一回事儿，就是指的这种parquet文件好吧，并且呢做一个什么merge完之后写入到新的什么base也也就新的文件片就生成新的parquet嘛。</span><br><span class="line"></span><br><span class="line">这个就是更新。那如果是纯粹的插入呢，我不是更新呢啊他就有点不一样了。呃，他会先扫描当前分区下面的小文件，也就是说有一个阈值啊，这个参数可以控制。比如说是十兆，哎，我说小于十兆的这个parquet文件，呃，如果有，那我这个插入的消息我就往里面去写，往里面追加啊。如果没有这种小的parquet文件small file我怎么办呢？啊，没有小的让你蹭啊，你蹭不了啊，那怎么办？那你就自己来呗，你写一个新的不就完事了吗？啊，就写入一个新的文件组，文件组里面的一个新的文件片能理解吧？也就是说有地方蹭那就蹭啊，没地方蹭就自己去开一间，对吧？啊，这个简单啊，这是COW</span><br></pre></td></tr></table></figure>

<h4 id="MOR"><a href="#MOR" class="headerlink" title="MOR"></a>MOR</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403112316554.png" alt="image-20240311231611456"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那MOR就麻烦了啊，也不是麻烦啊，就是跟索引有很大关系啊。MOR的话来如果是MOR的upsert写入啊，那也好理解啊。哪里呃，首先还是一样，根据咱们指定的数记录键或者叫数据键进行一个去重。就刚才例子啊有1A2B3C啊，呃然后再来一条1A你指定第一个字段ID为为这个键的话啊，那就先按照这个键去重。哎，哎发现有两个一哎去个重我只保留一个啊。好，然后呢同样是什么创建索引，然后这个索引也会区分是update还是insert。这个这两步跟COW是一样的啊是一样的。</span><br><span class="line"></span><br><span class="line">好，接下来就不一样了啊，它对insert的跟update分别是怎么处理呢？我们来看啊，对于insert，如果因为正常咱们增量提交嘛，MOR是不是要写点log文件？前面我也简单提了得区分能不能建索引，是不是？如果是不可建索引，也就是你用的是布隆啊，说白了就是布隆嘛，这也是默认的，对不对？他会干什么呢？默认去分区内最小的base file。如果建不了索引，他就去蹭别人的。能理解这个意思吧？你建不了索引，那我就去蹭别人了，这是插入的消息啊。然后蹭别人之后，跟别人合并成新的一个文件片啊。那如果没有小的基本文件可以蹭，那就一样自己写一个新的呗。新的文件组里面的新的片的新的parquet，这是见不了索引的时候啊，就生活不能自理呗。</span><br><span class="line"></span><br><span class="line">那如果你能够建索引，也就是说如果你用的是flink对吧？咱们就直接把这些联系起来，你就好理解了。如果你用的是flink它基于状态可以对log file建索引，它直接干嘛呢？它是追加log文件，什么样的log呢？小的log。如果没有小的log文件可以蹭。那就自己开个新的呗，新的文件组新的文件片新的base file。</span><br><span class="line"></span><br><span class="line">好吧？嗯，能不能理解这个意思啊？简单来讲，如果是插入消息，呃，log索引啊，就区分可不可以建。所以不可见他就去蹭人家的小parquet。然后合并成新的啊。如果蹭不了，就自己写入一个新的新的文件组就行了啊。如果可以见索引引它也是蹭，但是它蹭的是什么小log文件，如果蹭不了就自己写一个新的啊，一样的道理啊，简单理解就是这样吧。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那如果是更新的消息，这个就简单了，你也不用说蹭不蹭的了，你更新你就要找到你要你的老数据在哪，对不对啊？它会写对应的这个file group，还有对应的文件片啊，就老数据所在的位置啊，直接什么呢呃，append最新的log file对吧？那如果刚巧是最小的小文件，也会进行一个合并，生成新的文件片啊，这个就你就不用管这个细节了啊，反正如果是更新消息，那就找到对应的是哪个组的啊，你是要更新的数据在哪个组啊，然后对应的新的文件片，然后去追加log就行了。因为你一直追加，你是不是不可能无限膨胀啊？对吧你一直在追加对吧？所以它达到一定的阈值会做一个滚动啊滚动生成一个新的log。好吧？这个是upsert的一些细节。其实你说它有用吧，也没用，但是方便我们去理解呃一些现象。比如说你去看HDFS的时候啊，就看到那些文件的怎么有时候几个log有时候又是怎么样怎么样，对吧？啊，去方便理解。</span><br></pre></td></tr></table></figure>

<h3 id="写流程-INSERT"><a href="#写流程-INSERT" class="headerlink" title="写流程(INSERT)"></a>写流程(INSERT)</h3><h4 id="COW-1"><a href="#COW-1" class="headerlink" title="COW"></a>COW</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403122357690.png" alt="image-20240312235702570"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">呃，那其他的像insert这种写入流程就简单了啊，咱们快速过啊啊还是区分两种表，COW跟MOR表啊。那如果是COW它一样的，先对呃通过这个key啊进行一个去重啊，你也可以选择不去重啊，大家注意是可选的。另外呢我们前面讲了index啊，insert不会创建索引。呃，接下来就是蹭的问题了啊，如果有小的基本文件，那就去合并啊生成新的，否则呢没有小的可以蹭，就写新的呗啊，这个就insert了，很粗暴很简单，</span><br></pre></td></tr></table></figure>

<h4 id="MOR-1"><a href="#MOR-1" class="headerlink" title="MOR"></a>MOR</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403130001225.png" alt="image-20240313000158116"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也简单一样，我们可以按照这个key去重，也是可选，也不创建索引。那接下来无非又是那一坨式，就是你这个log文件有没有索引啊，能不能索引，对吧？如果可索引，并且有小的可以蹭，那你就去追加啊，如果没有，那你就写呗，写呃追加或者写新的一个文件。呃，这边是为什么是或写最新的文件？因为咱们前面讲的不是有一个什么呢滚动吗？就是说log有大小限制啊。好，那么如果这个log file也不能够索引，那直接就自己写个新的就完事了啊，新的文件片大家注意是新的文件片啊</span><br></pre></td></tr></table></figure>

<h3 id="写流程-INSERT-OVERWRITE"><a href="#写流程-INSERT-OVERWRITE" class="headerlink" title="写流程(INSERT OVERWRITE)"></a>写流程(INSERT OVERWRITE)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403130007151.png" alt="image-20240313000718129"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">啊那insert overwrite呢，这个是后面才支持的一个功能啊，叫覆盖写。呃，他会在同一个分区中创建新的文件组，并且呢现有的文件组被标记为删除。这个就是区别它创建新的同时将旧的组，大家注意它操作对象是组啊啊，它将旧的组标记为删除啊，根据新记录的数量创建新的文件组啊，说白了就是重来啊。</span><br><span class="line"></span><br><span class="line">那这边有一个小案例，大家看就行了啊。呃在插入之前呢，这个时候分区有一个文件组一、文件组2，对吧？啊，他们有一个版本的，都有一个PACK的文件啊，那如果你是插入相同数量的记录覆盖，也就是说原先有呃这个组有十条数据这个组有十条数据。那这个时候你是hudi的overwrite还是20条写过来，这个时候它会生成新的组3跟新的组四啊，并且是呃也各有一个pty的。然后呢，老的一跟二要被覆盖的这两个就在原数据中被标记为无效，标记为删除，就这么简单，就是这么粗暴啊，生成新的再把脑袋干掉，过河拆桥对吧？就这么简单。那插入如果是更多的记录，那其实没什么营养啊。比如说原先只有20条，你覆盖写入是100条，那无非就是生成更多的新的什么文件组。那同样的呢你要将呃。翻译一翻案2，就老的在T1后，原数据被标记为无效，就是老的又被过河拆迁了。啊，好吧，那其实这几个只是啰嗦一下啊啰嗦一下。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403130008398.png" alt="image-20240313000818437"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那如果是MOR表有什么特点一样啊，一模一样，好吧，这个就不啰嗦了。</span><br><span class="line"></span><br><span class="line">嗯，你看他们执行方面非常相似啊，而且不会干扰咱们的这个compassion。呃，然后可以减少parquet文件的大小啊，对吧？因为你重新规划了嘛，就相当于说你你旧改嘛，你家老的自建房都推都都拆了，然后通过规划去盖房子，那肯定是呃空间使用更合理嘛，是不是啊，不浪费空间嘛。啊，行，不需要更新关键路径中的外部索引，对吧？我不用去更新收引。好吧，还可以扩展清理策略。</span><br><span class="line"></span><br><span class="line">呃，缺点呢也有需要转发以前提交的原数据。另外呢呃还有一些小问题，当然这个缺点是在呃官方的一个呃啊设计当中的一个考虑啊。这个咱们现在也不用去操心，也就是说有一定的小代价吧。一个是转发元数据，第二个呢是将忽略老数据呃。但是这个事不用我们关心，他呃，会有方案来忽略他们。这个就简单介绍一下啊，那咱们在这里面最常用的还是这个什么upsert，这是最重要的一个特性。</span><br></pre></td></tr></table></figure>

<h3 id="Key生成策略-删除策略"><a href="#Key生成策略-删除策略" class="headerlink" title="Key生成策略&amp;删除策略"></a>Key生成策略&amp;删除策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">那其他的一些小东西咱们就简单了解一下就可以了啊。比如说有一个key的生成策略，咱们前面一直讲索引对吧？索引对应的是不是有个hoodie key啊？那hooodue key由咱们的记录键跟分区路径组成的</span><br><span class="line"></span><br><span class="line">那这个地方这个记录键那可以怎么做啊？然后分区路径又有哪些限制啊？就简单说一下。那首先这个record key是可以有多个字段组合的啊，比如说我们的字段有啊ID啊name，然后比如说性别、age这么多个来几条数据吧。一啊张三，性别男，呃，年龄十八啊。比如说这种数据</span><br><span class="line"></span><br><span class="line">你可以只以一个字段ID作为record key，你也可以拼接这个id跟性别作一个key啊，也可以啊就联合的的key。</span><br><span class="line"></span><br><span class="line">另外这个分区路径呢是可以有多个字段组合的。呃，多个字段组合呢为什么呢？因为你分区是不是可以有多级分区啊，也就多层目录呗，多层那这个也是允许的。另外呢如果你是非分区表也是可以的啊，这个都无所谓啊。</span><br><span class="line"></span><br><span class="line">另外就是比较重要删除策略，hudi对于数据的删除</span><br><span class="line">删除大家简单呃大家联想一下hive怎么删除数据呢？嗯，对吧？或者说我在某一张分区表某个分区，我里面有12345啊，某呃别管是不是hive了啊，就比如说某个分区下面有12345呃五条数据，我想把第三条数据删了怎么办呢？如果以前的传统做法，你是不是insert overwrite，你是不是overwrite一个1245进去，是不是就把删给给删了，对吧？但这样大家操作比较重了，如果我这个数据有一条，你只删一条再写一遍啊，没必要啊</span><br><span class="line"></span><br><span class="line">所以它有两种，第一种呢是逻辑删。我将value字段全部标记为null就可以了是吧？除了key之外的，其他的我都全部标记为null，这是逻辑上的删除。</span><br><span class="line"></span><br><span class="line">那第二种呢就是物理删，就正儿八经删啊，通过配置一个key删除所有的输入记录，就OPERATION_OPT_KEY对吧？另外一个就是利用它的payload机制，指定我们的payload类为一个空的PAYLOAD_CLASS_OPT_KEY = org.apache.hudi.EmptyHoodieRecordPayload，这样的话它会删除所有的记录。</span><br><span class="line"></span><br><span class="line">啊，另外呢还有一种方式呢，就手动添加一个字段。添加这个字段呢就是固定的字段名啊，添加这个字段_hoodie_is_deleted，然后就可以了啊，就标记为删除了。这种是一些删除的策略啊</span><br><span class="line"></span><br><span class="line">那么整体来看呢，核心优势最重要的是什么？就是upsert啊。那基于upsert，咱们对更新也好，删除也好，它非常高效。为什么呢？索引对不对？索引啊所以前面聊了这么多呀，描了这么多概念。其实最最重要的啊，大家有必要去了解的，好好理解的一个是什么？时间轴这是基本的吧啊文件布局要了解吧。那这个索引对不对？表类型、查询类型简单了解啊，因为你回头一直用啊，你要去用，你肯定会涉及到。那写操作最重要的就是这个upsert啊就够了。</span><br></pre></td></tr></table></figure>

<h3 id="数据读与Compaction"><a href="#数据读与Compaction" class="headerlink" title="数据读与Compaction"></a>数据读与Compaction</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那接下来就剩一点小概念了啊，数据读这一块前面都其实都介绍过了，我不再啰嗦了。就一个快照读取，一个增量读取</span><br><span class="line"></span><br><span class="line">那还有一个叫流读，那这个主要是在0.8版本之后的flink这一边支持流读。那当然后面我们也会去演示啊，有一些实际案例去操作啊。真正的是一个流式的读取，它是source会定期监控新增的改动文件，将读取任务下派对吧给读了这个task，这个后面再唠吧。你简单留个印象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那我们聊一个compassion，compassion来一起回忆一下它是什么表。有的呀MOR表啊，记住啊，COW不用compassion。那如果呃我是数据刚刚开始写，那这个时候是不是没有base file，也就是没有parquet。那这个时候你要compassion就是什么呢？它走的是类似COW表呃，COW这种insert流程，直接什么merge所有的log文件，生成一个parquet文件，就这么理解就完事儿了。</span><br><span class="line"></span><br><span class="line">那如果呃现在已经有parquet文件，并且呢也有log那怎么办呢？啊，他会先什么呢？其实就是一个cow upsert流程，他会先读log文件，建立一个索引，再读什么呢？老的parquet文件。建完索引读part quet，读完parquet读log之后呢，将它俩合并到新的一个parquet文件。啊，就这么简单嘛。</span><br><span class="line"></span><br><span class="line">啊另外要想强调的是，咱们这个compassion是可以走异步的。什么叫异步啊啊我相信对同步异步这个概念应该还是有些人搞不太明白。这是呃应该说作为一名开发基本的一人基本都要了解的吧。那所谓的异步就是各管各的呗，对吧？就有点像咱们田径比赛当中的什么呢啊，比如说400米比赛吧啊是不是每个赛道一名选手，对不对？那你开始之后啊，裁判发令之后是不是各跑各的？你总不会说你跑得快，你跑到前面说，哎，我等你一会儿，你没有这回事吧，你专心跑你自己的就行了，是不是？这是一个异步呢？那还有一种同步，你可以怎么理解400米接力啊400米接力啊。如果上一棒400米没跑完，你下一棒不能跑，你是不是得等啊，是不是得阻塞呀？啊那一般来讲这么来粗糙的理解就够了啊</span><br><span class="line"></span><br><span class="line">那这边的异步指的是什么呢？呃，就是咱们写入的这个动作跟我们执行compassion，他俩之间不用互相看脸色，不用互相等待啊。Compassion由你自己的条件来触发执行就行了。我写入管我写入的就行了。嗯，那这个compassion的呃compassion的策略可以按照呃几次commit，或者说按照固定的时间来触发，这是有不同的策略对吧？那一般来讲呃会用数量更多一点啊数量更多一点。行，这是咱们聊的一些小概念了，后面几个就简单过啊。</span><br></pre></td></tr></table></figure>







<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来我们动手体验一下跟Spark集成来操作护底表这么一个操作。那么首先呢咱们还是要回顾一下HOOO底支持Spark的一个版本。那么前面也跟大家聊到了不同的呼底版本支持呢，Spark系列是不一样的啊。那这边我列出了对于Spark三的支持啊，那要注意在0.12当中呃支持的是3.1、3.2、3.3，没有3.0啊，没有3.0。那如果你想要3.0，你可能呢你得用最新呢，只能用到0.10。当然呢对于二系列还支持2.4啊，这个我就不啰嗦了。那一些新特性啊也是在3.2才支持的那本教程呢咱们就以3.2的Spark为例啊，那首先需要大家先去安装部署一下，那么你可以通过这个地址直接w get去下载下来。那我这边是有了，下载下来之后呢，你将这个踏包呃通过踏命令去做一个解压，解压到对应的目录就可以了。那么大家可以看一下，我的model下面已经解压了一份Spark302.2，就是这个啊。另外呢解压完之后，最好还是配个环境变量啊，方便使用。哎，provide点d my ENV啊，我习惯上写在这个文件里面。在这呢我已经配了一个Spark home，那这个路径啊写成你的路径就可以了。修改完环境变量，不要忘了做一个source常规操作啊。扫描一下这个环境啊，那就可以了。那么接下来呢呃我们需要集成，只需要做一件事情就可以了。将我们编译完的Spark hoody包放到Spark的呃依赖路径下面即可。啊，那在哪呢？我先把我老的那个删掉啊。好。我们听到soft沃尔弧底呃0点一二里面有一个package，在这里呢有一个Spark谋害啊who蝶Spark这个那么进来之后呢有一个target，target就是咱们编译完的一个路径，那里面有一个架包对吧嗯。呃，呃咱们要的是上面这个呃名字最短的这个就是好，那我们拷贝它，拷贝到OPT module Spark3点2.2里面的驾驶，放到这个里面就可以了啊，我们拷贝过去。那拷贝完事儿之后啊，我们搂一眼吧。那这个包已经在这里了，这是我们编译完成的包。那么接下来你我们只需要去启动我们的Spark就可以。那通呃Spark呢怎么来操作这个护底呢？呃，你可以直接通过share Spark share直接去快速的体验。那你也可以去到你编呃打写成一个代码，然后打成价包的方式去提交也可以啊，那我们先介绍一下这个渲染的方式啊，这样比较快啊，快速的体验。那么大家别忘了这个它Spark对于依赖的加载，它是静态加载的。也就是说如果你已经是启动了一个呃什么样的集群，比如说是真的弄的Spark，那么你添加新依赖需要重启一下它才能够加载到啊。行，这个不啰嗦了。那么接下来呢大家注意这个启动命令啊，share里面呃启动的时候不同的版本它可能写法不太一样啊，包括它的类不太一样。这个大家可以去官网查阅啊，有一个Spark指南，你看一下你对应版本有什么区别啊。那如果是3.2跟我一样就行了。那么大家看一下啊share然后呢指定几个参数，那这些参数分别是什么？哎，一个序列化器指定为KRYO，第21个呢呃使用了一个catalogue啊，咱们用的是什么hody catalog，还有一个呢是一个拓展项啊，用的是hohoddy spck session啊，指定这三个就可以了。那么如果你需要用到HDFS之类的啊，呃你记得启动一下hadoop。那如果没有的话，你不启动也行啊，这个我就不不去啰嗦了。那这个命令啊你就不要手敲了吧，这个可是全类名啊啊，也是一个固定写法啊。如果你有其他参数要指定，再去指定就好了啊，咱们快速演示啊。好，回车。好，那这样就进入了Spark share这个交互式的命令行了，就可以我们来一个快速的体验了。</span><br></pre></td></tr></table></figure>



<h2 id="Hudi集成Spark"><a href="#Hudi集成Spark" class="headerlink" title="Hudi集成Spark"></a>Hudi集成Spark</h2><h3 id="环境准备-启动Shell"><a href="#环境准备-启动Shell" class="headerlink" title="环境准备&amp;启动Shell"></a>环境准备&amp;启动Shell</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403141441576.png" alt="image-20240314144140822"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">接下来我们动手体验一下跟Spark集成来操作hudi表这么一个操作。那么首先呢咱们还是要回顾一下hudi支持Spark的一个版本。那么前面也跟大家聊到了不同的呼底版本支持呢，Spark系列是不一样的啊。那这边我列出了对于Spark三的支持啊，那要注意在0.12当中呃支持的是3.1、3.2、3.3，没有3.0啊，没有3.0。那如果你想要3.0，你可能呢你得用最新呢，只能用到0.10。当然呢对于二系列还支持2.4啊，这个我就不啰嗦了。</span><br><span class="line"></span><br><span class="line">那一些新特性啊也是在3.2才支持的那本教程呢咱们就以3.2的Spark为例啊，那首先需要大家先去安装部署一下，那么你可以通过这个地址直接wget去下载下来。那我这边是有了，下载下来之后呢，你将这个踏包呃通过踏命令去做一个解压，解压到对应的目录就可以了。另外呢解压完之后，最好还是配个环境变量啊，方便使用。哎，/etc/profile.d/my_env.sh，我习惯上写在这个文件里面。在这呢我已经配了一个Spark home，那这个路径啊写成你的路径就可以了。修改完环境变量，不要忘了做一个source /etc/profile.d/my_env.sh常规操作啊。扫描一下这个环境啊，那就可以了。</span><br><span class="line"></span><br><span class="line">那么接下来呢呃我们需要集成，只需要做一件事情就可以了。将我们编译完的Spark hoodie包放到Spark的呃依赖路径下面即可。hudi下面有一个packaging，在这里呢有一个Spark模块。那么进来之后呢有一个target，target就是咱们编译完的一个路径，那里面有一个jar包对吧。 咱们要的是上面这个呃名字最短的这个就是hudi-spark3.2-bundle_2.12-0.12.0.jar</span><br><span class="line"></span><br><span class="line">拷贝到/spark3.2/jars，放到这个里面就可以了啊，我们拷贝过去。那么接下来你我们只需要去启动我们的Spark就可以。那Spark呢怎么来操作这个护底呢？呃，你可以直接通过spark shell直接去快速的体验。那你也可以去到你编呃打写成一个代码，然后打成jar包的方式去提交也可以啊</span><br><span class="line"></span><br><span class="line">那我们先介绍一下这个shell的方式啊，这样比较快啊，快速的体验。那么大家别忘了这个它Spark对于依赖的加载，它是静态加载的。也就是说如果你已经是启动了一个呃什么样的集群，比如说是真的弄的Spark集群，那么你添加新依赖需要重启一下它才能够加载到啊。行，这个不啰嗦了。那么接下来呢大家注意这个启动命令啊，shell里面呃启动的时候不同的版本它可能写法不太一样啊，包括它的类不太一样。这个大家可以去官网查阅啊，有一个Spark指南，你看一下你对应版本有什么区别啊。那如果是3.2跟我一样就行了。</span><br><span class="line"></span><br><span class="line">#针对Spark 3.2(官网还有一个jars要指定啊)</span><br><span class="line">spark-shell \</span><br><span class="line">  --conf </span><br><span class="line">&#x27;spark.serializer=org.apache.spark.serializer.KryoSerializer&#x27; \</span><br><span class="line">  --conf &#x27;spark.sql.catalog.spark_catalog=org.apache.spark.sql.hudi.catalog.HoodieCatalog&#x27; \</span><br><span class="line">  --conf &#x27;spark.sql.extensions=org.apache.spark.sql.hudi.HoodieSparkSessionExtension&#x27;</span><br><span class="line">  </span><br><span class="line">那么大家看一下啊share然后呢指定几个参数，那这些参数分别是什么？哎，一个序列化器指定为KRYO，第21个呢呃使用了一个catalogue啊，咱们用的是什么hody catalog，还有一个呢是一个拓展项啊，用的是hohoddy spck session啊，指定这三个就可以了。</span><br><span class="line"></span><br><span class="line">那么如果你需要用到HDFS之类的啊，呃你记得启动一下hadoop。那如果没有的话，你不启动也行啊，这个我就不不去啰嗦了。那这个命令啊你就不要手敲了吧，这个可是全类名啊啊，也是一个固定写法啊。如果你有其他参数要指定，再去指定就好了啊，咱们快速演示啊。好，回车。好，那这样就进入了Spark shell这个交互式的命令行了，就可以我们来一个快速的体验了。</span><br></pre></td></tr></table></figure>

<h3 id="Shell方式-准备及插入数据"><a href="#Shell方式-准备及插入数据" class="headerlink" title="Shell方式_准备及插入数据"></a>Shell方式_准备及插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hudi.QuickstartUtils._</span><br><span class="line">import scala.collection.JavaConversions._</span><br><span class="line">import org.apache.spark.sql.SaveMode._</span><br><span class="line">import org.apache.hudi.DataSourceReadOptions._</span><br><span class="line">import org.apache.hudi.DataSourceWriteOptions._</span><br><span class="line">import org.apache.hudi.config.HoodieWriteConfig._</span><br><span class="line"></span><br><span class="line">val tableName = &quot;hudi_trips_cow&quot;</span><br><span class="line">val basePath = &quot;file:///tmp/hudi_trips_cow&quot;</span><br><span class="line">val dataGen = new DataGenerator</span><br><span class="line"></span><br><span class="line">val inserts = convertToStringList(dataGen.generateInserts(10))</span><br><span class="line">val df = spark.read.json(spark.sparkContext.parallelize(inserts, 2))</span><br><span class="line">df.write.format(&quot;hudi&quot;).</span><br><span class="line">  options(getQuickstartWriteConfigs).</span><br><span class="line">  option(PRECOMBINE_FIELD_OPT_KEY, &quot;ts&quot;).</span><br><span class="line">  option(RECORDKEY_FIELD_OPT_KEY, &quot;uuid&quot;).</span><br><span class="line">  option(PARTITIONPATH_FIELD_OPT_KEY, &quot;partitionpath&quot;).</span><br><span class="line">  option(TABLE_NAME, tableName).</span><br><span class="line">  mode(Overwrite).</span><br><span class="line">  save(basePath)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">那接下来我们要做什么事儿呢？哎，就是呃准备一些数据啊，准备一些咱们来测试的一个数据啊。数据有了之后，呃，来具体的操作一下各种操作，像插入啊、查询啊、更新啊，还有增量查询对吧？啊，增量的那还有指定时间点的查询啊，删除覆盖等等这些方式。</span><br><span class="line"></span><br><span class="line">那么这边呢不建议大家手敲了，为什么呢？啊，有一些需要导入的包啊，那这一块呢咱们就直接先拷贝啊，来拷贝这些import。好，那都import完成之后，接下来我们是呃通过它自带的一个类可以去生成数据。那指定一个变量是表明，那还有呢指定一个它的数据的路径。那这一边为了快速演示，咱们就用一个本地的就好了。OK啊那么大家注意这个数据生成器，这个类是谁呢？是hudi提供的啊，hudi提供的。</span><br><span class="line"></span><br><span class="line">好了，那么接下来呢呃我们就来演示一下插入数据表，我们没有创建对吧？呃，无所谓啊。第一批写入它会判断表是否存在，不存在它就会自己创建的啊所以我们就直接写就可以了。</span><br><span class="line">那么看一下这个写法啊，首先呢我是将呃生成了什么呢？十条数据啊，生成十条数据，然后呢做一个插入啊，这是它固定它的一个api啊，这个就按照这么写就可以了。然后呢将它转成一个list啊，是string字符串啊，之后呢将这个数据读成什么呢？通过Spark上下文然后并行化读取，读取成一个什么呢？读取进来啊，那分区数我指定为2啊，然后呢直接去read Json就可以了，那读成了一个DF</span><br><span class="line"></span><br><span class="line">那通常来讲我们对hudi操作都是用的Spark sql语法啊。你可以用DF去操作啊，也可以写sql啊。好，来，我们把它拿过来。稍等一会儿。好，那其实上面这里就是生成的数据和呃我们转成了这个list，大概就是我们看一条就好了啊。到这里啊，这是一条数据啊，有TS啊、UID啊啊，有rider driver啊对吧？等等一些字段，这是一个出行的一个交通数据。</span><br><span class="line"></span><br><span class="line">好，那接下来我们要将这个DF里的数据写入到hudi里面，那怎么写呢？哎，大家看啊是其实这个写法如果熟悉Spark应该都熟了，呃，通过DF的write方式去写就可以了。那只要格式指定为hudi。那之所以能够指定为hudi，就是因为咱们已经集成好了那个jar包，你已经放进去了，那它就能识别这个hudi格式。接下来下面的这一些写法是hudi特有的啊，跟hudi集成的时候特有的一些写法。呃，那这边我们是设置了一个quick star啊，快速入门的一个案例配置啊，就简单的配置。</span><br><span class="line"></span><br><span class="line">另外呢有几个东西先给大家讲一下，一个叫precombine field，这个东西是什么呢？呃，precome by就是可以理解为预聚合，为什么呢？预聚合字段这个东西主要是通过来去重使用的。另外一个东西是不是叫key啊？Record key啊，这个就是咱们前面一直在在一直在讲的record key，指定record key为UUID这个字段，对吧？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那接下来就讲讲这个precombine有什么用啊。举一个例子啊，比如说我的呃record key是呃有一条数据是1 a 10，呃，那么呃值是比如说a然后这个时间戳比如说是十。那么如果我又来了一条数据，1 a 11，其实这个语句和字段就指定了。哎，我当我的record key相同的时候，因为我们record key是要保持唯一性，对不对？那如果出现重复，它取哪一条啊哪个值，它会取预聚合字段这个值较大的那个数据。比如说有这两条数据啊，record key都是这样啊，都是1重复了对吧？那么它就会取下面这条字段啊，假设咱们precombine filed指定的是timestamp啊，它就取大的啊，所以这个可以简单理解为就是去重的时候用啊。所以你就得呃考虑这个预聚合字段用什么比较合适啊。通常来讲常规的就是用一个时间戳字呢就就比较理想啊。那这个record key你也得去考虑啊，用什么样的好一点，最好你不要说出现大量重复的那就不合适了啊。就类似于你去设计数据库，一张表主键你来怎么设</span><br><span class="line"></span><br><span class="line">那其他的就没什么了。这个是一个什么分区的字段啊PARTITION FIELD，用哪一个作为一个分区字的，然后呢表名tablename就没了。然后呢，模式mode选择一个覆盖，然后保存到路径。这个路径就是hudi表的路径啊 。那你看我们上面已经定义了一对吧？这个base path这是一个基本路径，对吧？路径就写到以表名作为一个文件夹的名称就可以了。好吧？好，那就是关于这几个基本参数的解释</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403141714697.png" alt="image-20240314171428150"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那我们来做一下哈。嗯。好，等他执行完执行完了对吧？那么接下来我们怎么看呢？在我们指定的这个路径下面，应该是有hudi的目录生成的hudi表的目录，还有它对应的什么原数据目录啊数据目录啊。然后我们来搂一眼啊，这个路径我们定义的是本地文件系统tmp。下面来我们瞅瞅一眼cd /tmp，然后呢看一眼啊，这个有点多对吧？但是我们看到了有一个什么hudi_trips_cow</span><br><span class="line"></span><br><span class="line">大家可以看到现在的这个文件夹是什么东西呢？啊，就是分区，就是我们的分区目录，呃，这个就是亚洲对吧？这个是美洲啊，我们的分区是按照这一来的。我们看一下这个数据啊，这里有一个字段叫做partitionpath啊，我们指定它为分区字段对吧？它的只有什么呢什什么啊美洲的啊什么什么什么，你大家可以看到这个值是不是什么嵌套的，有三层对吧？那我们随便看一个吧，比如说这这是其中一个分区啊，是一级分区啊。 ，哎，你是不是看到又有一层文件夹了，那是因为咱们使用了多级分区啊，也就是说多级目录了啊，每周下面的这里还有这里啊，哎随便看一个在里面，还有一层对吧？还有一层好再来再看就没了吧。这里面只有一个什么文件点parquet。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403141715226.png" alt="image-20240314171543022"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403141716459.png" alt="image-20240314171600194"></p>
<h3 id="Shell方式-查询数据-文件命名源码"><a href="#Shell方式-查询数据-文件命名源码" class="headerlink" title="Shell方式_查询数据&amp;文件命名源码"></a>Shell方式_查询数据&amp;文件命名源码</h3><h4 id="转换成DF"><a href="#转换成DF" class="headerlink" title="转换成DF"></a>转换成DF</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那现在有了hudi表，我们来尝试着查询一下那查的话怎么查呢？其实还是一样，从Spark去读取对应路径下的hudi表。啊，这个Spark这个contest我们直接去Spark session嘛啊直接read之后呢，格式指定为hudi。啊，同样的道理，由于我们集成的那个jar包，所以他就能够识别了。另外不要忘了他需要写一个load，也就写到对应的表路径啊，你要读取的hudi表的表路径啊，一定要写到表路径啊。然后呢我们需要呃我们再把它创建成一张临时的视图啊，起个名字OK那这边要注意的是什么呢？这张表我们知道分区字段它里面包含了多级分区啊，对吧？我们是有三级分区的那如果是老版本的hudi，0.9以前的hudi，呃，这个时候我们需要在表路径，然后在拼接上load(basepath+&quot;/*/*/*/&quot;)。呃，这样子也就是说有几层路径你就要拼接几层，那么当前版本就不需要，它自己会去识别啊，这是一个小事情。也就是说你加载路径必须把每一级的分区路径都得表示出来啊，用星号去拼接啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142130980.png" alt="image-20240314213029582"></p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那我们就快速的把它注册成为一个temporal view啊。好，直接还是粘贴就行了啊，这种写法就没必要去敲了啊，浪费时间啊，就很简单的语法。好，有了之后我们是不是可以直接查了呀？啊你可以用DF去show()，也可以用spark sql的语法来写啊，然后可以写一个select语句啊，然后再show()一下啊。我们搂一眼吧啊，这个也没必要敲了，那字段都是我们那个模拟数据。我这边想说明的一点是什么呢？我我尽量缩小，哎，看不清楚啊。我想说的是其实每张呼底表它都有几个隐藏字段，分别是什么呢？你看hoodie_commit_time，那么你看这个是什么？这就是我说的拼接年月日时分秒。那我们仔细看一下啊，这是年月日时分秒毫秒对吧？它是直接拼在一块的啊，而不是说距离1970年有多少时间戳，好吧？</span><br><span class="line"></span><br><span class="line">然后呢还有一个commit的一个序列号啊，其实它基本就是一个时间戳，然后再拼接上其他东西。</span><br><span class="line"></span><br><span class="line">还有这个是什么record key，这个是不是由我们去写入手指定的record key，就是用的UUID啊，还有呢分区路径啊，那这个是多级的，看到没有？再一块看到hoodie_file_name啊，就就文件名对吧？前面基本有几个五个隐藏字段啊，一个小事情。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个正常的查询，你就会Spark就就会了。接下来呃说白了咱们的集成只是放一个jar包，然后格式指定为hudi，还有一些配置项，该指定的去指定就ok了。接下来就是正常的一个操作了。所以对大家来讲应该是没有什么学习成本的啊，无非就是前面我们花了大量的时间去讲那个核心概念啊，那些你把它理解就ok了，用起来的话倒是没有什么难度啊，没有难度。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142218120.png" alt="image-20240314221827909"></p>
<h4 id="时间旅行查询"><a href="#时间旅行查询" class="headerlink" title="时间旅行查询"></a>时间旅行查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spark.read.</span><br><span class="line">  format(&quot;hudi&quot;).</span><br><span class="line">  option(&quot;as.of.instant&quot;, &quot;20210728141108100&quot;).</span><br><span class="line">  load(basePath)</span><br><span class="line"></span><br><span class="line">spark.read.</span><br><span class="line">  format(&quot;hudi&quot;).</span><br><span class="line">  option(&quot;as.of.instant&quot;, &quot;2021-07-28 14:11:08.200&quot;).</span><br><span class="line">  load(basePath)</span><br><span class="line"></span><br><span class="line">// 表示 &quot;as.of.instant = 2021-07-28 00:00:00&quot;</span><br><span class="line">spark.read.</span><br><span class="line">  format(&quot;hudi&quot;).</span><br><span class="line">  option(&quot;as.of.instant&quot;, &quot;2021-07-28&quot;).</span><br><span class="line">  load(basePath)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">另外一个事儿呢就是hudi。还有一种查询方式是叫时间旅行的查询。什么叫时间旅行啊啊，就是我要查询指定时间点的一个commit。就比如说呃现在COMMIT的都多次了啊，时间分是T0、T1、T2。咱不是有个时间线嘛，对不对？时间轴timeline嘛。那我们说timeline呢是一个一个的instant，对不对啊？每个instant都有对应的什么呢？一个是它的instant的时间，还有呢他的动作action，还有他的状态，是不是啊？</span><br><span class="line"></span><br><span class="line">那这个时候已经到了T2以后了，那如果你想查T1的时候，这个时刻的呃数据它的状态也是可以的，你只需要指定一个instant的时间即可啊。那我看一下咱们目前的这个commit time，应该都是一一回事儿啊，应该都是一回事儿。呃，那具体呢就是这么一个配置项就可以了，那我们试一下呗。但是这个时间戳不对啊，这个是以前的那我想想啊，我们现在都一样。</span><br><span class="line"></span><br><span class="line">呃，那也简单，怎么简单呢？我们只需要再重复执行一下前面这个就行了，就插入数据我们再插入一遍呗，再插入一遍啊，就这这呃overwrite我们改成append就可以了呗，稍等一下嗯。好append不就ok了吗？说。但是appen end咱们一会儿再来吧，因为后面咱们要讲更新数据，更新数据其实有点类似于插入新的数据，那回头咱们就要end了啊。这个咱们先呃简单理解一下，一会儿再来玩嘛啊讲到更新的时候再来玩这个事儿啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142149778.png" alt="image-20240314214908287"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">好，那接下来我给大家补充一点啊，就是咱们可以看到这个地方这个pofeket文件前缀这么长，那它到底是什么意思呢？那我听我一一道来吧。啊那么注意它的连接符是什么？是下划线，也就是说咱们根据下划线分成几块来看啊。哎我先在这里切一刀，呃，然后这个下划线再切一刀，哎，然后这个后缀切移到它，其实是由四部分组成。第一部分是什么呢？这么长的一串东西，就是咱们前面一直讲的file ID还记得吧？咱们聊到索引的时候讲过呀，呃每一个它它里面是不是按照文件组来组织的？每一个文件组有一个唯一的file ID啊，当这个呃生成这个文件组生成的时候，这个file ID就已经固定了，不会再变了啊，它默认情况下是通过UUID来取的啊，也就是挺随机的啊。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后中间这个东西呢嗯怎么理解呢？这是它拼接了一个token啊，你可以不用管，呃，那后面这个东西应该就很熟了吧，这个其实就是instant time, 也就是说咱们那个commit time啊。好，那最后一个是什么？就后缀啊。由于咱们COW它只有一个parquet对吧？没有什么点log啊，就简单了。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142153615.png" alt="image-20240314215302423"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那如果你要看源码也简单啊，呃这样呃我这边有一个写好的，你直接搜什么呢？我相应的依赖都放好了，呃，相应的依赖hudi Spark的这个依赖。好，那么接下来咱们直接搜啊control shift加F搜一个什么呢？呃，应该是叫base file，你看啊就这里在FSUTS，这是hudi的类啊，它在这里有个方法叫make base。啊，当然它有两个，有一个回头要被遗弃掉，那这个东西呢大家就看一眼。你看这字符串格式的话，也就你看它是通过什么下划线来拼接的 。第一个是什么？第二个是什么？第三个，第四个。那我们来看吧，第一个是什么呢？File ID。第2个是啥呢？一个token啊，第三个呢是一个instant time。第4个呢就是它的后缀啊扩展名。嗯，就知道这个文件起名是什么规律。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142159247.png" alt="image-20240314215906159"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那说到这儿，我顺便提一嘴，那个如果是log文件呢，在同样这个类里面有一个makelog啊，我搜一下control加F12有1个makeLogFileName啊，那它同样的它是拼接了什么fileID commit time，还有log的后缀啊扩展名，后面它还会跟上一个叫版本啊版本。行，嗯，那就先到这儿了啊。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142204697.png" alt="image-20240314220456197"></p>
<h3 id="Shell方式-更新数据-时间旅行查询"><a href="#Shell方式-更新数据-时间旅行查询" class="headerlink" title="Shell方式_更新数据&amp;时间旅行查询"></a>Shell方式_更新数据&amp;时间旅行查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那接下来我们了解一下怎么来做一个数据的更新。那其实更新很简单，我们直接用一个插入操作就可以了啊，它如果判断recort存在，那么就相当来说会做一个更新了啊，因为我们说的upsert对吧？依赖于索引。如果我判断存在，那我就是做更新操作update，如果不存在，那我就是做insert操作，对吧？就这么简单啊。好，那这个时候我们可以再一次的生成几条数据啊，然后呢呃还是一样通过DF.write的方式往里写。</span><br><span class="line"></span><br><span class="line">那这个时候注意了，咱们的这个写模式要改为append，其他一模一样都不变，跟我们前面插入的都一样啊，那这个我们就直接拷贝就行了。那完事之后呢，就可以去做一个查询了。那么大家注意保存模式通常是就是append啊不要写overwrite啊，除非是第一次建表啊，第一次建表咱们还是用overwrite保险一点啊，或者说你你有需求你就overwrite。</span><br><span class="line"></span><br><span class="line">那这个时候呢，我们再来查一下吧。嗯，我看一下啊，前面的是多少啊啊，什么38342对吧，这个也是38342嗯，都一样啊。我们先看一下这边的变化吧啊呃可能数据没有在对应的这个分区里有体现啊。你看哎这个有啊，</span><br><span class="line"></span><br><span class="line">这是我们刚才这个路径呃，这个表里面的这个分区下面之前呢只有上面这一个什么，那现在多了一个什么呢？这个这个时间点的对吧？第二次commit，那我们知道上面这个呃是属于这个是file ID，你看是一样对不对？也就是说这两个文件属于同一个文件组，但是是不同的fileslice啊。那你看这个token就不一样了啊，然后这个提交时间也不一样了。也就是说，前面这个已经是旧的了，这个是新的了。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142231515.png" alt="image-20240314223119580"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那我看看我怎么把它查出来啊，我们现在不是流式处理，对吧？所以这个DF可能要重新加载一下啊，这是之前加载的DF我们虽然数据已经更新了hudi表，但是这个DF还是老的。老的话那也简单，我重新加载一个DF1啊</span><br><span class="line"></span><br><span class="line">然后呢，路径还是这个表名改一下，对吧？这样的话就ok了嘛。这一次应该没问题。那么大家可以看到现在的commit time有什么呢？有老的这个什么38342，也有新的这个57670啊，那是不是跟这个一样对吧？因为它拼接的这个实力时间其实就是呃我们的commit time啊，这个地方大家就看得懂啊，那record giase是UUID啊生成的，咱们就不用去看了啊，</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142240622.png" alt="image-20240314224033225"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行。那接下来我们顺便来玩一下时间旅行呗，对吧。那时间旅行有几种写法啊，就是你去read的时候啊，就重新去创建这个DF，然后呢你指定一个as.of.instant。然后格式有3种写法。那现在我的话肯定是要用这个完整的这个来写吧。</span><br><span class="line"></span><br><span class="line">哎我先构造一下啊，哎拿过来呃。好，那这个这里的time我要改成我自个儿了，因为我现在只有两个嘛，那就改成老的这个吧，这个38342啊，我旅行回去啊。好，然后load完之后是不是可以生成一个DF啊，对吧？</span><br><span class="line"></span><br><span class="line">呃，通过这个方式重新加载一遍，我们能查查找到全量最新的，那现在我希望恢复到某一个instant的对应的那个时刻的快照。其实这个时间旅行就是查看某一个历史快照嘛</span><br><span class="line"></span><br><span class="line">回车。那么大家看现在一共也就只有十条数据。当时我们第一次是不是插入十条，第二次又插了十条，对吧？第二次的十条可能有更新，有新插入的那你看现在我也没有什么过滤条件啊，一共只有什么这十条。而且这个COMMIT time都是当时的。这个就是所谓的时间旅行啊</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403142247879.png" alt="image-20240314224713827"></p>
<h3 id="Shell方式-增量查询-指定时间点查询"><a href="#Shell方式-增量查询-指定时间点查询" class="headerlink" title="Shell方式_增量查询&amp;指定时间点查询"></a>Shell方式_增量查询&amp;指定时间点查询</h3><h4 id="增量查询"><a href="#增量查询" class="headerlink" title="增量查询"></a>增量查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么接下来我们来聊一下这个增量查询它是怎么来实现的。其实也很简单，就是依赖于咱们这个胎卖还是这个时间轴啊，所以说这个概念很重要。那我们在这个轴上有多个instant，对吧？每个instant对应可能是我们一个动作啊，那么他怎么来实现的？比如说我这时间轴上有多个instant啊，那所谓的增量查询其实很简单，就是我们既然是时间轴，我们就应该能够指定一个时间范围了。啊，所以他我们可以去指定一个叫begin，还可以指定一个end。</span><br><span class="line"></span><br><span class="line">那所谓的增量查询啊，比如说我写个T0、T1、T2、T3、T4。我举个例子啊，如果你想增量查询T4以后新增的数据啊，T4之前的那些我不要啊，我不想查，我只想查T4之后有哪些新增的那简单你只需要怎么做呢？你将begin指向T4，那end你不指定就行了，表示说结束都要啊，就后面的全都要，这个就是所谓的增量查询。那基于此呢，你也可以想一想，那如果我想要查询什么呢？我想要类似前面咱们讲到一个时间旅行，对吧？你是不是可以begin跟end指定为同一个时刻就可以了，对吧？那也可以实现一个时间旅行啊，那包括后面这个指定时间点查询，其实也是通过控制这两个东西的范围来实现的。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151113121.png" alt="image-20240315111301329"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">好吧，那现在废话少说，我们先来实现一个增量查询。那么我们前面有过两次commit对吧？那我们对这一张表的还是要重新加载一下啊，我之前就重新加载一下吧，好吧，先加载进来。好，加载完之后我们来获取指定的开始时间啊。那这个你也可以手动指定说具体的某一个time，但是如果你不想指定的话，也可以通过咱们下面这个sql来实现。就是什么呢？哎，我order by commit time啊. 这个commit time就是这个隐藏列hoodie_commit_time啊。那我们直接对它进行一个distinct啊去重啊，然后再呢一个排序之后呢，我再用map算子啊去getstring(0)啊，然后呢再take(50)，那当然咱们没有50了。好，先看一眼这个commits吧。好，那其实大家可以看到我们这个commans只有两个啊，只有这么两个。好，那既然只有这么两个呢，那接下来呃开始的时间那就是看你也需要哪一个了。</span><br><span class="line"></span><br><span class="line">那那为了更好的演示，这样吧，咱们再插入几次啊，咱们再更新数据。这里不是有一个哎啊是上面啊更新数据，这里不是有一个appen的方式吗？啊，我们多执行几次就行了呗啊，那我再执行三次吧。也就是说呃我一共呢是插入过五次了啊，应该有五个了。你看这里有五个parquet的对吧？每一个版本它都保留下来了，当然有对应的清理策略啊。行，那既然有这么多，我再执行一下。刚才这个哪一个呢？就是咱们增量查询，这里不是呃，我先重新加载一下哈。在读取这个路径啊，创建为相同的这个表明好了。那之后呢还是通过对commit time去重，然后排序啊，封装成为一个commits。再给大家看一下。那大家也可以看到这里已经变了，对吧？那接下来我就直接指定为上一次啊，上一次啊，也就是说我们现在这里有五次了啊，我指定从上一次这个地方开始增量的查询啊，那我们来试一下呗</span><br><span class="line"></span><br><span class="line">那接下来我们就创建这个增量查询的表，怎么创建呢？还是一样read格式维固定。接下来关键是什么？查询类型要改一下，这个查询类型我们更改为叫增量查询啊，这个就固定写法，它封装好的一个常量啊，你就照这么写就行。接下来我们指定一个什么开始时间啊，这个也是一个固定它封装好的一个常量啊。然后把我们得到了这个begintime传进来，然后呢就正常去load的啊，这就ok了呗。然后呢表明我表名就命名为一个增量表，这个一个表名啊。那接下来不要忘了这个begin time先获取一下啊val begintime=commits(commits.length-2)，也就是说获取的是这个什么呃52秒023毫秒了。这个好，那么接下来就是创建这一张增量表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">增量表创建完了，我们来查询这一张增量表，看看它的commit time啊，是不是从我们指定的这个开始时间往后的这一些呢，好吧。那么可以看到，这个是我们的开始时间啊。好，那我们看到现在能查出来的数据，它的committime都是怎么样？是不是都是大于这个时间呢？啊，前面应该都是一样，都是56秒570的了啊，前面这个分钟都是42啊，一样啊。大家看你执行的时间了啊。这个其实就是啊指定一个时间范围过滤出来，所以它的实现原理特别简单。但往往就是我们说对高端的食材，往往只需要最简单的烹饪方式，对吧？</span><br><span class="line"></span><br><span class="line">这就是一个增量查询啊，很简单啊。呃，那么其实大家也可以看到，我们每一次数据变更都重新加载是为啥呢？因为咱们基于这种Spark渲染，它纯粹就是一种什么批处理啊，对吧？我们不是实时的流处理啊。所以呢利用增量查询，我们能够在批处理的数据上创建啊流式的这种管道效果。</span><br><span class="line"></span><br><span class="line">我举个例子，呃，咱们比如说用spark写的，我可以是不是可以设置每5分钟调度一次，也就是说每5分钟执行一次代码。那这个时候你是不是可以每5分钟通过，不写死开始时间，每一次获取的是不是都不一样，对吧？这样就可以实现一个哎5分钟，我只拿到这5分钟的增量数据啊，对不对？就看起来像是一个流式的效果，这是通过Spark来做这么来一个实现啊。</span><br></pre></td></tr></table></figure>

<h5 id="重新加载数据"><a href="#重新加载数据" class="headerlink" title="重新加载数据"></a>重新加载数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark.</span><br><span class="line">  read.</span><br><span class="line">  format(&quot;hudi&quot;).</span><br><span class="line">  load(basePath).</span><br><span class="line"> createOrReplaceTempView(&quot;hudi_trips_snapshot&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="获取指定beginTime"><a href="#获取指定beginTime" class="headerlink" title="获取指定beginTime"></a>获取指定beginTime</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val commits = spark.sql(&quot;select distinct(_hoodie_commit_time) as commitTime from  hudi_trips_snapshot order by commitTime&quot;).map(k =&gt; k.getString(0)).take(50)</span><br><span class="line">val beginTime = commits(commits.length - 2)</span><br></pre></td></tr></table></figure>

<h5 id="创建增量查询的表"><a href="#创建增量查询的表" class="headerlink" title="创建增量查询的表"></a>创建增量查询的表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val tripsIncrementalDF = spark.read.format(&quot;hudi&quot;).</span><br><span class="line">  option(QUERY_TYPE_OPT_KEY, QUERY_TYPE_INCREMENTAL_OPT_VAL).</span><br><span class="line">  option(BEGIN_INSTANTTIME_OPT_KEY, beginTime).</span><br><span class="line">  load(basePath)</span><br><span class="line">tripsIncrementalDF.createOrReplaceTempView(&quot;hudi_trips_incremental&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="查询增量表"><a href="#查询增量表" class="headerlink" title="查询增量表"></a>查询增量表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(&quot;select `_hoodie_commit_time`, fare, begin_lon, begin_lat, ts from  hudi_trips_incremental where fare &gt; 20.0&quot;).show()</span><br></pre></td></tr></table></figure>

<h5 id="指定时间点查询"><a href="#指定时间点查询" class="headerlink" title="指定时间点查询"></a>指定时间点查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好，另外我们一起看一下这个指定时间点吧。所谓的指定时间点是什么意思呢？就是我现在有多次呃commit呃多个instant，那比如说你指定到你要指定的是这一段时间啊它的一个状态就好了。最新的一次我不要这个就是指定时间点，那怎么实现呢？其实就是什么将begin设置为最开始的地方，将end设置为指定的这个time，那这样就可以获取这一段时间的一个一个状态和数据了，对不对？这个跟时间旅行前面讲的那个什么asof那个还是有点区别的啊</span><br><span class="line"></span><br><span class="line">咱们来试一下吧。好，那你看我怎么做啊啊我将开始时间指定为000，表示最开始，然后end的time呢我指定为上一次，对吧？这个写法我们前面唠过了啊。好，先获取这两个，也就是说我指定的范围了。指定完范围之后，我们创建一张表啊，叫时间点查询，一样的格式为hudi啊，咱们去read一下，然后查询类型还是一样，还是这种增量查询啊，增量查询就可以指定begin跟end啊，这是固定写法啊。然后把咱们获取到了两个时间传进来，这个是000，这个是上一次，也就是说还是这个啊从最开始一直到上一次。然后呢，创建了这个表名啊，然后再进行一个查询。很简单吧啊所以你把他的思想本质理解了就可以了。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151141145.png" alt="image-20240315114151514"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么大家可以看到这个committime有哪一些啊？这些是不是通通都小于42分52秒023呢23毫秒对吧？啊，那这个是结束时间的这个时刻啊，那剩下的这些都是比他小比他早的，对不对啊？有这么四次提交的时间，我们能明显看到啊</span><br><span class="line"></span><br><span class="line">接下来可能大家会跟那个时间旅行搞混啊。呃，我刚才是不是创建了一张时间旅行的这个表，对不对啊？所以其实说白了这个时间旅行查询跟这种指定时间点，呃，其实咱们理解起来是一样啊。只要你的开始时间是000，然后end指定为某个点儿，这个就等价于asof一个时间点一个意思啊一个意思呃，行。这个是咱们这个事儿啊。</span><br></pre></td></tr></table></figure>

<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它这个案例数据的生成方式是：假如我每次生成同样的条数，这些数据都是同样的数据，只是数值发生了变化。所以所以时间点只有10条数据</span><br></pre></td></tr></table></figure>



<h4 id="第一次插入后查询"><a href="#第一次插入后查询" class="headerlink" title="第一次插入后查询"></a>第一次插入后查询</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151300656.png" alt="image-20240315130013095"></p>
<h4 id="第一次更新"><a href="#第一次更新" class="headerlink" title="第一次更新"></a>第一次更新</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151300743.png" alt="image-20240315130049905"></p>
<h4 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151301640.png" alt="image-20240315130123850"></p>
<h4 id="第二次更新"><a href="#第二次更新" class="headerlink" title="第二次更新"></a>第二次更新</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151301679.png" alt="image-20240315130145417"></p>
<h4 id="增量查询-一次插入-两次更新-查第一次更新之后"><a href="#增量查询-一次插入-两次更新-查第一次更新之后" class="headerlink" title="增量查询 一次插入 两次更新 查第一次更新之后"></a>增量查询 一次插入 两次更新 查第一次更新之后</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151302104.png" alt="image-20240315130219453"></p>
<h4 id="增量查询-一次插入-两次更新-查第一次插入之后"><a href="#增量查询-一次插入-两次更新-查第一次插入之后" class="headerlink" title="增量查询 一次插入 两次更新 查第一次插入之后"></a>增量查询 一次插入 两次更新 查第一次插入之后</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151302154.png" alt="image-20240315130231468"></p>
<h3 id="Shell方式-删除数据-覆盖数据"><a href="#Shell方式-删除数据-覆盖数据" class="headerlink" title="Shell方式_删除数据&amp;覆盖数据"></a>Shell方式_删除数据&amp;覆盖数据</h3><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">那么接下来就该到删除数据这个事儿了。删除数据前面我跟大家聊到了。来我们看一下第三章核心概念有一个哎应该是在数据写里面有个删除的策略。</span><br><span class="line"></span><br><span class="line">那来那我们说第一种是配置一个什么key。第二种是指定一个PAYLOAD的为空啊空这个类删除所有的。第三是添加一个标记字段对吧？</span><br><span class="line"></span><br><span class="line">那接下来咱们是怎么做呢？啊，执行删除的话，其实我这边做的是第一种方式。指定一个Operation_opt_key啊，然后呢指定为delete啊，这就是第一种方式了。那这种方式呢就是说咱们现在还是什么，其实就是写入啊。你写入比如说你你原先一这张表，12345这五条数据，然后呢你现在要删除3跟4，那简单你构造一个3和4这2条数据啊，然后呢指定为delete做一个什么呢？Insert操作就可以了。啊，做一个write吧啊做一个写入吧那这样的话它就会把3跟4给删掉。其实他也是先标记的一样的，就是这么简单嘛。</span><br><span class="line"></span><br><span class="line">那我们看一下啊，那首先我们先取要删的，先看一下现在这张表啊，原始的这张快照表现在有几条了，先count一下。嗯，呃有十条对吧？啊，有十条好，还是这十条数据。那么取其中的两条哎，来我用了一个limit2，取其中的两条啊用来做删除，构造成一个DS啊，名字叫DS嘛。然后呢。将待删除的两条数据构建DF什么意思呢？把这个前面获取到了这个东西啊，生呃用他官方的一个类啊一个方法，叫生成删除的数据啊就可以了。再把这个deletes最终构造成一个DF好吧。构造完之后就是执行write啊，关键在哪里啊？指定一个key为delete啊，然后呢你正常去write就可以了啊，其他的什么预聚合字段呃，record key啊，分区字段表明保持一致即可。</span><br><span class="line"></span><br><span class="line">好了，删除完之后我们再来统计一下行数有没有变化。你要统计变化后的是不是要重新加载一下，对吧？所以不要忘了重新read一下啊，我这边叫一个新的DF啊。无所谓啊，然后还是这个表名啊。你看原来的十现在变成了8，那这样的话就是实现一个删除的效果。</span><br></pre></td></tr></table></figure>

<h4 id="覆盖数据"><a href="#覆盖数据" class="headerlink" title="覆盖数据"></a>覆盖数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那聊完删除呢，咱们也来聊聊另外一种场景，就是覆盖。对于我们的表或者一个分区来说，如果呀你基本上整个分区的数据都要动了大变了，那这个时候还不如直接覆盖掉来得快，比你说呃一条条拎出来去做更新或者删除，你还不如直接全部覆盖对吧？啊，破罐子破摔啊，这样更好一点，更简单一点。那类似于hive的这种insert overwrite，那咱们目前也是支持的呃。好，那我们看一下啊，那首先我们统计一下当前表的key啊，那我们还是读取格式为hudi读取这张表的路径。然后我们将它的UUID字段，我们不是以它为key吗？对吧？还有它的分区路径啊，把它查出来啊，然后排个序啊之后呢，展现一下当前的key。</span><br><span class="line"></span><br><span class="line">那其实你查隐藏字段也一样啊。它的隐藏字段其实就是这个拼这个嘛，对吧？那现在我就展示的更全一点。好，那现在的key有这么一些，那我们先生成一些新的要用来覆盖的数据，那我还是再什么生成10个呗啊，然后呢呃再把这个生成的这些数据读成一个DF啊，然后过滤一下啊。为什么要过滤呢？因为我生成的数据可能是每个分区的都有。现在我只想演示的是我覆盖这个分区americas，然后这个united states，然后san_fransco这个分区了啊，其他的我就不想动了啊。好执行。</span><br><span class="line"></span><br><span class="line">接下来我们要覆盖这个圣弗兰西斯科这个分区了，那怎么写呢？其他这个写法都一样，还是write。那么注意了，我这个模式还是append，你不要说直接来一个overwrite啊，这个我们说嗯当然也可以，但是不太理想啊。你得考虑你的索引这些是原数据啊，你覆盖的只是数据本身，那原数据这些是不是也要呃稍微更新一下？</span><br><span class="line"></span><br><span class="line">另外呢就是指定一个操作的key，为Insert overwrite就可以了啊，那其他的什么预聚合字段record key啊，还有分区字段该什么是什么啊，表名该什么就什么。好，覆盖完之后，我们再次执行这个东西，来看一下key有没有变化，好不好啊。你看是不不一样了，你看前缀都知道不一样了啊。这个就是要注意的是我刚才跟大家提到，你不要说直接这个DF的这个mode为overwrite就完事了啊，这种不规范啊不规范还是用hudi方式来overwrite，为什么呢？又涉及到原数据的。嗯。</span><br></pre></td></tr></table></figure>

<h5 id="查看当前表的key"><a href="#查看当前表的key" class="headerlink" title="查看当前表的key"></a>查看当前表的key</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark.</span><br><span class="line">  read.format(&quot;hudi&quot;).</span><br><span class="line">  load(basePath).</span><br><span class="line">  select(&quot;uuid&quot;,&quot;partitionpath&quot;).</span><br><span class="line">  sort(&quot;partitionpath&quot;,&quot;uuid&quot;).</span><br><span class="line">  show(100, false)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403151540215.png" alt="image-20240315154033633"></p>
<h5 id="生成一些新的行程数据"><a href="#生成一些新的行程数据" class="headerlink" title="生成一些新的行程数据"></a>生成一些新的行程数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val inserts = convertToStringList(dataGen.generateInserts(10))</span><br><span class="line">val df = spark.</span><br><span class="line">  read.json(spark.sparkContext.parallelize(inserts, 2)).</span><br><span class="line">  filter(&quot;partitionpath = &#x27;americas/united_states/san_francisco&#x27;&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="覆盖指定分区"><a href="#覆盖指定分区" class="headerlink" title="覆盖指定分区"></a>覆盖指定分区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.write.format(&quot;hudi&quot;).</span><br><span class="line">  options(getQuickstartWriteConfigs).</span><br><span class="line">  option(OPERATION.key(),&quot;insert_overwrite&quot;).</span><br><span class="line">  option(PRECOMBINE_FIELD.key(), &quot;ts&quot;).</span><br><span class="line">  option(RECORDKEY_FIELD.key(), &quot;uuid&quot;).</span><br><span class="line">  option(PARTITIONPATH_FIELD.key(), &quot;partitionpath&quot;).</span><br><span class="line">  option(TBL_NAME.key(), tableName).</span><br><span class="line">  mode(Append).</span><br><span class="line">  save(basePath)</span><br></pre></td></tr></table></figure>

<h5 id="查询覆盖后的key，发生了变化"><a href="#查询覆盖后的key，发生了变化" class="headerlink" title="查询覆盖后的key，发生了变化"></a>查询覆盖后的key，发生了变化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark.</span><br><span class="line">  read.format(&quot;hudi&quot;).</span><br><span class="line">  load(basePath).</span><br><span class="line">  select(&quot;uuid&quot;,&quot;partitionpath&quot;).</span><br><span class="line">  sort(&quot;partitionpath&quot;,&quot;uuid&quot;).</span><br><span class="line">  show(100, false)</span><br></pre></td></tr></table></figure>

<h3 id="SQL方式-环境准备-创建表"><a href="#SQL方式-环境准备-创建表" class="headerlink" title="SQL方式_环境准备&amp;创建表"></a>SQL方式_环境准备&amp;创建表</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403152344924.png" alt="image-20240315234439932"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hive --service metastore &amp; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面我们尝试的用shell的方式来操作，但毕竟还是要写一些代码，对吧？啊，写DF等等这些可能不太方便，那如果我们能够用sql方式来操作，那就很舒服了啊，那它也是支持的，那么接下来我们来做啊，第一个呢，就是由于我们要启动一个Spark sql的这么一个交互式的命令行客户端，呃，所以呢，它会默认会去连接hive的啊，所以我们需要呃，需要做的就是将hive的原数据服务启动起来，那这边就要求你hive的原数据服务是配置为外置的单独的服务，而不是默认的内嵌啊，什么意思呢？啊，说白了就是你的hive，你看一下。在这里你有没有配这个东西？hive.metastore.uris啊，如果配的这个就表示它需要单独启动的一个原数据的外置服务啊9083啊</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403152346252.png" alt="image-20240315234649889"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#针对Spark 3.2</span><br><span class="line">spark-sql \</span><br><span class="line">  --conf &#x27;spark.serializer=org.apache.spark.serializer.KryoSerializer&#x27; \</span><br><span class="line">  --conf &#x27;spark.sql.catalog.spark_catalog=org.apache.spark.sql.hudi.catalog.HoodieCatalog&#x27; \</span><br><span class="line">  --conf &#x27;spark.sql.extensions=org.apache.spark.sql.hudi.HoodieSparkSessionExtension&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行，那我们起一下呗，嗯，啊，去哪个路径都行啊，我配的环境变量的啊啊我直接呢，呃，我直接后台启动吧，nohup hive --service metastore &amp;</span><br><span class="line">日志也不要了，那些我就不管了啊。好，那接下来我们看一下端口监听了没有，netstat -anp|grep 9083。好，现在已经是监听状态啊，这个metastore服务应该是启动起来了</span><br><span class="line"></span><br><span class="line">那接下来我们就要启动这个Spark sql这么一个客户端就可以了，那同样要指定三个配置啊，第一个kryo,第二个catog啊，第三个就extension，那么catalog还是hudi提供的，那extension呢，用的hudi的。那为什么会用到hive呢？其实跟这个catalog有关系</span><br><span class="line"></span><br><span class="line">那么大家知道什么叫catalog呢？啊，学过的应该都知道啊，Catalog直接翻译是目录的意思啊，那如果我们简单的不讲那些专业术语，简单来讲就是在数据库之上的一层，呃，抽象，也就是说先有catalog，再有数据库叫database，比如说哪个库哪个库，那我们知道每个库里面是不是有一张一张的table啊啊，这是常规的一个组织关系，对吧？那现在再多一层叫catalog啊</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403152349008.png" alt="image-20240315234954110"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那外部系统啊，比如说Spark就可以通过这种catalog的东西，也比如说跟hive去做一个打通啊。他有一个hive catalog。好，那这边hudi它默认实现hudi catalog，其实它用的就是底层源码，用的是hive catalog啊，所以这也是为什么如果你不启动hive这个东西，你直接去启动啊，会报错什么原数据服务什么啊，拒绝连接呀啊，无法实例化原数据啊这些东西啊，那是因为这个事啊</span><br><span class="line"></span><br><span class="line">行啊，那如果你的机器上面没有装hive，你就简单装一下呗啊，那装完之后最好配一下环境变量，这样的话你就不用做额外的操作了，如果没有hive环境变量啊，也就这个时候你要手动拷贝你的hive配置文件到Spark的配置目录下，说白了就一句话，你要能够让Spark能读取到hive的配置就可以了啊，要么你配环境变量，要么你拷贝呃，它的配置文件</span><br><span class="line"></span><br><span class="line">那我现在是只要原数据服务启动的，呃，我环境是能读到hive那个配置的。所以我直接输入命令来启动我的Spark sql，那这个时候就进来了，这个时候我比如说我show databases。呃。看一眼，那么大家能看到有这么多库对不对啊，这些其实是我的什么，我的hive当中存在的一些数据库啊，这个就是我们Spark sql的启动方式啊</span><br></pre></td></tr></table></figure>

<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那接下来我们讲一下这个建表语句啊在呃，简单先下面看一个例子吧，啊，就是正常的写一个DDL那就是create table,然后定义字段的类型啊就行了，那无非是在后面加一个using hudi啊，表示为是hudi表啊，另外呢，可以通过指定一些表的参数来指定hudi相关参数，像比如说最常见的是这三个，第一个呢是type，也就是说表的类型，你是MOR还是COW，在这边可以去做一个指定，默认不指定的话，都是COW。</span><br><span class="line"></span><br><span class="line">我们在前面渲的时候，并没有指定什么表类型，对不对，那是因为默认就是cow啊。另外一个primary key,这个就等于所谓的record key啊，就是我们的记录键啊</span><br><span class="line"></span><br><span class="line">那还有一个预聚合的字段，这个我们说了主要是我主键相同啊，这个时候该取哪一条数据去重的时候对吧？啊以指定的预合并字段值大的为准啊，那一般我们用时间戳会更好一点啊。</span><br><span class="line"></span><br><span class="line">好，这个就是一一些建表参数啊，那这个主键如果我们不指定的话，它默认是取得UUID啊，一个随唯一的随机值啊。</span><br></pre></td></tr></table></figure>

<h5 id="创建非分区表"><a href="#创建非分区表" class="headerlink" title="创建非分区表"></a>创建非分区表</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403160006972.png" alt="image-20240316000626130"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_cow_nonpcf_tbl (</span><br><span class="line">  uuid int,</span><br><span class="line">  name string,</span><br><span class="line">  price double</span><br><span class="line">) using hudi;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那我们尝试建一个吧啊。那比如说我们先来创建一个非分区表，这个地方呢，我们建一个cow表。呃，那你看我这个语法只起了表明指定的字段，Using的who，后面那个表参数都不指定，也就是说这个时候我用的都是什么，都是默认值，默认值呢就是CoW表，默认的主键就是UUID，那默认的预聚合字段就是没有啊，就是没有啊，就这个意思啊</span><br><span class="line"></span><br><span class="line">我们来执行一下啊，呃，我们创建一个database吧的spark_hudi，当然你这个库无所谓啊，那我show tables.你看这张表就好了吧，啊，你desc hudi_cow_nonpcf_tbl一下啊。对吧？啊，那这张表我们建表时指定的这三个字段啊，</span><br><span class="line"></span><br><span class="line">我们说了hudi表它有个特点，就是最前面会有5个隐藏列啊，那分别是什么？提交时间，提交序列号啊，Record key啊，分区路径啊，还有文件名啊这五个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_mor_tbl (</span><br><span class="line">  id int,</span><br><span class="line">  name string,</span><br><span class="line">  price double,</span><br><span class="line">  ts bigint</span><br><span class="line">) using hudi</span><br><span class="line">tblproperties (</span><br><span class="line">  type = &#x27;mor&#x27;,</span><br><span class="line">  primaryKey = &#x27;id&#x27;,</span><br><span class="line">  preCombineField = &#x27;ts&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个就是一个简单的建表，那接下来来我们建一个MOR的非分区表，怎么建呢？那简单前面都一样，我不啰嗦了啊，咱们快速过，那就是表属性，然后呢，类型为MOR啊，那指定主键为ID字段啊，指定预合并为ts字段啊，这个是最完整的一个写法啊啊，这个同样直接拿过来啊。</span><br><span class="line"></span><br><span class="line">好，desc hudi_mor_tbl。前面同样有5个什么隐藏列，而且默认类型都是string啊，都是string。</span><br></pre></td></tr></table></figure>

<h5 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_cow_pt_tbl (</span><br><span class="line">  id bigint,</span><br><span class="line">  name string,</span><br><span class="line">  ts bigint,</span><br><span class="line">  dt string,</span><br><span class="line">  hh string</span><br><span class="line">) using hudi</span><br><span class="line">tblproperties (</span><br><span class="line">  type = &#x27;cow&#x27;,</span><br><span class="line">  primaryKey = &#x27;id&#x27;,</span><br><span class="line">  preCombineField = &#x27;ts&#x27;</span><br><span class="line"> )</span><br><span class="line">partitioned by (dt, hh)</span><br><span class="line">location &#x27;/tmp/hudi/hudi_cow_pt_tbl&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么如果我们要创建分区表，用怎么样的语法呢？啊，也简单了解一下啊，如果是个分区表呢，无非就是大家注意位置啊，是写在后面啊，那么这个表属性是在分区语法的前面啊，也就是说前面这个是我们刚刚试过的，只要在后面加上partitioned by，那分区字段可以是多个字段表示多级分区啊，就多级目录啊。大家注意这个分区这个关键词是有ED结尾的啊不要忘了啊，大家容易忘这个事儿啊。然后指定表的路径，这个跟hive的写法有点像吧啊，所以对于大家来讲没有什么学习成本。</span><br><span class="line"></span><br><span class="line">那我就手动敲一下吧。啊比如说我的分区要按照dt跟hh啊来做一个分区。那这个时候这张表就建好了，我们desc下啊。这呃你看那现在DSC我们都看到了一个什么分区信息啊，由于我们指定了两个分区字段啊，好，回头我们去插入数据的时候再来去看。</span><br></pre></td></tr></table></figure>

<h5 id="在已有的hudi表上创建新表-非分区"><a href="#在已有的hudi表上创建新表-非分区" class="headerlink" title="在已有的hudi表上创建新表-非分区"></a>在已有的hudi表上创建新表-非分区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_existing_tbl0 using hudi</span><br><span class="line">location &#x27;file:///tmp/hudi/dataframe_hudi_nonpt_table&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那还有一种用的方式就是在我们已经存在的hudi表再创建一张新表啊，这种东西呢。你可能以为是CTAS对吧？什么叫CPAS呢？就什么create table，然后呢as或者like这种，呃，主要是like吧，但呃是支持没错啊，这个是后面呃后面咱们来讲。</span><br><span class="line"></span><br><span class="line">那还有一种用的方式就是我直接指定什么这个location。因为这个路径是已经存在的那这个时候呢呃我们不需要再去指定什么字段呢，还有表属性这些东西，为什么呢？因为它可以自动识别模式还有配置。因为大家还记得吧，我们说表路径下面会有什么？表路径下面会存储了咱们的原数据信息，还记得吧？</span><br><span class="line"></span><br><span class="line">因为它有一个.hoodie。所以咱们直接指定到location，它就会自动识别模式，还有咱们的配置。那如果你不要分区，那你就不要写分区呗，要分区你就partitioned by就可以了，就这么简单啊。</span><br></pre></td></tr></table></figure>

<h5 id="在已有的hudi表上创建新表-分区表"><a href="#在已有的hudi表上创建新表-分区表" class="headerlink" title="在已有的hudi表上创建新表-分区表"></a>在已有的hudi表上创建新表-分区表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_existing_tbl1 using hudi</span><br><span class="line">partitioned by (dt, hh)</span><br><span class="line">location &#x27;file:///tmp/hudi/dataframe_hudi_pt_table&#x27;;</span><br></pre></td></tr></table></figure>

<p>通过CTAS(Create Table As Select)建表-非分区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_ctas_cow_nonpcf_tbl</span><br><span class="line">using hudi</span><br><span class="line">tblproperties (primaryKey = &#x27;id&#x27;)</span><br><span class="line">as</span><br><span class="line">select 1 as id, &#x27;a1&#x27; as name, 10 as price;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">那就是将一个表的查询结果啊，将它作为我的表啊，这个语法我们应该是特别常见嘛。呃，另外大家注意它CTAS这种语法的话，它是用批量插入作为写操作的啊啊批量插入也就是说帮将整个结果集一次性插入咱们这个table啊。好，那CTAS呢咱们这边举了三种例子，对吧？啊，分别是什么呢？呃，比如说我创建COW非分区表，那说白了就是还是那几件事儿啊。你表属性要不要指定type，要不要指定主键，要不要指定预合并，对吧？呃，另外呢就是要不要有partitioned by字段啊，就这几个都可以啊，都灵活来设啊。</span><br><span class="line"></span><br><span class="line">那你看下面就是既有type又有主键，又有啊预聚合又有分区，这个是最完整的对吧？好，</span><br><span class="line"></span><br><span class="line">那这边哦对，有一个事提醒，就是咱们hive建表的时候啊，我们的分区字段是不是不会写在建表的字段列表当中啊，对吧？这是额外的一个字段是不是？但是在hudi当中我们是这样的啊，就是说你这个分区字段必须出现在你的定义的字段列表当中啊。</span><br><span class="line"></span><br><span class="line">那么大家注意一下，我是不是没有指定location啊？没有指定location，它默认会保存到Spark的默认那个配置路径spark-3.2/spark-warehouse/...</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ttyong/hexoBlog/master/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi/202403160043572.png" alt="image-20240316004342426"></p>
<h5 id="通过CTAS-Create-Table-As-Select-建表-分区"><a href="#通过CTAS-Create-Table-As-Select-建表-分区" class="headerlink" title="通过CTAS(Create Table As Select)建表-分区"></a>通过CTAS(Create Table As Select)建表-分区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table hudi_ctas_cow_pt_tbl</span><br><span class="line">using hudi</span><br><span class="line">tblproperties (type = &#x27;cow&#x27;, primaryKey = &#x27;id&#x27;, preCombineField = &#x27;ts&#x27;)</span><br><span class="line">partitioned by (dt)</span><br><span class="line">as</span><br><span class="line">select 1 as id, &#x27;a1&#x27; as name, 10 as price, 1000 as ts, &#x27;2021-12-01&#x27; as dt;</span><br></pre></td></tr></table></figure>

<h5 id="通过CTAS从其他表加载数据"><a href="#通过CTAS从其他表加载数据" class="headerlink" title="通过CTAS从其他表加载数据"></a>通过CTAS从其他表加载数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建内部表</span><br><span class="line">create table parquet_mngd using parquet location &#x27;file:///tmp/parquet_dataset/*.parquet&#x27;;</span><br><span class="line"></span><br><span class="line"># 通过CTAS加载数据</span><br><span class="line">create table hudi_ctas_cow_pt_tbl2 using hudi location &#x27;file:/tmp/hudi/hudi_tbl/&#x27; options (</span><br><span class="line">  type = &#x27;cow&#x27;,</span><br><span class="line">  primaryKey = &#x27;id&#x27;,</span><br><span class="line">  preCombineField = &#x27;ts&#x27;</span><br><span class="line"> )</span><br><span class="line">partitioned by (datestr) as select * from parquet_mngd;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那还有一种呢CTAS还可以什么用location的方式来加载。咱们前面讲的这个location是不是包含了什么呢？包含了一些属性配置，还有字段信息啊。那比如说你要创建一张内部表啊，所谓那个表是咱们说的的啊，那using就是什么呢？parquet，大家注意这边不是hudi了啊。如果你写的是hudi，那是一种外部表。什么叫外部表呢？外部表意思就是说我数据的路径啊可能在某个地方我单独指定就行了。我的DDL建表只是一个建表语句原数据而已。好，那location可能是某个地方的parquet对吧？</span><br><span class="line"></span><br><span class="line">啊，那如果是通过CTAS加载数据，那除呃你可以用hoodie，然后location之后可以去单独指定一些配置啊，这个咱们就了解一下就行啊，partitioned by，然后呢再去stat。他是不是也是as select按是起来就将这个数据加载到这张表里面。那其实相当于就是什么？就是说一些属性我要自己来定义，而不是使用默认配置，就这样而已嘛。这个是简单说一下一个CTAS的用法。</span><br></pre></td></tr></table></figure>

<h4 id="插入-查询"><a href="#插入-查询" class="headerlink" title="插入&amp;查询"></a>插入&amp;查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在呢我们就来给前面创建了几张表啊，我们去插入一些数据啊，然后我们先看一下这些表，呃，so对吧？那我们现在是有这么几张表了，那比如说来一个非分区表啊，就最开始建的这张表，我们先insert in two。这张表啊，然后呢它的表结构是啥来着啊，无所谓，咱们直接拷贝吧。啊是这张表没错啊，就插入一条数据。哎，多了一个insert，呃，select好回车。由于咱们没指定啊啊，所以它的路径会是在哪呢？在这个地方啊，咱们没有指定location，没没有指定location对吧？啊，那这个时候我们就来到默认路径呗。这里有一个Spark warehouse，那来了一个spa y house。再看一看里面，你看有一个Spark hooody啊，这么一个数据库的路径都是依赖于文件系统的啊。好，那你看啊咱们现在有这么几个了。那我们是这个固底COW看一下这里面现在是不是有一个pfet，对吧？啊，我们一起来回顾一下，看一下原数据怎么看呢？IS杠AR这里能看到什么呢？点弧底点蝴蝶，那还有一个什么分区的云数据啊，我们说了没有指定分区字段，那整个表的路径就是大的一个分区路径啊，相当于是这样啊，就相当于说有个默认的大分区啊。行，嗯，呵呵。好，那同样对另一张表，MOR表我们也去插入一下。呵呵。对吧啊，也是执行成功了。我们来看一下数据有没有生成，就这张啊M2你也可以直接去那个select一下啊。那你看也有帕灰特了啊。好，行啊，这个应该都ok另外一种就是咱们的动态分区写法。哎，我就是说我我是一张分区表，但是呢分区我不写死，分区的值不写示，哎，我只需要传一个什么呢分区字段就可以。那么回头呢咱们大家注意了，你后面不是跟上一个senlight吗？啊，反正总而言之，跟上一个结果集，最后的字段就跟分区字段匹配啊。那比如说你分区字段是两个，那么倒数第二个字段的值那就是呃这个DT的值。那最后的一个值就是这个HH的值啊，它是根据这个字段的顺序来对应的的这跟hif的一个用法还是基本一致的。好，那我们来尝试着，哎，我不指定分区让他去哎，不对啊，在这里让他去插入之后呢，咱们只需要去看一看这个呃。好，那我们先看一下这张表呗，呃，COWPTTVL是哪张表来着？进来太多COWPTTTB22这张表是吧？看确认一下啊，PTTBR啊，行，那就这个我们先看一下这里有没有。呃，不在这儿啊，因为我们当时建表时候指定一个什么location啊，指定一个location。好，那既然指定了location，我们就去在这看呗啊，我再拷贝一个窗口出来。哦，这个是HDFS路径了，现在就是那这样的话，我的hadoop我看起了没有，他豆粉是起的，那么啊这里有啊。我来到跟路径看看咱们指定的那个TNP，哎，然后有个HO底啊，然后你看这张表是不是现在就有了，它不存在就会自动帮我们创建。哎，点进来哎发现了哎，它自动在这个表路径下面生成了一个呃分区路径啊。就咱们是动态插入的嘛啊还有原数据对吧？这里面呢还有第二层分区HH还有呢哎这里就是一个part回的文件了。好，嗯，这个就是像分区呃动态插入啊，动态分区插入这个可以说应该是特别常用，特别好用啊。另外一种就是往斜死的分区去做一个插入操作啊，就还是同样的表，咱们在银色的时候指定塔金水为具体的值，那这样的话就是一个指定分区的插入了。那么也是快速执行一下啊，这些语法都跟have或者说Spark sql的语法啊。如果你要指定为本地文件系统啊，就比如说咱们创建表的时候，这个地方呃你没有加协议，默认就是HDFS是吧？如果你要本地的话，你应该是这么写呃，fire啊，对吧？啊，这样来写，那就这就是一个本地的。好，那完事之后我们只需要确认什么，刚才是不是只有一个十这么一个分区，我们看看有没有生成新的分区啊，你看现在是不是生成了一个11的这个二级分区啊，这里面也有数据了，这个就是一些插入啊。另外一个就单独介绍一个我们的这个boook insert批量导入这么一种插入方式。这种一般是用来做一个呃历史数据的初始化啊，举个例子啊，呃你现在呢有大量的数据，有比如说有1亿条历史数据，现在你们要开始上数据湖了啊，要上foody了，要数据路湖了。那这个时候呢我建议说历史数据的导入就用这种方式啊，boook insert. 啊，那要用它呢其实就是呃开启两个配置。第一个呢就是这个，第二个呢就指定为插入模式，为非研究模式啊非研究模式。来，我们先来执行一下，比如说MOR这张表，我们再插入一条数据啊，这个时候呃我们都不去指定这个参数，对吧？还没指定这个时候默认为什么upset啊？我就是插入或更新啊，插入或更新，我们先查一下这张表啊。之前呢我们是插入过一条数据，是不是啊？1A1 21A1 20。那现在相当于说我要把A一的名字改为A一下划线一啊，这样子。好，先插入。好，完事之后呢我们再来查询那个隐藏字段，咱们就不看了对吧？我们只要看它的结果值，哎，你看这个name是不是从原先的，我看在哪个地方，原先的A一现在变成了A一下划线一了啊，这就实现了一个更新的效果嘛，这个TS也被我们更新掉了嘛，对吧？啊，我们说我们指定了那个precombine预合并字段，如果咱们的record d相同，它就会取预合并字段值大的那条数据，对吧？那我们指定的ID为什么呢？Id就是咱们的record key啊都是一啊，然后呢这个TS大的就是这个1001啊，就取它，这就实现了一个更新覆盖的效果。嗯，行，哼那我们要用boke银色的。注意啊，要求你这张表指定的玉合并的key啊才可以啊，要不然会报错的啊。呃数据也会不准确，这样的话就可以保证一个数据的一致性的插入的时候，好，那我们先把这两个参数给开启一下啊，我们set的方式让它临时生效啊就ok了啊，set一下。好，现在已经是触跟非严格了，开启之后呢咱们再去插入，大家可以看一下啊。我再插入，相当于说嗯这个内蒙又变了，ts呢是1002啊，也就看一下它的方式会是什么。来我们再查询一遍，这个时候你会发现哎，居然有相同ID为一的存在，也就是说它并没有执行upset。我们这张表是有预合并字段的，但是没有执行F4。如果是前面这种upset的效果，大家也看到它是不是直接覆盖掉，更新掉啊，对吧？那现在是批量导入的话就不会了啊，他就会把这条新的数据也插入进来而已啊而已嗯。好，那接下来查询就不用讲了，查询就是一个select语法就可以了啊。那这个我们其实我们已经执行过seat了啊，所以这个没什么好演示的，这个大家都会啊，谁都会啊。那么查询这里呢我们需要单独来强调一下时间旅行。那么在渲染方式当中我们已经试过了，那么接下来我们用circle方式来实现啊。那注意版本要求hoooding是要0.9以上，另外Spark你要circle方式要求3.2以上，不然circle方式是不支持的。那么为了避免前面的影响呢，咱们不是开了一个box insert吗？对吧？呃，那这个地方我们先把它关掉，把它制成一个false。那那个非严格模式还是保持非严格就可以了啊，其他不动。那我们再建一张新的表啊，这个什么表一对吧？字段还是这几个啊，ID name TSDT还有HH分区呢咱们还是以两个字段分区啊，路径呢也指定一下。呃，COW呃组件ID预合并字段TS啊，就这样子跟前面建表基本一样啊，为了不干扰我们再建一张新的。建完之后呢，咱们开始插入数据了啊，先插入这么一条简单的数据啊，1ID为一，内为A0，TS为1000啊，后面是两个分区字段。好，插入完咱们在现查吧。好，现在说没找到，他会去给我们创建的。好，我们查询一下数据呢，缩小一点啊，数据现在是进来了，你看ID name TS还有两个分区。好，那接下来我们对它进行修改，现在我们是upset的模式，对不对啊？那这个时候ID呃组件相同，那就会取域合并字段大的这一条，也就是它也就可以将A一更A0更新成了A一啊，你看后面这个分区一样的啊一样的好做一个更新操作。哎，嗯好，更新完之后我直接上翻查询。那我们缩小一点看一下这个值已经变了，对不对啊？已经从A0变成了A1。Ok也就是说现在进行了两次的commit，那现在呢我们要基于第一次这个时候做一个时间旅行，怎么写呢？呃，这么写啊，就是你正常的查询加上一个什么语法呢？Time stand time stand as of. As of of什么什么东西呢？当时的那个instant type，那我们刚才查过是有的，对吧？当时的时间是这个啊，第二次提交的时间是这个，那么就指定时间履行到这个时候啊去查。如果查出来是A0 1000，那就说明就是没毛病了，对吧？啊，那当然这边的写法有几种啊几种。呃，一个是写完整的时间戳，年月日10分秒毫秒。另外一个呢是写一个日期date格式的啊，有有连接符的这种啊也可以。再有一个呢，你只写到日，表示从0点0分开始啊，那我们现在用就用第一种呗。那这个时间戳我们就从刚才查询的A零它对应的这个commit time来就可以了。好拷贝，那这边注意加一个单引号啊，单引号。好，行，来回车。哎，注意看我们查出来的是什么A零是吧？哎，我们把它的历史状态给查出来了。如果你不加这个，那查出来就是最新的A一了。这个就是世界旅行，这个应该说还是比较好用啊，可以查询多版本啊，这个是世界旅行啊。</span><br></pre></td></tr></table></figure>

<h4 id="更新数据-Update"><a href="#更新数据-Update" class="headerlink" title="更新数据_Update"></a>更新数据_Update</h4><h4 id="更新数据-MergeInto"><a href="#更新数据-MergeInto" class="headerlink" title="更新数据_MergeInto"></a>更新数据_MergeInto</h4><h4 id="删除-覆盖数据"><a href="#删除-覆盖数据" class="headerlink" title="删除&amp;覆盖数据"></a>删除&amp;覆盖数据</h4><h4 id="修改表结构、分区-存储过程"><a href="#修改表结构、分区-存储过程" class="headerlink" title="修改表结构、分区&amp;存储过程"></a>修改表结构、分区&amp;存储过程</h4></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">智汇君</div><div class="post-copyright__author_desc">路漫漫其修远兮，吾将上下而求索！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/01/17/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/01/17/尚硅谷大数据技术之数据湖Hudi-3/')">尚硅谷大数据技术之数据湖Hudi-3</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/01/17/%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Tech智汇站</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>大数据<span class="tagsPageCount">27</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/17/%E5%BB%96%E9%9B%AA%E5%B3%B0java-Spring%20Boot%E5%BC%80%E5%8F%91%201/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">廖雪峰java-Spring Boot开发 1</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/17/%E5%B0%9A%E8%A7%82%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B9%8Boracle%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%201/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">尚观云计算之oracle数据库 基础部分 1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%201/" title="2022黑马数据湖架构开发Hudi"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20flink%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 flink集成 1</div></div></a></div><div><a href="/2025/01/17/2022%E9%BB%91%E9%A9%AC%E6%95%B0%E6%8D%AE%E6%B9%96%E6%9E%B6%E6%9E%84%E5%BC%80%E5%8F%91Hudi-%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87%20spark%E9%9B%86%E6%88%90%201/" title="2022黑马数据湖架构开发Hudi-应用进阶篇 1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">2022黑马数据湖架构开发Hudi-应用进阶篇 1</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%85%2017/" title="oracle数据库开发与应用 存储过程、函数和包 17"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 存储过程、函数和包 17</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%2016/" title="oracle数据库开发与应用 数据库编程 16"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 数据库编程 16</div></div></a></div><div><a href="/2025/01/17/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%20%E6%B8%B8%E6%A0%87%E5%92%8C%E5%BC%82%E5%B8%B8%2019/" title="oracle数据库开发与应用 游标和异常 19"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-17</div><div class="title">oracle数据库开发与应用 游标和异常 19</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">智汇君</h1><div class="author-info__desc">路漫漫其修远兮，吾将上下而求索！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/contact/" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(/img/博客微信公众号图片.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B9%96Hudi-3"><span class="toc-number">1.</span> <span class="toc-text">尚硅谷大数据技术之数据湖Hudi-3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99"><span class="toc-number">1.1.</span> <span class="toc-text">数据写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B-UPSERT"><span class="toc-number">1.1.1.</span> <span class="toc-text">写流程(UPSERT)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#COW"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">COW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MOR"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">MOR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B-INSERT"><span class="toc-number">1.1.2.</span> <span class="toc-text">写流程(INSERT)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#COW-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">COW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MOR-1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">MOR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B-INSERT-OVERWRITE"><span class="toc-number">1.1.3.</span> <span class="toc-text">写流程(INSERT OVERWRITE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5-%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text">Key生成策略&amp;删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E4%B8%8ECompaction"><span class="toc-number">1.1.5.</span> <span class="toc-text">数据读与Compaction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hudi%E9%9B%86%E6%88%90Spark"><span class="toc-number">1.2.</span> <span class="toc-text">Hudi集成Spark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-%E5%90%AF%E5%8A%A8Shell"><span class="toc-number">1.2.1.</span> <span class="toc-text">环境准备&amp;启动Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E6%96%B9%E5%BC%8F-%E5%87%86%E5%A4%87%E5%8F%8A%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">Shell方式_准备及插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E6%96%B9%E5%BC%8F-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E6%BA%90%E7%A0%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">Shell方式_查询数据&amp;文件命名源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90DF"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">转换成DF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%97%85%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">时间旅行查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E6%96%B9%E5%BC%8F-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE-%E6%97%B6%E9%97%B4%E6%97%85%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">Shell方式_更新数据&amp;时间旅行查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E6%96%B9%E5%BC%8F-%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2-%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E7%82%B9%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">Shell方式_增量查询&amp;指定时间点查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">增量查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.5.1.1.</span> <span class="toc-text">重新加载数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9AbeginTime"><span class="toc-number">1.2.5.1.2.</span> <span class="toc-text">获取指定beginTime</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%A1%A8"><span class="toc-number">1.2.5.1.3.</span> <span class="toc-text">创建增量查询的表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%A2%9E%E9%87%8F%E8%A1%A8"><span class="toc-number">1.2.5.1.4.</span> <span class="toc-text">查询增量表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E7%82%B9%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.5.1.5.</span> <span class="toc-text">指定时间点查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D"><span class="toc-number">1.2.6.</span> <span class="toc-text">实操</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%90%8E%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">第一次插入后查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">第一次更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%97%85%E8%A1%8C"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">时间旅行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">第二次更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2-%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5-%E4%B8%A4%E6%AC%A1%E6%9B%B4%E6%96%B0-%E6%9F%A5%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0%E4%B9%8B%E5%90%8E"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">增量查询 一次插入 两次更新 查第一次更新之后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2-%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5-%E4%B8%A4%E6%AC%A1%E6%9B%B4%E6%96%B0-%E6%9F%A5%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E4%B9%8B%E5%90%8E"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">增量查询 一次插入 两次更新 查第一次插入之后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell%E6%96%B9%E5%BC%8F-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-%E8%A6%86%E7%9B%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.7.</span> <span class="toc-text">Shell方式_删除数据&amp;覆盖数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">覆盖数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%A1%A8%E7%9A%84key"><span class="toc-number">1.2.7.2.1.</span> <span class="toc-text">查看当前表的key</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E8%A1%8C%E7%A8%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.7.2.2.</span> <span class="toc-text">生成一些新的行程数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.7.2.3.</span> <span class="toc-text">覆盖指定分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84key%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.7.2.4.</span> <span class="toc-text">查询覆盖后的key，发生了变化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%96%B9%E5%BC%8F-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">SQL方式_环境准备&amp;创建表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">创建表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9D%9E%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.2.8.2.1.</span> <span class="toc-text">创建非分区表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.2.8.2.2.</span> <span class="toc-text">创建分区表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E6%9C%89%E7%9A%84hudi%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A1%A8-%E9%9D%9E%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.8.2.3.</span> <span class="toc-text">在已有的hudi表上创建新表-非分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E6%9C%89%E7%9A%84hudi%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E6%96%B0%E8%A1%A8-%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.2.8.2.4.</span> <span class="toc-text">在已有的hudi表上创建新表-分区表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87CTAS-Create-Table-As-Select-%E5%BB%BA%E8%A1%A8-%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.8.2.5.</span> <span class="toc-text">通过CTAS(Create Table As Select)建表-分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87CTAS%E4%BB%8E%E5%85%B6%E4%BB%96%E8%A1%A8%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.8.2.6.</span> <span class="toc-text">通过CTAS从其他表加载数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">插入&amp;查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE-Update"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">更新数据_Update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE-MergeInto"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">更新数据_MergeInto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-%E8%A6%86%E7%9B%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.8.6.</span> <span class="toc-text">删除&amp;覆盖数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E3%80%81%E5%88%86%E5%8C%BA-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.8.7.</span> <span class="toc-text">修改表结构、分区&amp;存储过程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/02/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive/" title="无题">无题</a><time datetime="2025-07-02T10:28:32.791Z" title="发表于 2025-07-02 18:28:32">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/" title="无题">无题</a><time datetime="2025-07-02T03:31:20.020Z" title="发表于 2025-07-02 11:31:20">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0PythonJava%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0PythonJava%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/" title="无题">无题</a><time datetime="2025-05-14T04:06:50.987Z" title="发表于 2025-05-14 12:06:50">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0Python/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/05/14/%E5%BB%96%E9%9B%AA%E5%B3%B0Python/" title="无题">无题</a><time datetime="2025-05-14T04:02:32.996Z" title="发表于 2025-05-14 12:02:32">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2025/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2025-04-16T02:11:28.562Z" title="发表于 2025-04-16 10:11:28">2025-04-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="智汇君" target="_blank">智汇君</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://video-b2g.pages.dev/" title="视频解析"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/视频.png" alt="视频解析"/><span class="back-menu-item-text">视频解析</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://md5-uir.pages.dev/" title="md5值解密"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/MD5.png" alt="md5值解密"/><span class="back-menu-item-text">md5值解密</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://screencheck.pages.dev/#welcome" title="屏幕坏点检查"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/屏幕外观.png" alt="屏幕坏点检查"/><span class="back-menu-item-text">屏幕坏点检查</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://htmleditor-9lo.pages.dev/" title="在线html编辑器"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/html编辑器.png" alt="在线html编辑器"/><span class="back-menu-item-text">在线html编辑器</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">博客</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ttyong-github-io.pages.dev/" title="旧博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/博客.png" alt="旧博客"/><span class="back-menu-item-text">旧博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/GitHub/" style="font-size: 0.88rem;">GitHub<sup>1</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem;">Hexo<sup>1</sup></a><a href="/tags/NodeJs/" style="font-size: 0.88rem;">NodeJs<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>3</sup></a><a href="/tags/github/" style="font-size: 0.88rem;">github<sup>1</sup></a><a href="/tags/idea/" style="font-size: 0.88rem;">idea<sup>1</sup></a><a href="/tags/%E5%85%AC%E8%80%83%E6%9D%A8%E8%80%81%E5%B8%88/" style="font-size: 0.88rem;">公考杨老师<sup>10</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 0.88rem;">大数据<sup>27</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B8%BB%E9%A2%98/" style="font-size: 0.88rem;">安知鱼主题<sup>1</sup></a><a href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/" style="font-size: 0.88rem;">廖雪峰<sup>9</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>12</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("24/12/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 智汇君 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("24/12/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4792307_02gxbpyxcpwp.js?spm=a313x.manage_type_myprojects.i1.10.56323a81KZGFDE&amp;file=font_4792307_02gxbpyxcpwp.js# 阿里图标symbol 引用链接，主题会进行加载 symbol 引用"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>